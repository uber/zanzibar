{{/* template to render gateway http endpoint code */ -}}
// Code generated by zanzibar
// @generated

package {{.PackageName}}

import (
	"context"
	"io/ioutil"
	"net/http"

	"github.com/pkg/errors"
	"github.com/uber-go/zap"
	"{{.GatewayPackageName}}/clients"
	zanzibar "github.com/uber/zanzibar/runtime"

	{{range $idx, $pkg := .IncludedPackages -}}
	"{{$pkg}}"
	{{end}}

	{{range $idx, $pkg := .Method.Downstream.IncludedPackages -}}
	{{$file := basePath $pkg -}}
	clientType{{ title $file }} "{{$pkg}}"
	{{end}}
)

{{with .Method -}}
{{- $clientPackage := .Downstream.PackageName -}}
{{- $clientName := title .DownstreamService -}}
{{- $clientMethod := .DownstreamMethod -}}
{{- $clientMethodRequestType := fullTypeName ($clientMethod).RequestType ($clientPackage) -}}
{{- $clientMethodResponseType := fullTypeName  ($clientMethod).ResponseType ($clientPackage) -}}

// Handle{{title .Name}}Request handles "{{.HTTPPath}}".
func Handle{{title .Name}}Request(
	ctx context.Context,
	req *zanzibar.IncomingHTTPRequest,
	res *zanzibar.OutgoingHTTPResponse,
	g *zanzibar.Gateway,
	clients *clients.Clients,
) {
	// Handle request headers.
	h := http.Header{}
	{{ if .Headers -}}
	for _, header := range {{.Headers | printf "%#v"}} {
		h.Set(header, req.Header.Get(header))
	}
	{{- end}}

	// Handle request body.
	{{if or (eq .RequestType "") (eq $clientMethodRequestType "") -}}
	clientResp, err := clients.{{$clientName}}.{{title ($clientMethod).Name}}(ctx, h)

	{{- else -}}
		var body {{title .RequestType}}
		if ok := req.ReadAndUnmarshalBody(&body); !ok {
			return
		}
		clientRequest := convertTo{{title .Name}}ClientRequest(&body)
		clientResp, err := clients.{{$clientName}}.{{title ($clientMethod).Name}}(ctx, clientRequest, h)
	{{- end }}
	if err != nil {
		g.Logger.Error("Could not make client request",
			zap.String("error", err.Error()),
		)
		res.SendError(500, errors.Wrap(err, "could not make client request:"))
		return
	}
	
    defer func() {
        if cerr := clientResp.Body.Close(); cerr != nil && err == nil {
            err = cerr
        }
    }()

	// Handle client respnse.
	if !res.IsOKResponse(clientResp.StatusCode, {{statusCodes .OKStatusCode}}) {
		g.Logger.Warn("Unknown response status code",
			zap.Int("status code", clientResp.StatusCode),
		)
	}
	{{if or (eq $clientMethodResponseType "") (eq .ResponseType "") -}}
	res.WriteJSONBytes(clientResp.StatusCode, nil)
	{{- else -}}
	b, err := ioutil.ReadAll(clientResp.Body)
	if err != nil {
		res.SendError(500, errors.Wrap(err, "could not read client response body:"))
		return
	}
	var clientRespBody {{$clientMethodResponseType}}
	if err := clientRespBody.UnmarshalJSON(b); err != nil {
	 	res.SendError(500, errors.Wrap(err, "could not unmarshal client response body:"))
	 	return
	}
	response := convert{{title .Name}}ClientResponse(&clientRespBody)
	res.WriteJSON(clientResp.StatusCode, response)
	{{- end -}}
}

{{if and (ne .RequestType "") (ne $clientMethodRequestType "") -}}
func convertTo{{title .Name}}ClientRequest(body *{{title .RequestType}}) *{{$clientMethodRequestType}} {
	clientRequest := &{{$clientMethodRequestType}}{}

	{{ range $key, $value := .RequestFieldMap -}}
	{{ range $name, $type := $.Method.RequestTypeMap -}} {{if eq $name $key -}}
	clientRequest.{{title $key }} = {{ $type }}(body.{{title $value }})
	{{ end -}}
	{{ end -}}
	{{ end }}
	return clientRequest
}
{{end -}}


{{if and (ne .ResponseType "") (ne $clientMethodResponseType "") -}}
func convert{{title .Name}}ClientResponse(body *{{$clientMethodResponseType}}) *{{.ResponseType}} {
	// TODO: Add response fields mapping here.
	downstreamResponse := &{{.ResponseType}}{}
	return downstreamResponse
}
{{end -}}

{{end -}}
