// Code generated by thriftrw v1.23.0. DO NOT EDIT.
// @generated

package bar

import (
	bytes "bytes"
	base64 "encoding/base64"
	json "encoding/json"
	errors "errors"
	fmt "fmt"
	math "math"
	strconv "strconv"
	strings "strings"

	foo "github.com/uber/zanzibar/examples/selective-gateway/build/gen-code/clients/foo/foo"
	multierr "go.uber.org/multierr"
	wire "go.uber.org/thriftrw/wire"
	zapcore "go.uber.org/zap/zapcore"
)

type BarException struct {
	StringField string `json:"stringField,required"`
}

// ToWire translates a BarException struct into a Thrift-level intermediate
// representation. This intermediate representation may be serialized
// into bytes using a ThriftRW protocol implementation.
//
// An error is returned if the struct or any of its fields failed to
// validate.
//
//   x, err := v.ToWire()
//   if err != nil {
//     return err
//   }
//
//   if err := binaryProtocol.Encode(x, writer); err != nil {
//     return err
//   }
func (v *BarException) ToWire() (wire.Value, error) {
	var (
		fields [1]wire.Field
		i      int = 0
		w      wire.Value
		err    error
	)

	w, err = wire.NewValueString(v.StringField), error(nil)
	if err != nil {
		return w, err
	}
	fields[i] = wire.Field{ID: 1, Value: w}
	i++

	return wire.NewValueStruct(wire.Struct{Fields: fields[:i]}), nil
}

// FromWire deserializes a BarException struct from its Thrift-level
// representation. The Thrift-level representation may be obtained
// from a ThriftRW protocol implementation.
//
// An error is returned if we were unable to build a BarException struct
// from the provided intermediate representation.
//
//   x, err := binaryProtocol.Decode(reader, wire.TStruct)
//   if err != nil {
//     return nil, err
//   }
//
//   var v BarException
//   if err := v.FromWire(x); err != nil {
//     return nil, err
//   }
//   return &v, nil
func (v *BarException) FromWire(w wire.Value) error {
	var err error

	stringFieldIsSet := false

	for _, field := range w.GetStruct().Fields {
		switch field.ID {
		case 1:
			if field.Value.Type() == wire.TBinary {
				v.StringField, err = field.Value.GetString(), error(nil)
				if err != nil {
					return err
				}
				stringFieldIsSet = true
			}
		}
	}

	if !stringFieldIsSet {
		return errors.New("field StringField of BarException is required")
	}

	return nil
}

// String returns a readable string representation of a BarException
// struct.
func (v *BarException) String() string {
	if v == nil {
		return "<nil>"
	}

	var fields [1]string
	i := 0
	fields[i] = fmt.Sprintf("StringField: %v", v.StringField)
	i++

	return fmt.Sprintf("BarException{%v}", strings.Join(fields[:i], ", "))
}

// ErrorName is the name of this type as defined in the Thrift
// file.
func (*BarException) ErrorName() string {
	return "BarException"
}

// Equals returns true if all the fields of this BarException match the
// provided BarException.
//
// This function performs a deep comparison.
func (v *BarException) Equals(rhs *BarException) bool {
	if v == nil {
		return rhs == nil
	} else if rhs == nil {
		return false
	}
	if !(v.StringField == rhs.StringField) {
		return false
	}

	return true
}

// MarshalLogObject implements zapcore.ObjectMarshaler, enabling
// fast logging of BarException.
func (v *BarException) MarshalLogObject(enc zapcore.ObjectEncoder) (err error) {
	if v == nil {
		return nil
	}
	enc.AddString("stringField", v.StringField)
	return err
}

// GetStringField returns the value of StringField if it is set or its
// zero value if it is unset.
func (v *BarException) GetStringField() (o string) {
	if v != nil {
		o = v.StringField
	}
	return
}

func (v *BarException) Error() string {
	return v.String()
}

type BarRequest struct {
	StringField string    `json:"stringField,required"`
	BoolField   bool      `json:"boolField,required"`
	BinaryField []byte    `json:"binaryField,required"`
	Timestamp   Timestamp `json:"timestamp,required"`
	EnumField   Fruit     `json:"enumField,required"`
	LongField   Long      `json:"longField,required"`
}

// ToWire translates a BarRequest struct into a Thrift-level intermediate
// representation. This intermediate representation may be serialized
// into bytes using a ThriftRW protocol implementation.
//
// An error is returned if the struct or any of its fields failed to
// validate.
//
//   x, err := v.ToWire()
//   if err != nil {
//     return err
//   }
//
//   if err := binaryProtocol.Encode(x, writer); err != nil {
//     return err
//   }
func (v *BarRequest) ToWire() (wire.Value, error) {
	var (
		fields [6]wire.Field
		i      int = 0
		w      wire.Value
		err    error
	)

	w, err = wire.NewValueString(v.StringField), error(nil)
	if err != nil {
		return w, err
	}
	fields[i] = wire.Field{ID: 1, Value: w}
	i++

	w, err = wire.NewValueBool(v.BoolField), error(nil)
	if err != nil {
		return w, err
	}
	fields[i] = wire.Field{ID: 2, Value: w}
	i++
	if v.BinaryField == nil {
		return w, errors.New("field BinaryField of BarRequest is required")
	}
	w, err = wire.NewValueBinary(v.BinaryField), error(nil)
	if err != nil {
		return w, err
	}
	fields[i] = wire.Field{ID: 3, Value: w}
	i++

	w, err = v.Timestamp.ToWire()
	if err != nil {
		return w, err
	}
	fields[i] = wire.Field{ID: 4, Value: w}
	i++

	w, err = v.EnumField.ToWire()
	if err != nil {
		return w, err
	}
	fields[i] = wire.Field{ID: 5, Value: w}
	i++

	w, err = v.LongField.ToWire()
	if err != nil {
		return w, err
	}
	fields[i] = wire.Field{ID: 6, Value: w}
	i++

	return wire.NewValueStruct(wire.Struct{Fields: fields[:i]}), nil
}

func _Timestamp_Read(w wire.Value) (Timestamp, error) {
	var x Timestamp
	err := x.FromWire(w)
	return x, err
}

func _Fruit_Read(w wire.Value) (Fruit, error) {
	var v Fruit
	err := v.FromWire(w)
	return v, err
}

func _Long_Read(w wire.Value) (Long, error) {
	var x Long
	err := x.FromWire(w)
	return x, err
}

// FromWire deserializes a BarRequest struct from its Thrift-level
// representation. The Thrift-level representation may be obtained
// from a ThriftRW protocol implementation.
//
// An error is returned if we were unable to build a BarRequest struct
// from the provided intermediate representation.
//
//   x, err := binaryProtocol.Decode(reader, wire.TStruct)
//   if err != nil {
//     return nil, err
//   }
//
//   var v BarRequest
//   if err := v.FromWire(x); err != nil {
//     return nil, err
//   }
//   return &v, nil
func (v *BarRequest) FromWire(w wire.Value) error {
	var err error

	stringFieldIsSet := false
	boolFieldIsSet := false
	binaryFieldIsSet := false
	timestampIsSet := false
	enumFieldIsSet := false
	longFieldIsSet := false

	for _, field := range w.GetStruct().Fields {
		switch field.ID {
		case 1:
			if field.Value.Type() == wire.TBinary {
				v.StringField, err = field.Value.GetString(), error(nil)
				if err != nil {
					return err
				}
				stringFieldIsSet = true
			}
		case 2:
			if field.Value.Type() == wire.TBool {
				v.BoolField, err = field.Value.GetBool(), error(nil)
				if err != nil {
					return err
				}
				boolFieldIsSet = true
			}
		case 3:
			if field.Value.Type() == wire.TBinary {
				v.BinaryField, err = field.Value.GetBinary(), error(nil)
				if err != nil {
					return err
				}
				binaryFieldIsSet = true
			}
		case 4:
			if field.Value.Type() == wire.TI64 {
				v.Timestamp, err = _Timestamp_Read(field.Value)
				if err != nil {
					return err
				}
				timestampIsSet = true
			}
		case 5:
			if field.Value.Type() == wire.TI32 {
				v.EnumField, err = _Fruit_Read(field.Value)
				if err != nil {
					return err
				}
				enumFieldIsSet = true
			}
		case 6:
			if field.Value.Type() == wire.TI64 {
				v.LongField, err = _Long_Read(field.Value)
				if err != nil {
					return err
				}
				longFieldIsSet = true
			}
		}
	}

	if !stringFieldIsSet {
		return errors.New("field StringField of BarRequest is required")
	}

	if !boolFieldIsSet {
		return errors.New("field BoolField of BarRequest is required")
	}

	if !binaryFieldIsSet {
		return errors.New("field BinaryField of BarRequest is required")
	}

	if !timestampIsSet {
		return errors.New("field Timestamp of BarRequest is required")
	}

	if !enumFieldIsSet {
		return errors.New("field EnumField of BarRequest is required")
	}

	if !longFieldIsSet {
		return errors.New("field LongField of BarRequest is required")
	}

	return nil
}

// String returns a readable string representation of a BarRequest
// struct.
func (v *BarRequest) String() string {
	if v == nil {
		return "<nil>"
	}

	var fields [6]string
	i := 0
	fields[i] = fmt.Sprintf("StringField: %v", v.StringField)
	i++
	fields[i] = fmt.Sprintf("BoolField: %v", v.BoolField)
	i++
	fields[i] = fmt.Sprintf("BinaryField: %v", v.BinaryField)
	i++
	fields[i] = fmt.Sprintf("Timestamp: %v", v.Timestamp)
	i++
	fields[i] = fmt.Sprintf("EnumField: %v", v.EnumField)
	i++
	fields[i] = fmt.Sprintf("LongField: %v", v.LongField)
	i++

	return fmt.Sprintf("BarRequest{%v}", strings.Join(fields[:i], ", "))
}

// Equals returns true if all the fields of this BarRequest match the
// provided BarRequest.
//
// This function performs a deep comparison.
func (v *BarRequest) Equals(rhs *BarRequest) bool {
	if v == nil {
		return rhs == nil
	} else if rhs == nil {
		return false
	}
	if !(v.StringField == rhs.StringField) {
		return false
	}
	if !(v.BoolField == rhs.BoolField) {
		return false
	}
	if !bytes.Equal(v.BinaryField, rhs.BinaryField) {
		return false
	}
	if !(v.Timestamp == rhs.Timestamp) {
		return false
	}
	if !v.EnumField.Equals(rhs.EnumField) {
		return false
	}
	if !(v.LongField == rhs.LongField) {
		return false
	}

	return true
}

// MarshalLogObject implements zapcore.ObjectMarshaler, enabling
// fast logging of BarRequest.
func (v *BarRequest) MarshalLogObject(enc zapcore.ObjectEncoder) (err error) {
	if v == nil {
		return nil
	}
	enc.AddString("stringField", v.StringField)
	enc.AddBool("boolField", v.BoolField)
	enc.AddString("binaryField", base64.StdEncoding.EncodeToString(v.BinaryField))
	enc.AddInt64("timestamp", (int64)(v.Timestamp))
	err = multierr.Append(err, enc.AddObject("enumField", v.EnumField))
	enc.AddInt64("longField", (int64)(v.LongField))
	return err
}

// GetStringField returns the value of StringField if it is set or its
// zero value if it is unset.
func (v *BarRequest) GetStringField() (o string) {
	if v != nil {
		o = v.StringField
	}
	return
}

// GetBoolField returns the value of BoolField if it is set or its
// zero value if it is unset.
func (v *BarRequest) GetBoolField() (o bool) {
	if v != nil {
		o = v.BoolField
	}
	return
}

// GetBinaryField returns the value of BinaryField if it is set or its
// zero value if it is unset.
func (v *BarRequest) GetBinaryField() (o []byte) {
	if v != nil {
		o = v.BinaryField
	}
	return
}

// IsSetBinaryField returns true if BinaryField is not nil.
func (v *BarRequest) IsSetBinaryField() bool {
	return v != nil && v.BinaryField != nil
}

// GetTimestamp returns the value of Timestamp if it is set or its
// zero value if it is unset.
func (v *BarRequest) GetTimestamp() (o Timestamp) {
	if v != nil {
		o = v.Timestamp
	}
	return
}

// GetEnumField returns the value of EnumField if it is set or its
// zero value if it is unset.
func (v *BarRequest) GetEnumField() (o Fruit) {
	if v != nil {
		o = v.EnumField
	}
	return
}

// GetLongField returns the value of LongField if it is set or its
// zero value if it is unset.
func (v *BarRequest) GetLongField() (o Long) {
	if v != nil {
		o = v.LongField
	}
	return
}

type BarRequestRecur struct {
	Name  string           `json:"name,required"`
	Recur *BarRequestRecur `json:"recur,omitempty"`
}

// ToWire translates a BarRequestRecur struct into a Thrift-level intermediate
// representation. This intermediate representation may be serialized
// into bytes using a ThriftRW protocol implementation.
//
// An error is returned if the struct or any of its fields failed to
// validate.
//
//   x, err := v.ToWire()
//   if err != nil {
//     return err
//   }
//
//   if err := binaryProtocol.Encode(x, writer); err != nil {
//     return err
//   }
func (v *BarRequestRecur) ToWire() (wire.Value, error) {
	var (
		fields [2]wire.Field
		i      int = 0
		w      wire.Value
		err    error
	)

	w, err = wire.NewValueString(v.Name), error(nil)
	if err != nil {
		return w, err
	}
	fields[i] = wire.Field{ID: 1, Value: w}
	i++
	if v.Recur != nil {
		w, err = v.Recur.ToWire()
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 2, Value: w}
		i++
	}

	return wire.NewValueStruct(wire.Struct{Fields: fields[:i]}), nil
}

func _BarRequestRecur_Read(w wire.Value) (*BarRequestRecur, error) {
	var v BarRequestRecur
	err := v.FromWire(w)
	return &v, err
}

// FromWire deserializes a BarRequestRecur struct from its Thrift-level
// representation. The Thrift-level representation may be obtained
// from a ThriftRW protocol implementation.
//
// An error is returned if we were unable to build a BarRequestRecur struct
// from the provided intermediate representation.
//
//   x, err := binaryProtocol.Decode(reader, wire.TStruct)
//   if err != nil {
//     return nil, err
//   }
//
//   var v BarRequestRecur
//   if err := v.FromWire(x); err != nil {
//     return nil, err
//   }
//   return &v, nil
func (v *BarRequestRecur) FromWire(w wire.Value) error {
	var err error

	nameIsSet := false

	for _, field := range w.GetStruct().Fields {
		switch field.ID {
		case 1:
			if field.Value.Type() == wire.TBinary {
				v.Name, err = field.Value.GetString(), error(nil)
				if err != nil {
					return err
				}
				nameIsSet = true
			}
		case 2:
			if field.Value.Type() == wire.TStruct {
				v.Recur, err = _BarRequestRecur_Read(field.Value)
				if err != nil {
					return err
				}

			}
		}
	}

	if !nameIsSet {
		return errors.New("field Name of BarRequestRecur is required")
	}

	return nil
}

// String returns a readable string representation of a BarRequestRecur
// struct.
func (v *BarRequestRecur) String() string {
	if v == nil {
		return "<nil>"
	}

	var fields [2]string
	i := 0
	fields[i] = fmt.Sprintf("Name: %v", v.Name)
	i++
	if v.Recur != nil {
		fields[i] = fmt.Sprintf("Recur: %v", v.Recur)
		i++
	}

	return fmt.Sprintf("BarRequestRecur{%v}", strings.Join(fields[:i], ", "))
}

// Equals returns true if all the fields of this BarRequestRecur match the
// provided BarRequestRecur.
//
// This function performs a deep comparison.
func (v *BarRequestRecur) Equals(rhs *BarRequestRecur) bool {
	if v == nil {
		return rhs == nil
	} else if rhs == nil {
		return false
	}
	if !(v.Name == rhs.Name) {
		return false
	}
	if !((v.Recur == nil && rhs.Recur == nil) || (v.Recur != nil && rhs.Recur != nil && v.Recur.Equals(rhs.Recur))) {
		return false
	}

	return true
}

// MarshalLogObject implements zapcore.ObjectMarshaler, enabling
// fast logging of BarRequestRecur.
func (v *BarRequestRecur) MarshalLogObject(enc zapcore.ObjectEncoder) (err error) {
	if v == nil {
		return nil
	}
	enc.AddString("name", v.Name)
	if v.Recur != nil {
		err = multierr.Append(err, enc.AddObject("recur", v.Recur))
	}
	return err
}

// GetName returns the value of Name if it is set or its
// zero value if it is unset.
func (v *BarRequestRecur) GetName() (o string) {
	if v != nil {
		o = v.Name
	}
	return
}

// GetRecur returns the value of Recur if it is set or its
// zero value if it is unset.
func (v *BarRequestRecur) GetRecur() (o *BarRequestRecur) {
	if v != nil && v.Recur != nil {
		return v.Recur
	}

	return
}

// IsSetRecur returns true if Recur is not nil.
func (v *BarRequestRecur) IsSetRecur() bool {
	return v != nil && v.Recur != nil
}

type BarResponse struct {
	StringField        string           `json:"stringField,required"`
	IntWithRange       int32            `json:"intWithRange,required"`
	IntWithoutRange    int32            `json:"intWithoutRange,required"`
	MapIntWithRange    map[UUID]int32   `json:"mapIntWithRange,required"`
	MapIntWithoutRange map[string]int32 `json:"mapIntWithoutRange,required"`
	BinaryField        []byte           `json:"binaryField,required"`
	NextResponse       *BarResponse     `json:"nextResponse,omitempty"`
}

type _Map_UUID_I32_MapItemList map[UUID]int32

func (m _Map_UUID_I32_MapItemList) ForEach(f func(wire.MapItem) error) error {
	for k, v := range m {
		kw, err := k.ToWire()
		if err != nil {
			return err
		}

		vw, err := wire.NewValueI32(v), error(nil)
		if err != nil {
			return err
		}
		err = f(wire.MapItem{Key: kw, Value: vw})
		if err != nil {
			return err
		}
	}
	return nil
}

func (m _Map_UUID_I32_MapItemList) Size() int {
	return len(m)
}

func (_Map_UUID_I32_MapItemList) KeyType() wire.Type {
	return wire.TBinary
}

func (_Map_UUID_I32_MapItemList) ValueType() wire.Type {
	return wire.TI32
}

func (_Map_UUID_I32_MapItemList) Close() {}

type _Map_String_I32_MapItemList map[string]int32

func (m _Map_String_I32_MapItemList) ForEach(f func(wire.MapItem) error) error {
	for k, v := range m {
		kw, err := wire.NewValueString(k), error(nil)
		if err != nil {
			return err
		}

		vw, err := wire.NewValueI32(v), error(nil)
		if err != nil {
			return err
		}
		err = f(wire.MapItem{Key: kw, Value: vw})
		if err != nil {
			return err
		}
	}
	return nil
}

func (m _Map_String_I32_MapItemList) Size() int {
	return len(m)
}

func (_Map_String_I32_MapItemList) KeyType() wire.Type {
	return wire.TBinary
}

func (_Map_String_I32_MapItemList) ValueType() wire.Type {
	return wire.TI32
}

func (_Map_String_I32_MapItemList) Close() {}

// ToWire translates a BarResponse struct into a Thrift-level intermediate
// representation. This intermediate representation may be serialized
// into bytes using a ThriftRW protocol implementation.
//
// An error is returned if the struct or any of its fields failed to
// validate.
//
//   x, err := v.ToWire()
//   if err != nil {
//     return err
//   }
//
//   if err := binaryProtocol.Encode(x, writer); err != nil {
//     return err
//   }
func (v *BarResponse) ToWire() (wire.Value, error) {
	var (
		fields [7]wire.Field
		i      int = 0
		w      wire.Value
		err    error
	)

	w, err = wire.NewValueString(v.StringField), error(nil)
	if err != nil {
		return w, err
	}
	fields[i] = wire.Field{ID: 1, Value: w}
	i++

	w, err = wire.NewValueI32(v.IntWithRange), error(nil)
	if err != nil {
		return w, err
	}
	fields[i] = wire.Field{ID: 2, Value: w}
	i++

	w, err = wire.NewValueI32(v.IntWithoutRange), error(nil)
	if err != nil {
		return w, err
	}
	fields[i] = wire.Field{ID: 3, Value: w}
	i++
	if v.MapIntWithRange == nil {
		return w, errors.New("field MapIntWithRange of BarResponse is required")
	}
	w, err = wire.NewValueMap(_Map_UUID_I32_MapItemList(v.MapIntWithRange)), error(nil)
	if err != nil {
		return w, err
	}
	fields[i] = wire.Field{ID: 4, Value: w}
	i++
	if v.MapIntWithoutRange == nil {
		return w, errors.New("field MapIntWithoutRange of BarResponse is required")
	}
	w, err = wire.NewValueMap(_Map_String_I32_MapItemList(v.MapIntWithoutRange)), error(nil)
	if err != nil {
		return w, err
	}
	fields[i] = wire.Field{ID: 5, Value: w}
	i++
	if v.BinaryField == nil {
		return w, errors.New("field BinaryField of BarResponse is required")
	}
	w, err = wire.NewValueBinary(v.BinaryField), error(nil)
	if err != nil {
		return w, err
	}
	fields[i] = wire.Field{ID: 6, Value: w}
	i++
	if v.NextResponse != nil {
		w, err = v.NextResponse.ToWire()
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 7, Value: w}
		i++
	}

	return wire.NewValueStruct(wire.Struct{Fields: fields[:i]}), nil
}

func _UUID_Read(w wire.Value) (UUID, error) {
	var x UUID
	err := x.FromWire(w)
	return x, err
}

func _Map_UUID_I32_Read(m wire.MapItemList) (map[UUID]int32, error) {
	if m.KeyType() != wire.TBinary {
		return nil, nil
	}

	if m.ValueType() != wire.TI32 {
		return nil, nil
	}

	o := make(map[UUID]int32, m.Size())
	err := m.ForEach(func(x wire.MapItem) error {
		k, err := _UUID_Read(x.Key)
		if err != nil {
			return err
		}

		v, err := x.Value.GetI32(), error(nil)
		if err != nil {
			return err
		}

		o[k] = v
		return nil
	})
	m.Close()
	return o, err
}

func _Map_String_I32_Read(m wire.MapItemList) (map[string]int32, error) {
	if m.KeyType() != wire.TBinary {
		return nil, nil
	}

	if m.ValueType() != wire.TI32 {
		return nil, nil
	}

	o := make(map[string]int32, m.Size())
	err := m.ForEach(func(x wire.MapItem) error {
		k, err := x.Key.GetString(), error(nil)
		if err != nil {
			return err
		}

		v, err := x.Value.GetI32(), error(nil)
		if err != nil {
			return err
		}

		o[k] = v
		return nil
	})
	m.Close()
	return o, err
}

func _BarResponse_Read(w wire.Value) (*BarResponse, error) {
	var v BarResponse
	err := v.FromWire(w)
	return &v, err
}

// FromWire deserializes a BarResponse struct from its Thrift-level
// representation. The Thrift-level representation may be obtained
// from a ThriftRW protocol implementation.
//
// An error is returned if we were unable to build a BarResponse struct
// from the provided intermediate representation.
//
//   x, err := binaryProtocol.Decode(reader, wire.TStruct)
//   if err != nil {
//     return nil, err
//   }
//
//   var v BarResponse
//   if err := v.FromWire(x); err != nil {
//     return nil, err
//   }
//   return &v, nil
func (v *BarResponse) FromWire(w wire.Value) error {
	var err error

	stringFieldIsSet := false
	intWithRangeIsSet := false
	intWithoutRangeIsSet := false
	mapIntWithRangeIsSet := false
	mapIntWithoutRangeIsSet := false
	binaryFieldIsSet := false

	for _, field := range w.GetStruct().Fields {
		switch field.ID {
		case 1:
			if field.Value.Type() == wire.TBinary {
				v.StringField, err = field.Value.GetString(), error(nil)
				if err != nil {
					return err
				}
				stringFieldIsSet = true
			}
		case 2:
			if field.Value.Type() == wire.TI32 {
				v.IntWithRange, err = field.Value.GetI32(), error(nil)
				if err != nil {
					return err
				}
				intWithRangeIsSet = true
			}
		case 3:
			if field.Value.Type() == wire.TI32 {
				v.IntWithoutRange, err = field.Value.GetI32(), error(nil)
				if err != nil {
					return err
				}
				intWithoutRangeIsSet = true
			}
		case 4:
			if field.Value.Type() == wire.TMap {
				v.MapIntWithRange, err = _Map_UUID_I32_Read(field.Value.GetMap())
				if err != nil {
					return err
				}
				mapIntWithRangeIsSet = true
			}
		case 5:
			if field.Value.Type() == wire.TMap {
				v.MapIntWithoutRange, err = _Map_String_I32_Read(field.Value.GetMap())
				if err != nil {
					return err
				}
				mapIntWithoutRangeIsSet = true
			}
		case 6:
			if field.Value.Type() == wire.TBinary {
				v.BinaryField, err = field.Value.GetBinary(), error(nil)
				if err != nil {
					return err
				}
				binaryFieldIsSet = true
			}
		case 7:
			if field.Value.Type() == wire.TStruct {
				v.NextResponse, err = _BarResponse_Read(field.Value)
				if err != nil {
					return err
				}

			}
		}
	}

	if !stringFieldIsSet {
		return errors.New("field StringField of BarResponse is required")
	}

	if !intWithRangeIsSet {
		return errors.New("field IntWithRange of BarResponse is required")
	}

	if !intWithoutRangeIsSet {
		return errors.New("field IntWithoutRange of BarResponse is required")
	}

	if !mapIntWithRangeIsSet {
		return errors.New("field MapIntWithRange of BarResponse is required")
	}

	if !mapIntWithoutRangeIsSet {
		return errors.New("field MapIntWithoutRange of BarResponse is required")
	}

	if !binaryFieldIsSet {
		return errors.New("field BinaryField of BarResponse is required")
	}

	return nil
}

// String returns a readable string representation of a BarResponse
// struct.
func (v *BarResponse) String() string {
	if v == nil {
		return "<nil>"
	}

	var fields [7]string
	i := 0
	fields[i] = fmt.Sprintf("StringField: %v", v.StringField)
	i++
	fields[i] = fmt.Sprintf("IntWithRange: %v", v.IntWithRange)
	i++
	fields[i] = fmt.Sprintf("IntWithoutRange: %v", v.IntWithoutRange)
	i++
	fields[i] = fmt.Sprintf("MapIntWithRange: %v", v.MapIntWithRange)
	i++
	fields[i] = fmt.Sprintf("MapIntWithoutRange: %v", v.MapIntWithoutRange)
	i++
	fields[i] = fmt.Sprintf("BinaryField: %v", v.BinaryField)
	i++
	if v.NextResponse != nil {
		fields[i] = fmt.Sprintf("NextResponse: %v", v.NextResponse)
		i++
	}

	return fmt.Sprintf("BarResponse{%v}", strings.Join(fields[:i], ", "))
}

func _Map_UUID_I32_Equals(lhs, rhs map[UUID]int32) bool {
	if len(lhs) != len(rhs) {
		return false
	}

	for lk, lv := range lhs {
		rv, ok := rhs[lk]
		if !ok {
			return false
		}
		if !(lv == rv) {
			return false
		}
	}
	return true
}

func _Map_String_I32_Equals(lhs, rhs map[string]int32) bool {
	if len(lhs) != len(rhs) {
		return false
	}

	for lk, lv := range lhs {
		rv, ok := rhs[lk]
		if !ok {
			return false
		}
		if !(lv == rv) {
			return false
		}
	}
	return true
}

// Equals returns true if all the fields of this BarResponse match the
// provided BarResponse.
//
// This function performs a deep comparison.
func (v *BarResponse) Equals(rhs *BarResponse) bool {
	if v == nil {
		return rhs == nil
	} else if rhs == nil {
		return false
	}
	if !(v.StringField == rhs.StringField) {
		return false
	}
	if !(v.IntWithRange == rhs.IntWithRange) {
		return false
	}
	if !(v.IntWithoutRange == rhs.IntWithoutRange) {
		return false
	}
	if !_Map_UUID_I32_Equals(v.MapIntWithRange, rhs.MapIntWithRange) {
		return false
	}
	if !_Map_String_I32_Equals(v.MapIntWithoutRange, rhs.MapIntWithoutRange) {
		return false
	}
	if !bytes.Equal(v.BinaryField, rhs.BinaryField) {
		return false
	}
	if !((v.NextResponse == nil && rhs.NextResponse == nil) || (v.NextResponse != nil && rhs.NextResponse != nil && v.NextResponse.Equals(rhs.NextResponse))) {
		return false
	}

	return true
}

type _Map_UUID_I32_Zapper map[UUID]int32

// MarshalLogObject implements zapcore.ObjectMarshaler, enabling
// fast logging of _Map_UUID_I32_Zapper.
func (m _Map_UUID_I32_Zapper) MarshalLogObject(enc zapcore.ObjectEncoder) (err error) {
	for k, v := range m {
		enc.AddInt32((string)(k), v)
	}
	return err
}

type _Map_String_I32_Zapper map[string]int32

// MarshalLogObject implements zapcore.ObjectMarshaler, enabling
// fast logging of _Map_String_I32_Zapper.
func (m _Map_String_I32_Zapper) MarshalLogObject(enc zapcore.ObjectEncoder) (err error) {
	for k, v := range m {
		enc.AddInt32((string)(k), v)
	}
	return err
}

// MarshalLogObject implements zapcore.ObjectMarshaler, enabling
// fast logging of BarResponse.
func (v *BarResponse) MarshalLogObject(enc zapcore.ObjectEncoder) (err error) {
	if v == nil {
		return nil
	}
	enc.AddString("stringField", v.StringField)
	enc.AddInt32("intWithRange", v.IntWithRange)
	enc.AddInt32("intWithoutRange", v.IntWithoutRange)
	err = multierr.Append(err, enc.AddObject("mapIntWithRange", (_Map_UUID_I32_Zapper)(v.MapIntWithRange)))
	err = multierr.Append(err, enc.AddObject("mapIntWithoutRange", (_Map_String_I32_Zapper)(v.MapIntWithoutRange)))
	enc.AddString("binaryField", base64.StdEncoding.EncodeToString(v.BinaryField))
	if v.NextResponse != nil {
		err = multierr.Append(err, enc.AddObject("nextResponse", v.NextResponse))
	}
	return err
}

// GetStringField returns the value of StringField if it is set or its
// zero value if it is unset.
func (v *BarResponse) GetStringField() (o string) {
	if v != nil {
		o = v.StringField
	}
	return
}

// GetIntWithRange returns the value of IntWithRange if it is set or its
// zero value if it is unset.
func (v *BarResponse) GetIntWithRange() (o int32) {
	if v != nil {
		o = v.IntWithRange
	}
	return
}

// GetIntWithoutRange returns the value of IntWithoutRange if it is set or its
// zero value if it is unset.
func (v *BarResponse) GetIntWithoutRange() (o int32) {
	if v != nil {
		o = v.IntWithoutRange
	}
	return
}

// GetMapIntWithRange returns the value of MapIntWithRange if it is set or its
// zero value if it is unset.
func (v *BarResponse) GetMapIntWithRange() (o map[UUID]int32) {
	if v != nil {
		o = v.MapIntWithRange
	}
	return
}

// IsSetMapIntWithRange returns true if MapIntWithRange is not nil.
func (v *BarResponse) IsSetMapIntWithRange() bool {
	return v != nil && v.MapIntWithRange != nil
}

// GetMapIntWithoutRange returns the value of MapIntWithoutRange if it is set or its
// zero value if it is unset.
func (v *BarResponse) GetMapIntWithoutRange() (o map[string]int32) {
	if v != nil {
		o = v.MapIntWithoutRange
	}
	return
}

// IsSetMapIntWithoutRange returns true if MapIntWithoutRange is not nil.
func (v *BarResponse) IsSetMapIntWithoutRange() bool {
	return v != nil && v.MapIntWithoutRange != nil
}

// GetBinaryField returns the value of BinaryField if it is set or its
// zero value if it is unset.
func (v *BarResponse) GetBinaryField() (o []byte) {
	if v != nil {
		o = v.BinaryField
	}
	return
}

// IsSetBinaryField returns true if BinaryField is not nil.
func (v *BarResponse) IsSetBinaryField() bool {
	return v != nil && v.BinaryField != nil
}

// GetNextResponse returns the value of NextResponse if it is set or its
// zero value if it is unset.
func (v *BarResponse) GetNextResponse() (o *BarResponse) {
	if v != nil && v.NextResponse != nil {
		return v.NextResponse
	}

	return
}

// IsSetNextResponse returns true if NextResponse is not nil.
func (v *BarResponse) IsSetNextResponse() bool {
	return v != nil && v.NextResponse != nil
}

type BarResponseRecur struct {
	Nodes  []string `json:"nodes,required"`
	Height int32    `json:"height,required"`
}

type _List_String_ValueList []string

func (v _List_String_ValueList) ForEach(f func(wire.Value) error) error {
	for _, x := range v {
		w, err := wire.NewValueString(x), error(nil)
		if err != nil {
			return err
		}
		err = f(w)
		if err != nil {
			return err
		}
	}
	return nil
}

func (v _List_String_ValueList) Size() int {
	return len(v)
}

func (_List_String_ValueList) ValueType() wire.Type {
	return wire.TBinary
}

func (_List_String_ValueList) Close() {}

// ToWire translates a BarResponseRecur struct into a Thrift-level intermediate
// representation. This intermediate representation may be serialized
// into bytes using a ThriftRW protocol implementation.
//
// An error is returned if the struct or any of its fields failed to
// validate.
//
//   x, err := v.ToWire()
//   if err != nil {
//     return err
//   }
//
//   if err := binaryProtocol.Encode(x, writer); err != nil {
//     return err
//   }
func (v *BarResponseRecur) ToWire() (wire.Value, error) {
	var (
		fields [2]wire.Field
		i      int = 0
		w      wire.Value
		err    error
	)

	w, err = wire.NewValueList(_List_String_ValueList(v.Nodes)), error(nil)
	if err != nil {
		return w, err
	}
	fields[i] = wire.Field{ID: 1, Value: w}
	i++

	w, err = wire.NewValueI32(v.Height), error(nil)
	if err != nil {
		return w, err
	}
	fields[i] = wire.Field{ID: 2, Value: w}
	i++

	return wire.NewValueStruct(wire.Struct{Fields: fields[:i]}), nil
}

func _List_String_Read(l wire.ValueList) ([]string, error) {
	if l.ValueType() != wire.TBinary {
		return nil, nil
	}

	o := make([]string, 0, l.Size())
	err := l.ForEach(func(x wire.Value) error {
		i, err := x.GetString(), error(nil)
		if err != nil {
			return err
		}
		o = append(o, i)
		return nil
	})
	l.Close()
	return o, err
}

// FromWire deserializes a BarResponseRecur struct from its Thrift-level
// representation. The Thrift-level representation may be obtained
// from a ThriftRW protocol implementation.
//
// An error is returned if we were unable to build a BarResponseRecur struct
// from the provided intermediate representation.
//
//   x, err := binaryProtocol.Decode(reader, wire.TStruct)
//   if err != nil {
//     return nil, err
//   }
//
//   var v BarResponseRecur
//   if err := v.FromWire(x); err != nil {
//     return nil, err
//   }
//   return &v, nil
func (v *BarResponseRecur) FromWire(w wire.Value) error {
	var err error

	nodesIsSet := false
	heightIsSet := false

	for _, field := range w.GetStruct().Fields {
		switch field.ID {
		case 1:
			if field.Value.Type() == wire.TList {
				v.Nodes, err = _List_String_Read(field.Value.GetList())
				if err != nil {
					return err
				}
				nodesIsSet = true
			}
		case 2:
			if field.Value.Type() == wire.TI32 {
				v.Height, err = field.Value.GetI32(), error(nil)
				if err != nil {
					return err
				}
				heightIsSet = true
			}
		}
	}

	if !nodesIsSet {
		return errors.New("field Nodes of BarResponseRecur is required")
	}

	if !heightIsSet {
		return errors.New("field Height of BarResponseRecur is required")
	}

	return nil
}

// String returns a readable string representation of a BarResponseRecur
// struct.
func (v *BarResponseRecur) String() string {
	if v == nil {
		return "<nil>"
	}

	var fields [2]string
	i := 0
	fields[i] = fmt.Sprintf("Nodes: %v", v.Nodes)
	i++
	fields[i] = fmt.Sprintf("Height: %v", v.Height)
	i++

	return fmt.Sprintf("BarResponseRecur{%v}", strings.Join(fields[:i], ", "))
}

func _List_String_Equals(lhs, rhs []string) bool {
	if len(lhs) != len(rhs) {
		return false
	}

	for i, lv := range lhs {
		rv := rhs[i]
		if !(lv == rv) {
			return false
		}
	}

	return true
}

// Equals returns true if all the fields of this BarResponseRecur match the
// provided BarResponseRecur.
//
// This function performs a deep comparison.
func (v *BarResponseRecur) Equals(rhs *BarResponseRecur) bool {
	if v == nil {
		return rhs == nil
	} else if rhs == nil {
		return false
	}
	if !_List_String_Equals(v.Nodes, rhs.Nodes) {
		return false
	}
	if !(v.Height == rhs.Height) {
		return false
	}

	return true
}

type _List_String_Zapper []string

// MarshalLogArray implements zapcore.ArrayMarshaler, enabling
// fast logging of _List_String_Zapper.
func (l _List_String_Zapper) MarshalLogArray(enc zapcore.ArrayEncoder) (err error) {
	for _, v := range l {
		enc.AppendString(v)
	}
	return err
}

// MarshalLogObject implements zapcore.ObjectMarshaler, enabling
// fast logging of BarResponseRecur.
func (v *BarResponseRecur) MarshalLogObject(enc zapcore.ObjectEncoder) (err error) {
	if v == nil {
		return nil
	}
	err = multierr.Append(err, enc.AddArray("nodes", (_List_String_Zapper)(v.Nodes)))
	enc.AddInt32("height", v.Height)
	return err
}

// GetNodes returns the value of Nodes if it is set or its
// zero value if it is unset.
func (v *BarResponseRecur) GetNodes() (o []string) {
	if v != nil {
		o = v.Nodes
	}
	return
}

// IsSetNodes returns true if Nodes is not nil.
func (v *BarResponseRecur) IsSetNodes() bool {
	return v != nil && v.Nodes != nil
}

// GetHeight returns the value of Height if it is set or its
// zero value if it is unset.
func (v *BarResponseRecur) GetHeight() (o int32) {
	if v != nil {
		o = v.Height
	}
	return
}

type DemoType int32

const (
	DemoTypeFirst  DemoType = 0
	DemoTypeSecond DemoType = 1
)

// DemoType_Values returns all recognized values of DemoType.
func DemoType_Values() []DemoType {
	return []DemoType{
		DemoTypeFirst,
		DemoTypeSecond,
	}
}

// UnmarshalText tries to decode DemoType from a byte slice
// containing its name.
//
//   var v DemoType
//   err := v.UnmarshalText([]byte("FIRST"))
func (v *DemoType) UnmarshalText(value []byte) error {
	switch s := string(value); s {
	case "FIRST":
		*v = DemoTypeFirst
		return nil
	case "SECOND":
		*v = DemoTypeSecond
		return nil
	default:
		val, err := strconv.ParseInt(s, 10, 32)
		if err != nil {
			return fmt.Errorf("unknown enum value %q for %q: %v", s, "DemoType", err)
		}
		*v = DemoType(val)
		return nil
	}
}

// MarshalText encodes DemoType to text.
//
// If the enum value is recognized, its name is returned. Otherwise,
// its integer value is returned.
//
// This implements the TextMarshaler interface.
func (v DemoType) MarshalText() ([]byte, error) {
	switch int32(v) {
	case 0:
		return []byte("FIRST"), nil
	case 1:
		return []byte("SECOND"), nil
	}
	return []byte(strconv.FormatInt(int64(v), 10)), nil
}

// MarshalLogObject implements zapcore.ObjectMarshaler, enabling
// fast logging of DemoType.
// Enums are logged as objects, where the value is logged with key "value", and
// if this value's name is known, the name is logged with key "name".
func (v DemoType) MarshalLogObject(enc zapcore.ObjectEncoder) error {
	enc.AddInt32("value", int32(v))
	switch int32(v) {
	case 0:
		enc.AddString("name", "FIRST")
	case 1:
		enc.AddString("name", "SECOND")
	}
	return nil
}

// Ptr returns a pointer to this enum value.
func (v DemoType) Ptr() *DemoType {
	return &v
}

// ToWire translates DemoType into a Thrift-level intermediate
// representation. This intermediate representation may be serialized
// into bytes using a ThriftRW protocol implementation.
//
// Enums are represented as 32-bit integers over the wire.
func (v DemoType) ToWire() (wire.Value, error) {
	return wire.NewValueI32(int32(v)), nil
}

// FromWire deserializes DemoType from its Thrift-level
// representation.
//
//   x, err := binaryProtocol.Decode(reader, wire.TI32)
//   if err != nil {
//     return DemoType(0), err
//   }
//
//   var v DemoType
//   if err := v.FromWire(x); err != nil {
//     return DemoType(0), err
//   }
//   return v, nil
func (v *DemoType) FromWire(w wire.Value) error {
	*v = (DemoType)(w.GetI32())
	return nil
}

// String returns a readable string representation of DemoType.
func (v DemoType) String() string {
	w := int32(v)
	switch w {
	case 0:
		return "FIRST"
	case 1:
		return "SECOND"
	}
	return fmt.Sprintf("DemoType(%d)", w)
}

// Equals returns true if this DemoType value matches the provided
// value.
func (v DemoType) Equals(rhs DemoType) bool {
	return v == rhs
}

// MarshalJSON serializes DemoType into JSON.
//
// If the enum value is recognized, its name is returned. Otherwise,
// its integer value is returned.
//
// This implements json.Marshaler.
func (v DemoType) MarshalJSON() ([]byte, error) {
	switch int32(v) {
	case 0:
		return ([]byte)("\"FIRST\""), nil
	case 1:
		return ([]byte)("\"SECOND\""), nil
	}
	return ([]byte)(strconv.FormatInt(int64(v), 10)), nil
}

// UnmarshalJSON attempts to decode DemoType from its JSON
// representation.
//
// This implementation supports both, numeric and string inputs. If a
// string is provided, it must be a known enum name.
//
// This implements json.Unmarshaler.
func (v *DemoType) UnmarshalJSON(text []byte) error {
	d := json.NewDecoder(bytes.NewReader(text))
	d.UseNumber()
	t, err := d.Token()
	if err != nil {
		return err
	}

	switch w := t.(type) {
	case json.Number:
		x, err := w.Int64()
		if err != nil {
			return err
		}
		if x > math.MaxInt32 {
			return fmt.Errorf("enum overflow from JSON %q for %q", text, "DemoType")
		}
		if x < math.MinInt32 {
			return fmt.Errorf("enum underflow from JSON %q for %q", text, "DemoType")
		}
		*v = (DemoType)(x)
		return nil
	case string:
		return v.UnmarshalText([]byte(w))
	default:
		return fmt.Errorf("invalid JSON value %q (%T) to unmarshal into %q", t, t, "DemoType")
	}
}

type Fruit int32

const (
	FruitApple  Fruit = 0
	FruitBanana Fruit = 1
)

// Fruit_Values returns all recognized values of Fruit.
func Fruit_Values() []Fruit {
	return []Fruit{
		FruitApple,
		FruitBanana,
	}
}

// UnmarshalText tries to decode Fruit from a byte slice
// containing its name.
//
//   var v Fruit
//   err := v.UnmarshalText([]byte("APPLE"))
func (v *Fruit) UnmarshalText(value []byte) error {
	switch s := string(value); s {
	case "APPLE":
		*v = FruitApple
		return nil
	case "BANANA":
		*v = FruitBanana
		return nil
	default:
		val, err := strconv.ParseInt(s, 10, 32)
		if err != nil {
			return fmt.Errorf("unknown enum value %q for %q: %v", s, "Fruit", err)
		}
		*v = Fruit(val)
		return nil
	}
}

// MarshalText encodes Fruit to text.
//
// If the enum value is recognized, its name is returned. Otherwise,
// its integer value is returned.
//
// This implements the TextMarshaler interface.
func (v Fruit) MarshalText() ([]byte, error) {
	switch int32(v) {
	case 0:
		return []byte("APPLE"), nil
	case 1:
		return []byte("BANANA"), nil
	}
	return []byte(strconv.FormatInt(int64(v), 10)), nil
}

// MarshalLogObject implements zapcore.ObjectMarshaler, enabling
// fast logging of Fruit.
// Enums are logged as objects, where the value is logged with key "value", and
// if this value's name is known, the name is logged with key "name".
func (v Fruit) MarshalLogObject(enc zapcore.ObjectEncoder) error {
	enc.AddInt32("value", int32(v))
	switch int32(v) {
	case 0:
		enc.AddString("name", "APPLE")
	case 1:
		enc.AddString("name", "BANANA")
	}
	return nil
}

// Ptr returns a pointer to this enum value.
func (v Fruit) Ptr() *Fruit {
	return &v
}

// ToWire translates Fruit into a Thrift-level intermediate
// representation. This intermediate representation may be serialized
// into bytes using a ThriftRW protocol implementation.
//
// Enums are represented as 32-bit integers over the wire.
func (v Fruit) ToWire() (wire.Value, error) {
	return wire.NewValueI32(int32(v)), nil
}

// FromWire deserializes Fruit from its Thrift-level
// representation.
//
//   x, err := binaryProtocol.Decode(reader, wire.TI32)
//   if err != nil {
//     return Fruit(0), err
//   }
//
//   var v Fruit
//   if err := v.FromWire(x); err != nil {
//     return Fruit(0), err
//   }
//   return v, nil
func (v *Fruit) FromWire(w wire.Value) error {
	*v = (Fruit)(w.GetI32())
	return nil
}

// String returns a readable string representation of Fruit.
func (v Fruit) String() string {
	w := int32(v)
	switch w {
	case 0:
		return "APPLE"
	case 1:
		return "BANANA"
	}
	return fmt.Sprintf("Fruit(%d)", w)
}

// Equals returns true if this Fruit value matches the provided
// value.
func (v Fruit) Equals(rhs Fruit) bool {
	return v == rhs
}

// MarshalJSON serializes Fruit into JSON.
//
// If the enum value is recognized, its name is returned. Otherwise,
// its integer value is returned.
//
// This implements json.Marshaler.
func (v Fruit) MarshalJSON() ([]byte, error) {
	switch int32(v) {
	case 0:
		return ([]byte)("\"APPLE\""), nil
	case 1:
		return ([]byte)("\"BANANA\""), nil
	}
	return ([]byte)(strconv.FormatInt(int64(v), 10)), nil
}

// UnmarshalJSON attempts to decode Fruit from its JSON
// representation.
//
// This implementation supports both, numeric and string inputs. If a
// string is provided, it must be a known enum name.
//
// This implements json.Unmarshaler.
func (v *Fruit) UnmarshalJSON(text []byte) error {
	d := json.NewDecoder(bytes.NewReader(text))
	d.UseNumber()
	t, err := d.Token()
	if err != nil {
		return err
	}

	switch w := t.(type) {
	case json.Number:
		x, err := w.Int64()
		if err != nil {
			return err
		}
		if x > math.MaxInt32 {
			return fmt.Errorf("enum overflow from JSON %q for %q", text, "Fruit")
		}
		if x < math.MinInt32 {
			return fmt.Errorf("enum underflow from JSON %q for %q", text, "Fruit")
		}
		*v = (Fruit)(x)
		return nil
	case string:
		return v.UnmarshalText([]byte(w))
	default:
		return fmt.Errorf("invalid JSON value %q (%T) to unmarshal into %q", t, t, "Fruit")
	}
}

type Long int64

// LongPtr returns a pointer to a Long
func (v Long) Ptr() *Long {
	return &v
}

// ToWire translates Long into a Thrift-level intermediate
// representation. This intermediate representation may be serialized
// into bytes using a ThriftRW protocol implementation.
func (v Long) ToWire() (wire.Value, error) {
	x := (int64)(v)
	return wire.NewValueI64(x), error(nil)
}

// String returns a readable string representation of Long.
func (v Long) String() string {
	x := (int64)(v)
	return fmt.Sprint(x)
}

// FromWire deserializes Long from its Thrift-level
// representation. The Thrift-level representation may be obtained
// from a ThriftRW protocol implementation.
func (v *Long) FromWire(w wire.Value) error {
	x, err := w.GetI64(), error(nil)
	*v = (Long)(x)
	return err
}

// Equals returns true if this Long is equal to the provided
// Long.
func (lhs Long) Equals(rhs Long) bool {
	return ((int64)(lhs) == (int64)(rhs))
}

type OptionalParamsStruct struct {
	UserID *string `json:"userID,omitempty"`
}

// ToWire translates a OptionalParamsStruct struct into a Thrift-level intermediate
// representation. This intermediate representation may be serialized
// into bytes using a ThriftRW protocol implementation.
//
// An error is returned if the struct or any of its fields failed to
// validate.
//
//   x, err := v.ToWire()
//   if err != nil {
//     return err
//   }
//
//   if err := binaryProtocol.Encode(x, writer); err != nil {
//     return err
//   }
func (v *OptionalParamsStruct) ToWire() (wire.Value, error) {
	var (
		fields [1]wire.Field
		i      int = 0
		w      wire.Value
		err    error
	)

	if v.UserID != nil {
		w, err = wire.NewValueString(*(v.UserID)), error(nil)
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 1, Value: w}
		i++
	}

	return wire.NewValueStruct(wire.Struct{Fields: fields[:i]}), nil
}

// FromWire deserializes a OptionalParamsStruct struct from its Thrift-level
// representation. The Thrift-level representation may be obtained
// from a ThriftRW protocol implementation.
//
// An error is returned if we were unable to build a OptionalParamsStruct struct
// from the provided intermediate representation.
//
//   x, err := binaryProtocol.Decode(reader, wire.TStruct)
//   if err != nil {
//     return nil, err
//   }
//
//   var v OptionalParamsStruct
//   if err := v.FromWire(x); err != nil {
//     return nil, err
//   }
//   return &v, nil
func (v *OptionalParamsStruct) FromWire(w wire.Value) error {
	var err error

	for _, field := range w.GetStruct().Fields {
		switch field.ID {
		case 1:
			if field.Value.Type() == wire.TBinary {
				var x string
				x, err = field.Value.GetString(), error(nil)
				v.UserID = &x
				if err != nil {
					return err
				}

			}
		}
	}

	return nil
}

// String returns a readable string representation of a OptionalParamsStruct
// struct.
func (v *OptionalParamsStruct) String() string {
	if v == nil {
		return "<nil>"
	}

	var fields [1]string
	i := 0
	if v.UserID != nil {
		fields[i] = fmt.Sprintf("UserID: %v", *(v.UserID))
		i++
	}

	return fmt.Sprintf("OptionalParamsStruct{%v}", strings.Join(fields[:i], ", "))
}

func _String_EqualsPtr(lhs, rhs *string) bool {
	if lhs != nil && rhs != nil {

		x := *lhs
		y := *rhs
		return (x == y)
	}
	return lhs == nil && rhs == nil
}

// Equals returns true if all the fields of this OptionalParamsStruct match the
// provided OptionalParamsStruct.
//
// This function performs a deep comparison.
func (v *OptionalParamsStruct) Equals(rhs *OptionalParamsStruct) bool {
	if v == nil {
		return rhs == nil
	} else if rhs == nil {
		return false
	}
	if !_String_EqualsPtr(v.UserID, rhs.UserID) {
		return false
	}

	return true
}

// MarshalLogObject implements zapcore.ObjectMarshaler, enabling
// fast logging of OptionalParamsStruct.
func (v *OptionalParamsStruct) MarshalLogObject(enc zapcore.ObjectEncoder) (err error) {
	if v == nil {
		return nil
	}
	if v.UserID != nil {
		enc.AddString("userID", *v.UserID)
	}
	return err
}

// GetUserID returns the value of UserID if it is set or its
// zero value if it is unset.
func (v *OptionalParamsStruct) GetUserID() (o string) {
	if v != nil && v.UserID != nil {
		return *v.UserID
	}

	return
}

// IsSetUserID returns true if UserID is not nil.
func (v *OptionalParamsStruct) IsSetUserID() bool {
	return v != nil && v.UserID != nil
}

type ParamsStruct struct {
	UserUUID string `json:"userUUID,required"`
}

// ToWire translates a ParamsStruct struct into a Thrift-level intermediate
// representation. This intermediate representation may be serialized
// into bytes using a ThriftRW protocol implementation.
//
// An error is returned if the struct or any of its fields failed to
// validate.
//
//   x, err := v.ToWire()
//   if err != nil {
//     return err
//   }
//
//   if err := binaryProtocol.Encode(x, writer); err != nil {
//     return err
//   }
func (v *ParamsStruct) ToWire() (wire.Value, error) {
	var (
		fields [1]wire.Field
		i      int = 0
		w      wire.Value
		err    error
	)

	w, err = wire.NewValueString(v.UserUUID), error(nil)
	if err != nil {
		return w, err
	}
	fields[i] = wire.Field{ID: 1, Value: w}
	i++

	return wire.NewValueStruct(wire.Struct{Fields: fields[:i]}), nil
}

// FromWire deserializes a ParamsStruct struct from its Thrift-level
// representation. The Thrift-level representation may be obtained
// from a ThriftRW protocol implementation.
//
// An error is returned if we were unable to build a ParamsStruct struct
// from the provided intermediate representation.
//
//   x, err := binaryProtocol.Decode(reader, wire.TStruct)
//   if err != nil {
//     return nil, err
//   }
//
//   var v ParamsStruct
//   if err := v.FromWire(x); err != nil {
//     return nil, err
//   }
//   return &v, nil
func (v *ParamsStruct) FromWire(w wire.Value) error {
	var err error

	userUUIDIsSet := false

	for _, field := range w.GetStruct().Fields {
		switch field.ID {
		case 1:
			if field.Value.Type() == wire.TBinary {
				v.UserUUID, err = field.Value.GetString(), error(nil)
				if err != nil {
					return err
				}
				userUUIDIsSet = true
			}
		}
	}

	if !userUUIDIsSet {
		return errors.New("field UserUUID of ParamsStruct is required")
	}

	return nil
}

// String returns a readable string representation of a ParamsStruct
// struct.
func (v *ParamsStruct) String() string {
	if v == nil {
		return "<nil>"
	}

	var fields [1]string
	i := 0
	fields[i] = fmt.Sprintf("UserUUID: %v", v.UserUUID)
	i++

	return fmt.Sprintf("ParamsStruct{%v}", strings.Join(fields[:i], ", "))
}

// Equals returns true if all the fields of this ParamsStruct match the
// provided ParamsStruct.
//
// This function performs a deep comparison.
func (v *ParamsStruct) Equals(rhs *ParamsStruct) bool {
	if v == nil {
		return rhs == nil
	} else if rhs == nil {
		return false
	}
	if !(v.UserUUID == rhs.UserUUID) {
		return false
	}

	return true
}

// MarshalLogObject implements zapcore.ObjectMarshaler, enabling
// fast logging of ParamsStruct.
func (v *ParamsStruct) MarshalLogObject(enc zapcore.ObjectEncoder) (err error) {
	if v == nil {
		return nil
	}
	enc.AddString("userUUID", v.UserUUID)
	return err
}

// GetUserUUID returns the value of UserUUID if it is set or its
// zero value if it is unset.
func (v *ParamsStruct) GetUserUUID() (o string) {
	if v != nil {
		o = v.UserUUID
	}
	return
}

type QueryParamsOptsStruct struct {
	Name      string  `json:"name,required"`
	UserUUID  *string `json:"userUUID,omitempty"`
	AuthUUID  *string `json:"authUUID,omitempty"`
	AuthUUID2 *string `json:"authUUID2,omitempty"`
}

// ToWire translates a QueryParamsOptsStruct struct into a Thrift-level intermediate
// representation. This intermediate representation may be serialized
// into bytes using a ThriftRW protocol implementation.
//
// An error is returned if the struct or any of its fields failed to
// validate.
//
//   x, err := v.ToWire()
//   if err != nil {
//     return err
//   }
//
//   if err := binaryProtocol.Encode(x, writer); err != nil {
//     return err
//   }
func (v *QueryParamsOptsStruct) ToWire() (wire.Value, error) {
	var (
		fields [4]wire.Field
		i      int = 0
		w      wire.Value
		err    error
	)

	w, err = wire.NewValueString(v.Name), error(nil)
	if err != nil {
		return w, err
	}
	fields[i] = wire.Field{ID: 1, Value: w}
	i++
	if v.UserUUID != nil {
		w, err = wire.NewValueString(*(v.UserUUID)), error(nil)
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 2, Value: w}
		i++
	}
	if v.AuthUUID != nil {
		w, err = wire.NewValueString(*(v.AuthUUID)), error(nil)
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 3, Value: w}
		i++
	}
	if v.AuthUUID2 != nil {
		w, err = wire.NewValueString(*(v.AuthUUID2)), error(nil)
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 4, Value: w}
		i++
	}

	return wire.NewValueStruct(wire.Struct{Fields: fields[:i]}), nil
}

// FromWire deserializes a QueryParamsOptsStruct struct from its Thrift-level
// representation. The Thrift-level representation may be obtained
// from a ThriftRW protocol implementation.
//
// An error is returned if we were unable to build a QueryParamsOptsStruct struct
// from the provided intermediate representation.
//
//   x, err := binaryProtocol.Decode(reader, wire.TStruct)
//   if err != nil {
//     return nil, err
//   }
//
//   var v QueryParamsOptsStruct
//   if err := v.FromWire(x); err != nil {
//     return nil, err
//   }
//   return &v, nil
func (v *QueryParamsOptsStruct) FromWire(w wire.Value) error {
	var err error

	nameIsSet := false

	for _, field := range w.GetStruct().Fields {
		switch field.ID {
		case 1:
			if field.Value.Type() == wire.TBinary {
				v.Name, err = field.Value.GetString(), error(nil)
				if err != nil {
					return err
				}
				nameIsSet = true
			}
		case 2:
			if field.Value.Type() == wire.TBinary {
				var x string
				x, err = field.Value.GetString(), error(nil)
				v.UserUUID = &x
				if err != nil {
					return err
				}

			}
		case 3:
			if field.Value.Type() == wire.TBinary {
				var x string
				x, err = field.Value.GetString(), error(nil)
				v.AuthUUID = &x
				if err != nil {
					return err
				}

			}
		case 4:
			if field.Value.Type() == wire.TBinary {
				var x string
				x, err = field.Value.GetString(), error(nil)
				v.AuthUUID2 = &x
				if err != nil {
					return err
				}

			}
		}
	}

	if !nameIsSet {
		return errors.New("field Name of QueryParamsOptsStruct is required")
	}

	return nil
}

// String returns a readable string representation of a QueryParamsOptsStruct
// struct.
func (v *QueryParamsOptsStruct) String() string {
	if v == nil {
		return "<nil>"
	}

	var fields [4]string
	i := 0
	fields[i] = fmt.Sprintf("Name: %v", v.Name)
	i++
	if v.UserUUID != nil {
		fields[i] = fmt.Sprintf("UserUUID: %v", *(v.UserUUID))
		i++
	}
	if v.AuthUUID != nil {
		fields[i] = fmt.Sprintf("AuthUUID: %v", *(v.AuthUUID))
		i++
	}
	if v.AuthUUID2 != nil {
		fields[i] = fmt.Sprintf("AuthUUID2: %v", *(v.AuthUUID2))
		i++
	}

	return fmt.Sprintf("QueryParamsOptsStruct{%v}", strings.Join(fields[:i], ", "))
}

// Equals returns true if all the fields of this QueryParamsOptsStruct match the
// provided QueryParamsOptsStruct.
//
// This function performs a deep comparison.
func (v *QueryParamsOptsStruct) Equals(rhs *QueryParamsOptsStruct) bool {
	if v == nil {
		return rhs == nil
	} else if rhs == nil {
		return false
	}
	if !(v.Name == rhs.Name) {
		return false
	}
	if !_String_EqualsPtr(v.UserUUID, rhs.UserUUID) {
		return false
	}
	if !_String_EqualsPtr(v.AuthUUID, rhs.AuthUUID) {
		return false
	}
	if !_String_EqualsPtr(v.AuthUUID2, rhs.AuthUUID2) {
		return false
	}

	return true
}

// MarshalLogObject implements zapcore.ObjectMarshaler, enabling
// fast logging of QueryParamsOptsStruct.
func (v *QueryParamsOptsStruct) MarshalLogObject(enc zapcore.ObjectEncoder) (err error) {
	if v == nil {
		return nil
	}
	enc.AddString("name", v.Name)
	if v.UserUUID != nil {
		enc.AddString("userUUID", *v.UserUUID)
	}
	if v.AuthUUID != nil {
		enc.AddString("authUUID", *v.AuthUUID)
	}
	if v.AuthUUID2 != nil {
		enc.AddString("authUUID2", *v.AuthUUID2)
	}
	return err
}

// GetName returns the value of Name if it is set or its
// zero value if it is unset.
func (v *QueryParamsOptsStruct) GetName() (o string) {
	if v != nil {
		o = v.Name
	}
	return
}

// GetUserUUID returns the value of UserUUID if it is set or its
// zero value if it is unset.
func (v *QueryParamsOptsStruct) GetUserUUID() (o string) {
	if v != nil && v.UserUUID != nil {
		return *v.UserUUID
	}

	return
}

// IsSetUserUUID returns true if UserUUID is not nil.
func (v *QueryParamsOptsStruct) IsSetUserUUID() bool {
	return v != nil && v.UserUUID != nil
}

// GetAuthUUID returns the value of AuthUUID if it is set or its
// zero value if it is unset.
func (v *QueryParamsOptsStruct) GetAuthUUID() (o string) {
	if v != nil && v.AuthUUID != nil {
		return *v.AuthUUID
	}

	return
}

// IsSetAuthUUID returns true if AuthUUID is not nil.
func (v *QueryParamsOptsStruct) IsSetAuthUUID() bool {
	return v != nil && v.AuthUUID != nil
}

// GetAuthUUID2 returns the value of AuthUUID2 if it is set or its
// zero value if it is unset.
func (v *QueryParamsOptsStruct) GetAuthUUID2() (o string) {
	if v != nil && v.AuthUUID2 != nil {
		return *v.AuthUUID2
	}

	return
}

// IsSetAuthUUID2 returns true if AuthUUID2 is not nil.
func (v *QueryParamsOptsStruct) IsSetAuthUUID2() bool {
	return v != nil && v.AuthUUID2 != nil
}

type QueryParamsStruct struct {
	Name      string   `json:"name,required"`
	UserUUID  *string  `json:"userUUID,omitempty"`
	AuthUUID  *string  `json:"authUUID,omitempty"`
	AuthUUID2 *string  `json:"authUUID2,omitempty"`
	Foo       []string `json:"foo,required"`
}

// ToWire translates a QueryParamsStruct struct into a Thrift-level intermediate
// representation. This intermediate representation may be serialized
// into bytes using a ThriftRW protocol implementation.
//
// An error is returned if the struct or any of its fields failed to
// validate.
//
//   x, err := v.ToWire()
//   if err != nil {
//     return err
//   }
//
//   if err := binaryProtocol.Encode(x, writer); err != nil {
//     return err
//   }
func (v *QueryParamsStruct) ToWire() (wire.Value, error) {
	var (
		fields [5]wire.Field
		i      int = 0
		w      wire.Value
		err    error
	)

	w, err = wire.NewValueString(v.Name), error(nil)
	if err != nil {
		return w, err
	}
	fields[i] = wire.Field{ID: 1, Value: w}
	i++
	if v.UserUUID != nil {
		w, err = wire.NewValueString(*(v.UserUUID)), error(nil)
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 2, Value: w}
		i++
	}
	if v.AuthUUID != nil {
		w, err = wire.NewValueString(*(v.AuthUUID)), error(nil)
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 3, Value: w}
		i++
	}
	if v.AuthUUID2 != nil {
		w, err = wire.NewValueString(*(v.AuthUUID2)), error(nil)
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 4, Value: w}
		i++
	}

	w, err = wire.NewValueList(_List_String_ValueList(v.Foo)), error(nil)
	if err != nil {
		return w, err
	}
	fields[i] = wire.Field{ID: 5, Value: w}
	i++

	return wire.NewValueStruct(wire.Struct{Fields: fields[:i]}), nil
}

// FromWire deserializes a QueryParamsStruct struct from its Thrift-level
// representation. The Thrift-level representation may be obtained
// from a ThriftRW protocol implementation.
//
// An error is returned if we were unable to build a QueryParamsStruct struct
// from the provided intermediate representation.
//
//   x, err := binaryProtocol.Decode(reader, wire.TStruct)
//   if err != nil {
//     return nil, err
//   }
//
//   var v QueryParamsStruct
//   if err := v.FromWire(x); err != nil {
//     return nil, err
//   }
//   return &v, nil
func (v *QueryParamsStruct) FromWire(w wire.Value) error {
	var err error

	nameIsSet := false

	fooIsSet := false

	for _, field := range w.GetStruct().Fields {
		switch field.ID {
		case 1:
			if field.Value.Type() == wire.TBinary {
				v.Name, err = field.Value.GetString(), error(nil)
				if err != nil {
					return err
				}
				nameIsSet = true
			}
		case 2:
			if field.Value.Type() == wire.TBinary {
				var x string
				x, err = field.Value.GetString(), error(nil)
				v.UserUUID = &x
				if err != nil {
					return err
				}

			}
		case 3:
			if field.Value.Type() == wire.TBinary {
				var x string
				x, err = field.Value.GetString(), error(nil)
				v.AuthUUID = &x
				if err != nil {
					return err
				}

			}
		case 4:
			if field.Value.Type() == wire.TBinary {
				var x string
				x, err = field.Value.GetString(), error(nil)
				v.AuthUUID2 = &x
				if err != nil {
					return err
				}

			}
		case 5:
			if field.Value.Type() == wire.TList {
				v.Foo, err = _List_String_Read(field.Value.GetList())
				if err != nil {
					return err
				}
				fooIsSet = true
			}
		}
	}

	if !nameIsSet {
		return errors.New("field Name of QueryParamsStruct is required")
	}

	if !fooIsSet {
		return errors.New("field Foo of QueryParamsStruct is required")
	}

	return nil
}

// String returns a readable string representation of a QueryParamsStruct
// struct.
func (v *QueryParamsStruct) String() string {
	if v == nil {
		return "<nil>"
	}

	var fields [5]string
	i := 0
	fields[i] = fmt.Sprintf("Name: %v", v.Name)
	i++
	if v.UserUUID != nil {
		fields[i] = fmt.Sprintf("UserUUID: %v", *(v.UserUUID))
		i++
	}
	if v.AuthUUID != nil {
		fields[i] = fmt.Sprintf("AuthUUID: %v", *(v.AuthUUID))
		i++
	}
	if v.AuthUUID2 != nil {
		fields[i] = fmt.Sprintf("AuthUUID2: %v", *(v.AuthUUID2))
		i++
	}
	fields[i] = fmt.Sprintf("Foo: %v", v.Foo)
	i++

	return fmt.Sprintf("QueryParamsStruct{%v}", strings.Join(fields[:i], ", "))
}

// Equals returns true if all the fields of this QueryParamsStruct match the
// provided QueryParamsStruct.
//
// This function performs a deep comparison.
func (v *QueryParamsStruct) Equals(rhs *QueryParamsStruct) bool {
	if v == nil {
		return rhs == nil
	} else if rhs == nil {
		return false
	}
	if !(v.Name == rhs.Name) {
		return false
	}
	if !_String_EqualsPtr(v.UserUUID, rhs.UserUUID) {
		return false
	}
	if !_String_EqualsPtr(v.AuthUUID, rhs.AuthUUID) {
		return false
	}
	if !_String_EqualsPtr(v.AuthUUID2, rhs.AuthUUID2) {
		return false
	}
	if !_List_String_Equals(v.Foo, rhs.Foo) {
		return false
	}

	return true
}

// MarshalLogObject implements zapcore.ObjectMarshaler, enabling
// fast logging of QueryParamsStruct.
func (v *QueryParamsStruct) MarshalLogObject(enc zapcore.ObjectEncoder) (err error) {
	if v == nil {
		return nil
	}
	enc.AddString("name", v.Name)
	if v.UserUUID != nil {
		enc.AddString("userUUID", *v.UserUUID)
	}
	if v.AuthUUID != nil {
		enc.AddString("authUUID", *v.AuthUUID)
	}
	if v.AuthUUID2 != nil {
		enc.AddString("authUUID2", *v.AuthUUID2)
	}
	err = multierr.Append(err, enc.AddArray("foo", (_List_String_Zapper)(v.Foo)))
	return err
}

// GetName returns the value of Name if it is set or its
// zero value if it is unset.
func (v *QueryParamsStruct) GetName() (o string) {
	if v != nil {
		o = v.Name
	}
	return
}

// GetUserUUID returns the value of UserUUID if it is set or its
// zero value if it is unset.
func (v *QueryParamsStruct) GetUserUUID() (o string) {
	if v != nil && v.UserUUID != nil {
		return *v.UserUUID
	}

	return
}

// IsSetUserUUID returns true if UserUUID is not nil.
func (v *QueryParamsStruct) IsSetUserUUID() bool {
	return v != nil && v.UserUUID != nil
}

// GetAuthUUID returns the value of AuthUUID if it is set or its
// zero value if it is unset.
func (v *QueryParamsStruct) GetAuthUUID() (o string) {
	if v != nil && v.AuthUUID != nil {
		return *v.AuthUUID
	}

	return
}

// IsSetAuthUUID returns true if AuthUUID is not nil.
func (v *QueryParamsStruct) IsSetAuthUUID() bool {
	return v != nil && v.AuthUUID != nil
}

// GetAuthUUID2 returns the value of AuthUUID2 if it is set or its
// zero value if it is unset.
func (v *QueryParamsStruct) GetAuthUUID2() (o string) {
	if v != nil && v.AuthUUID2 != nil {
		return *v.AuthUUID2
	}

	return
}

// IsSetAuthUUID2 returns true if AuthUUID2 is not nil.
func (v *QueryParamsStruct) IsSetAuthUUID2() bool {
	return v != nil && v.AuthUUID2 != nil
}

// GetFoo returns the value of Foo if it is set or its
// zero value if it is unset.
func (v *QueryParamsStruct) GetFoo() (o []string) {
	if v != nil {
		o = v.Foo
	}
	return
}

// IsSetFoo returns true if Foo is not nil.
func (v *QueryParamsStruct) IsSetFoo() bool {
	return v != nil && v.Foo != nil
}

type RequestWithDuplicateType struct {
	Request1 *BarRequest `json:"request1,omitempty"`
	Request2 *BarRequest `json:"request2,omitempty"`
}

// ToWire translates a RequestWithDuplicateType struct into a Thrift-level intermediate
// representation. This intermediate representation may be serialized
// into bytes using a ThriftRW protocol implementation.
//
// An error is returned if the struct or any of its fields failed to
// validate.
//
//   x, err := v.ToWire()
//   if err != nil {
//     return err
//   }
//
//   if err := binaryProtocol.Encode(x, writer); err != nil {
//     return err
//   }
func (v *RequestWithDuplicateType) ToWire() (wire.Value, error) {
	var (
		fields [2]wire.Field
		i      int = 0
		w      wire.Value
		err    error
	)

	if v.Request1 != nil {
		w, err = v.Request1.ToWire()
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 1, Value: w}
		i++
	}
	if v.Request2 != nil {
		w, err = v.Request2.ToWire()
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 2, Value: w}
		i++
	}

	return wire.NewValueStruct(wire.Struct{Fields: fields[:i]}), nil
}

func _BarRequest_Read(w wire.Value) (*BarRequest, error) {
	var v BarRequest
	err := v.FromWire(w)
	return &v, err
}

// FromWire deserializes a RequestWithDuplicateType struct from its Thrift-level
// representation. The Thrift-level representation may be obtained
// from a ThriftRW protocol implementation.
//
// An error is returned if we were unable to build a RequestWithDuplicateType struct
// from the provided intermediate representation.
//
//   x, err := binaryProtocol.Decode(reader, wire.TStruct)
//   if err != nil {
//     return nil, err
//   }
//
//   var v RequestWithDuplicateType
//   if err := v.FromWire(x); err != nil {
//     return nil, err
//   }
//   return &v, nil
func (v *RequestWithDuplicateType) FromWire(w wire.Value) error {
	var err error

	for _, field := range w.GetStruct().Fields {
		switch field.ID {
		case 1:
			if field.Value.Type() == wire.TStruct {
				v.Request1, err = _BarRequest_Read(field.Value)
				if err != nil {
					return err
				}

			}
		case 2:
			if field.Value.Type() == wire.TStruct {
				v.Request2, err = _BarRequest_Read(field.Value)
				if err != nil {
					return err
				}

			}
		}
	}

	return nil
}

// String returns a readable string representation of a RequestWithDuplicateType
// struct.
func (v *RequestWithDuplicateType) String() string {
	if v == nil {
		return "<nil>"
	}

	var fields [2]string
	i := 0
	if v.Request1 != nil {
		fields[i] = fmt.Sprintf("Request1: %v", v.Request1)
		i++
	}
	if v.Request2 != nil {
		fields[i] = fmt.Sprintf("Request2: %v", v.Request2)
		i++
	}

	return fmt.Sprintf("RequestWithDuplicateType{%v}", strings.Join(fields[:i], ", "))
}

// Equals returns true if all the fields of this RequestWithDuplicateType match the
// provided RequestWithDuplicateType.
//
// This function performs a deep comparison.
func (v *RequestWithDuplicateType) Equals(rhs *RequestWithDuplicateType) bool {
	if v == nil {
		return rhs == nil
	} else if rhs == nil {
		return false
	}
	if !((v.Request1 == nil && rhs.Request1 == nil) || (v.Request1 != nil && rhs.Request1 != nil && v.Request1.Equals(rhs.Request1))) {
		return false
	}
	if !((v.Request2 == nil && rhs.Request2 == nil) || (v.Request2 != nil && rhs.Request2 != nil && v.Request2.Equals(rhs.Request2))) {
		return false
	}

	return true
}

// MarshalLogObject implements zapcore.ObjectMarshaler, enabling
// fast logging of RequestWithDuplicateType.
func (v *RequestWithDuplicateType) MarshalLogObject(enc zapcore.ObjectEncoder) (err error) {
	if v == nil {
		return nil
	}
	if v.Request1 != nil {
		err = multierr.Append(err, enc.AddObject("request1", v.Request1))
	}
	if v.Request2 != nil {
		err = multierr.Append(err, enc.AddObject("request2", v.Request2))
	}
	return err
}

// GetRequest1 returns the value of Request1 if it is set or its
// zero value if it is unset.
func (v *RequestWithDuplicateType) GetRequest1() (o *BarRequest) {
	if v != nil && v.Request1 != nil {
		return v.Request1
	}

	return
}

// IsSetRequest1 returns true if Request1 is not nil.
func (v *RequestWithDuplicateType) IsSetRequest1() bool {
	return v != nil && v.Request1 != nil
}

// GetRequest2 returns the value of Request2 if it is set or its
// zero value if it is unset.
func (v *RequestWithDuplicateType) GetRequest2() (o *BarRequest) {
	if v != nil && v.Request2 != nil {
		return v.Request2
	}

	return
}

// IsSetRequest2 returns true if Request2 is not nil.
func (v *RequestWithDuplicateType) IsSetRequest2() bool {
	return v != nil && v.Request2 != nil
}

type StringList []string

// ToWire translates StringList into a Thrift-level intermediate
// representation. This intermediate representation may be serialized
// into bytes using a ThriftRW protocol implementation.
func (v StringList) ToWire() (wire.Value, error) {
	x := ([]string)(v)
	return wire.NewValueList(_List_String_ValueList(x)), error(nil)
}

// String returns a readable string representation of StringList.
func (v StringList) String() string {
	x := ([]string)(v)
	return fmt.Sprint(x)
}

// FromWire deserializes StringList from its Thrift-level
// representation. The Thrift-level representation may be obtained
// from a ThriftRW protocol implementation.
func (v *StringList) FromWire(w wire.Value) error {
	x, err := _List_String_Read(w.GetList())
	*v = (StringList)(x)
	return err
}

// Equals returns true if this StringList is equal to the provided
// StringList.
func (lhs StringList) Equals(rhs StringList) bool {
	return _List_String_Equals(([]string)(lhs), ([]string)(rhs))
}

func (v StringList) MarshalLogArray(enc zapcore.ArrayEncoder) error {
	return ((_List_String_Zapper)(([]string)(v))).MarshalLogArray(enc)
}

type Timestamp int64

// TimestampPtr returns a pointer to a Timestamp
func (v Timestamp) Ptr() *Timestamp {
	return &v
}

// ToWire translates Timestamp into a Thrift-level intermediate
// representation. This intermediate representation may be serialized
// into bytes using a ThriftRW protocol implementation.
func (v Timestamp) ToWire() (wire.Value, error) {
	x := (int64)(v)
	return wire.NewValueI64(x), error(nil)
}

// String returns a readable string representation of Timestamp.
func (v Timestamp) String() string {
	x := (int64)(v)
	return fmt.Sprint(x)
}

// FromWire deserializes Timestamp from its Thrift-level
// representation. The Thrift-level representation may be obtained
// from a ThriftRW protocol implementation.
func (v *Timestamp) FromWire(w wire.Value) error {
	x, err := w.GetI64(), error(nil)
	*v = (Timestamp)(x)
	return err
}

// Equals returns true if this Timestamp is equal to the provided
// Timestamp.
func (lhs Timestamp) Equals(rhs Timestamp) bool {
	return ((int64)(lhs) == (int64)(rhs))
}

type UUID string

// UUIDPtr returns a pointer to a UUID
func (v UUID) Ptr() *UUID {
	return &v
}

// ToWire translates UUID into a Thrift-level intermediate
// representation. This intermediate representation may be serialized
// into bytes using a ThriftRW protocol implementation.
func (v UUID) ToWire() (wire.Value, error) {
	x := (string)(v)
	return wire.NewValueString(x), error(nil)
}

// String returns a readable string representation of UUID.
func (v UUID) String() string {
	x := (string)(v)
	return fmt.Sprint(x)
}

// FromWire deserializes UUID from its Thrift-level
// representation. The Thrift-level representation may be obtained
// from a ThriftRW protocol implementation.
func (v *UUID) FromWire(w wire.Value) error {
	x, err := w.GetString(), error(nil)
	*v = (UUID)(x)
	return err
}

// Equals returns true if this UUID is equal to the provided
// UUID.
func (lhs UUID) Equals(rhs UUID) bool {
	return ((string)(lhs) == (string)(rhs))
}

type _List_UUID_ValueList []UUID

func (v _List_UUID_ValueList) ForEach(f func(wire.Value) error) error {
	for _, x := range v {
		w, err := x.ToWire()
		if err != nil {
			return err
		}
		err = f(w)
		if err != nil {
			return err
		}
	}
	return nil
}

func (v _List_UUID_ValueList) Size() int {
	return len(v)
}

func (_List_UUID_ValueList) ValueType() wire.Type {
	return wire.TBinary
}

func (_List_UUID_ValueList) Close() {}

func _List_UUID_Read(l wire.ValueList) ([]UUID, error) {
	if l.ValueType() != wire.TBinary {
		return nil, nil
	}

	o := make([]UUID, 0, l.Size())
	err := l.ForEach(func(x wire.Value) error {
		i, err := _UUID_Read(x)
		if err != nil {
			return err
		}
		o = append(o, i)
		return nil
	})
	l.Close()
	return o, err
}

func _List_UUID_Equals(lhs, rhs []UUID) bool {
	if len(lhs) != len(rhs) {
		return false
	}

	for i, lv := range lhs {
		rv := rhs[i]
		if !(lv == rv) {
			return false
		}
	}

	return true
}

type _List_UUID_Zapper []UUID

// MarshalLogArray implements zapcore.ArrayMarshaler, enabling
// fast logging of _List_UUID_Zapper.
func (l _List_UUID_Zapper) MarshalLogArray(enc zapcore.ArrayEncoder) (err error) {
	for _, v := range l {
		enc.AppendString((string)(v))
	}
	return err
}

type UUIDList []UUID

// ToWire translates UUIDList into a Thrift-level intermediate
// representation. This intermediate representation may be serialized
// into bytes using a ThriftRW protocol implementation.
func (v UUIDList) ToWire() (wire.Value, error) {
	x := ([]UUID)(v)
	return wire.NewValueList(_List_UUID_ValueList(x)), error(nil)
}

// String returns a readable string representation of UUIDList.
func (v UUIDList) String() string {
	x := ([]UUID)(v)
	return fmt.Sprint(x)
}

// FromWire deserializes UUIDList from its Thrift-level
// representation. The Thrift-level representation may be obtained
// from a ThriftRW protocol implementation.
func (v *UUIDList) FromWire(w wire.Value) error {
	x, err := _List_UUID_Read(w.GetList())
	*v = (UUIDList)(x)
	return err
}

// Equals returns true if this UUIDList is equal to the provided
// UUIDList.
func (lhs UUIDList) Equals(rhs UUIDList) bool {
	return _List_UUID_Equals(([]UUID)(lhs), ([]UUID)(rhs))
}

func (v UUIDList) MarshalLogArray(enc zapcore.ArrayEncoder) error {
	return ((_List_UUID_Zapper)(([]UUID)(v))).MarshalLogArray(enc)
}

// Bar_ArgNotStruct_Args represents the arguments for the Bar.argNotStruct function.
//
// The arguments for argNotStruct are sent and received over the wire as this struct.
type Bar_ArgNotStruct_Args struct {
	Request string `json:"request,required"`
}

// ToWire translates a Bar_ArgNotStruct_Args struct into a Thrift-level intermediate
// representation. This intermediate representation may be serialized
// into bytes using a ThriftRW protocol implementation.
//
// An error is returned if the struct or any of its fields failed to
// validate.
//
//   x, err := v.ToWire()
//   if err != nil {
//     return err
//   }
//
//   if err := binaryProtocol.Encode(x, writer); err != nil {
//     return err
//   }
func (v *Bar_ArgNotStruct_Args) ToWire() (wire.Value, error) {
	var (
		fields [1]wire.Field
		i      int = 0
		w      wire.Value
		err    error
	)

	w, err = wire.NewValueString(v.Request), error(nil)
	if err != nil {
		return w, err
	}
	fields[i] = wire.Field{ID: 1, Value: w}
	i++

	return wire.NewValueStruct(wire.Struct{Fields: fields[:i]}), nil
}

// FromWire deserializes a Bar_ArgNotStruct_Args struct from its Thrift-level
// representation. The Thrift-level representation may be obtained
// from a ThriftRW protocol implementation.
//
// An error is returned if we were unable to build a Bar_ArgNotStruct_Args struct
// from the provided intermediate representation.
//
//   x, err := binaryProtocol.Decode(reader, wire.TStruct)
//   if err != nil {
//     return nil, err
//   }
//
//   var v Bar_ArgNotStruct_Args
//   if err := v.FromWire(x); err != nil {
//     return nil, err
//   }
//   return &v, nil
func (v *Bar_ArgNotStruct_Args) FromWire(w wire.Value) error {
	var err error

	requestIsSet := false

	for _, field := range w.GetStruct().Fields {
		switch field.ID {
		case 1:
			if field.Value.Type() == wire.TBinary {
				v.Request, err = field.Value.GetString(), error(nil)
				if err != nil {
					return err
				}
				requestIsSet = true
			}
		}
	}

	if !requestIsSet {
		return errors.New("field Request of Bar_ArgNotStruct_Args is required")
	}

	return nil
}

// String returns a readable string representation of a Bar_ArgNotStruct_Args
// struct.
func (v *Bar_ArgNotStruct_Args) String() string {
	if v == nil {
		return "<nil>"
	}

	var fields [1]string
	i := 0
	fields[i] = fmt.Sprintf("Request: %v", v.Request)
	i++

	return fmt.Sprintf("Bar_ArgNotStruct_Args{%v}", strings.Join(fields[:i], ", "))
}

// Equals returns true if all the fields of this Bar_ArgNotStruct_Args match the
// provided Bar_ArgNotStruct_Args.
//
// This function performs a deep comparison.
func (v *Bar_ArgNotStruct_Args) Equals(rhs *Bar_ArgNotStruct_Args) bool {
	if v == nil {
		return rhs == nil
	} else if rhs == nil {
		return false
	}
	if !(v.Request == rhs.Request) {
		return false
	}

	return true
}

// MarshalLogObject implements zapcore.ObjectMarshaler, enabling
// fast logging of Bar_ArgNotStruct_Args.
func (v *Bar_ArgNotStruct_Args) MarshalLogObject(enc zapcore.ObjectEncoder) (err error) {
	if v == nil {
		return nil
	}
	enc.AddString("request", v.Request)
	return err
}

// GetRequest returns the value of Request if it is set or its
// zero value if it is unset.
func (v *Bar_ArgNotStruct_Args) GetRequest() (o string) {
	if v != nil {
		o = v.Request
	}
	return
}

// MethodName returns the name of the Thrift function as specified in
// the IDL, for which this struct represent the arguments.
//
// This will always be "argNotStruct" for this struct.
func (v *Bar_ArgNotStruct_Args) MethodName() string {
	return "argNotStruct"
}

// EnvelopeType returns the kind of value inside this struct.
//
// This will always be Call for this struct.
func (v *Bar_ArgNotStruct_Args) EnvelopeType() wire.EnvelopeType {
	return wire.Call
}

// Bar_ArgNotStruct_Helper provides functions that aid in handling the
// parameters and return values of the Bar.argNotStruct
// function.
var Bar_ArgNotStruct_Helper = struct {
	// Args accepts the parameters of argNotStruct in-order and returns
	// the arguments struct for the function.
	Args func(
		request string,
	) *Bar_ArgNotStruct_Args

	// IsException returns true if the given error can be thrown
	// by argNotStruct.
	//
	// An error can be thrown by argNotStruct only if the
	// corresponding exception type was mentioned in the 'throws'
	// section for it in the Thrift file.
	IsException func(error) bool

	// WrapResponse returns the result struct for argNotStruct
	// given the error returned by it. The provided error may
	// be nil if argNotStruct did not fail.
	//
	// This allows mapping errors returned by argNotStruct into a
	// serializable result struct. WrapResponse returns a
	// non-nil error if the provided error cannot be thrown by
	// argNotStruct
	//
	//   err := argNotStruct(args)
	//   result, err := Bar_ArgNotStruct_Helper.WrapResponse(err)
	//   if err != nil {
	//     return fmt.Errorf("unexpected error from argNotStruct: %v", err)
	//   }
	//   serialize(result)
	WrapResponse func(error) (*Bar_ArgNotStruct_Result, error)

	// UnwrapResponse takes the result struct for argNotStruct
	// and returns the erorr returned by it (if any).
	//
	// The error is non-nil only if argNotStruct threw an
	// exception.
	//
	//   result := deserialize(bytes)
	//   err := Bar_ArgNotStruct_Helper.UnwrapResponse(result)
	UnwrapResponse func(*Bar_ArgNotStruct_Result) error
}{}

func init() {
	Bar_ArgNotStruct_Helper.Args = func(
		request string,
	) *Bar_ArgNotStruct_Args {
		return &Bar_ArgNotStruct_Args{
			Request: request,
		}
	}

	Bar_ArgNotStruct_Helper.IsException = func(err error) bool {
		switch err.(type) {
		case *BarException:
			return true
		default:
			return false
		}
	}

	Bar_ArgNotStruct_Helper.WrapResponse = func(err error) (*Bar_ArgNotStruct_Result, error) {
		if err == nil {
			return &Bar_ArgNotStruct_Result{}, nil
		}

		switch e := err.(type) {
		case *BarException:
			if e == nil {
				return nil, errors.New("WrapResponse received non-nil error type with nil value for Bar_ArgNotStruct_Result.BarException")
			}
			return &Bar_ArgNotStruct_Result{BarException: e}, nil
		}

		return nil, err
	}
	Bar_ArgNotStruct_Helper.UnwrapResponse = func(result *Bar_ArgNotStruct_Result) (err error) {
		if result.BarException != nil {
			err = result.BarException
			return
		}
		return
	}

}

// Bar_ArgNotStruct_Result represents the result of a Bar.argNotStruct function call.
//
// The result of a argNotStruct execution is sent and received over the wire as this struct.
type Bar_ArgNotStruct_Result struct {
	BarException *BarException `json:"barException,omitempty"`
}

// ToWire translates a Bar_ArgNotStruct_Result struct into a Thrift-level intermediate
// representation. This intermediate representation may be serialized
// into bytes using a ThriftRW protocol implementation.
//
// An error is returned if the struct or any of its fields failed to
// validate.
//
//   x, err := v.ToWire()
//   if err != nil {
//     return err
//   }
//
//   if err := binaryProtocol.Encode(x, writer); err != nil {
//     return err
//   }
func (v *Bar_ArgNotStruct_Result) ToWire() (wire.Value, error) {
	var (
		fields [1]wire.Field
		i      int = 0
		w      wire.Value
		err    error
	)

	if v.BarException != nil {
		w, err = v.BarException.ToWire()
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 1, Value: w}
		i++
	}

	if i > 1 {
		return wire.Value{}, fmt.Errorf("Bar_ArgNotStruct_Result should have at most one field: got %v fields", i)
	}

	return wire.NewValueStruct(wire.Struct{Fields: fields[:i]}), nil
}

func _BarException_Read(w wire.Value) (*BarException, error) {
	var v BarException
	err := v.FromWire(w)
	return &v, err
}

// FromWire deserializes a Bar_ArgNotStruct_Result struct from its Thrift-level
// representation. The Thrift-level representation may be obtained
// from a ThriftRW protocol implementation.
//
// An error is returned if we were unable to build a Bar_ArgNotStruct_Result struct
// from the provided intermediate representation.
//
//   x, err := binaryProtocol.Decode(reader, wire.TStruct)
//   if err != nil {
//     return nil, err
//   }
//
//   var v Bar_ArgNotStruct_Result
//   if err := v.FromWire(x); err != nil {
//     return nil, err
//   }
//   return &v, nil
func (v *Bar_ArgNotStruct_Result) FromWire(w wire.Value) error {
	var err error

	for _, field := range w.GetStruct().Fields {
		switch field.ID {
		case 1:
			if field.Value.Type() == wire.TStruct {
				v.BarException, err = _BarException_Read(field.Value)
				if err != nil {
					return err
				}

			}
		}
	}

	count := 0
	if v.BarException != nil {
		count++
	}
	if count > 1 {
		return fmt.Errorf("Bar_ArgNotStruct_Result should have at most one field: got %v fields", count)
	}

	return nil
}

// String returns a readable string representation of a Bar_ArgNotStruct_Result
// struct.
func (v *Bar_ArgNotStruct_Result) String() string {
	if v == nil {
		return "<nil>"
	}

	var fields [1]string
	i := 0
	if v.BarException != nil {
		fields[i] = fmt.Sprintf("BarException: %v", v.BarException)
		i++
	}

	return fmt.Sprintf("Bar_ArgNotStruct_Result{%v}", strings.Join(fields[:i], ", "))
}

// Equals returns true if all the fields of this Bar_ArgNotStruct_Result match the
// provided Bar_ArgNotStruct_Result.
//
// This function performs a deep comparison.
func (v *Bar_ArgNotStruct_Result) Equals(rhs *Bar_ArgNotStruct_Result) bool {
	if v == nil {
		return rhs == nil
	} else if rhs == nil {
		return false
	}
	if !((v.BarException == nil && rhs.BarException == nil) || (v.BarException != nil && rhs.BarException != nil && v.BarException.Equals(rhs.BarException))) {
		return false
	}

	return true
}

// MarshalLogObject implements zapcore.ObjectMarshaler, enabling
// fast logging of Bar_ArgNotStruct_Result.
func (v *Bar_ArgNotStruct_Result) MarshalLogObject(enc zapcore.ObjectEncoder) (err error) {
	if v == nil {
		return nil
	}
	if v.BarException != nil {
		err = multierr.Append(err, enc.AddObject("barException", v.BarException))
	}
	return err
}

// GetBarException returns the value of BarException if it is set or its
// zero value if it is unset.
func (v *Bar_ArgNotStruct_Result) GetBarException() (o *BarException) {
	if v != nil && v.BarException != nil {
		return v.BarException
	}

	return
}

// IsSetBarException returns true if BarException is not nil.
func (v *Bar_ArgNotStruct_Result) IsSetBarException() bool {
	return v != nil && v.BarException != nil
}

// MethodName returns the name of the Thrift function as specified in
// the IDL, for which this struct represent the result.
//
// This will always be "argNotStruct" for this struct.
func (v *Bar_ArgNotStruct_Result) MethodName() string {
	return "argNotStruct"
}

// EnvelopeType returns the kind of value inside this struct.
//
// This will always be Reply for this struct.
func (v *Bar_ArgNotStruct_Result) EnvelopeType() wire.EnvelopeType {
	return wire.Reply
}

// Bar_ArgWithHeaders_Args represents the arguments for the Bar.argWithHeaders function.
//
// The arguments for argWithHeaders are sent and received over the wire as this struct.
type Bar_ArgWithHeaders_Args struct {
	Name         string                `json:"-"`
	UserUUID     *string               `json:"-"`
	ParamsStruct *OptionalParamsStruct `json:"paramsStruct,omitempty"`
}

// ToWire translates a Bar_ArgWithHeaders_Args struct into a Thrift-level intermediate
// representation. This intermediate representation may be serialized
// into bytes using a ThriftRW protocol implementation.
//
// An error is returned if the struct or any of its fields failed to
// validate.
//
//   x, err := v.ToWire()
//   if err != nil {
//     return err
//   }
//
//   if err := binaryProtocol.Encode(x, writer); err != nil {
//     return err
//   }
func (v *Bar_ArgWithHeaders_Args) ToWire() (wire.Value, error) {
	var (
		fields [3]wire.Field
		i      int = 0
		w      wire.Value
		err    error
	)

	w, err = wire.NewValueString(v.Name), error(nil)
	if err != nil {
		return w, err
	}
	fields[i] = wire.Field{ID: 1, Value: w}
	i++
	if v.UserUUID != nil {
		w, err = wire.NewValueString(*(v.UserUUID)), error(nil)
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 2, Value: w}
		i++
	}
	if v.ParamsStruct != nil {
		w, err = v.ParamsStruct.ToWire()
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 3, Value: w}
		i++
	}

	return wire.NewValueStruct(wire.Struct{Fields: fields[:i]}), nil
}

func _OptionalParamsStruct_Read(w wire.Value) (*OptionalParamsStruct, error) {
	var v OptionalParamsStruct
	err := v.FromWire(w)
	return &v, err
}

// FromWire deserializes a Bar_ArgWithHeaders_Args struct from its Thrift-level
// representation. The Thrift-level representation may be obtained
// from a ThriftRW protocol implementation.
//
// An error is returned if we were unable to build a Bar_ArgWithHeaders_Args struct
// from the provided intermediate representation.
//
//   x, err := binaryProtocol.Decode(reader, wire.TStruct)
//   if err != nil {
//     return nil, err
//   }
//
//   var v Bar_ArgWithHeaders_Args
//   if err := v.FromWire(x); err != nil {
//     return nil, err
//   }
//   return &v, nil
func (v *Bar_ArgWithHeaders_Args) FromWire(w wire.Value) error {
	var err error

	nameIsSet := false

	for _, field := range w.GetStruct().Fields {
		switch field.ID {
		case 1:
			if field.Value.Type() == wire.TBinary {
				v.Name, err = field.Value.GetString(), error(nil)
				if err != nil {
					return err
				}
				nameIsSet = true
			}
		case 2:
			if field.Value.Type() == wire.TBinary {
				var x string
				x, err = field.Value.GetString(), error(nil)
				v.UserUUID = &x
				if err != nil {
					return err
				}

			}
		case 3:
			if field.Value.Type() == wire.TStruct {
				v.ParamsStruct, err = _OptionalParamsStruct_Read(field.Value)
				if err != nil {
					return err
				}

			}
		}
	}

	if !nameIsSet {
		return errors.New("field Name of Bar_ArgWithHeaders_Args is required")
	}

	return nil
}

// String returns a readable string representation of a Bar_ArgWithHeaders_Args
// struct.
func (v *Bar_ArgWithHeaders_Args) String() string {
	if v == nil {
		return "<nil>"
	}

	var fields [3]string
	i := 0
	fields[i] = fmt.Sprintf("Name: %v", v.Name)
	i++
	if v.UserUUID != nil {
		fields[i] = fmt.Sprintf("UserUUID: %v", *(v.UserUUID))
		i++
	}
	if v.ParamsStruct != nil {
		fields[i] = fmt.Sprintf("ParamsStruct: %v", v.ParamsStruct)
		i++
	}

	return fmt.Sprintf("Bar_ArgWithHeaders_Args{%v}", strings.Join(fields[:i], ", "))
}

// Equals returns true if all the fields of this Bar_ArgWithHeaders_Args match the
// provided Bar_ArgWithHeaders_Args.
//
// This function performs a deep comparison.
func (v *Bar_ArgWithHeaders_Args) Equals(rhs *Bar_ArgWithHeaders_Args) bool {
	if v == nil {
		return rhs == nil
	} else if rhs == nil {
		return false
	}
	if !(v.Name == rhs.Name) {
		return false
	}
	if !_String_EqualsPtr(v.UserUUID, rhs.UserUUID) {
		return false
	}
	if !((v.ParamsStruct == nil && rhs.ParamsStruct == nil) || (v.ParamsStruct != nil && rhs.ParamsStruct != nil && v.ParamsStruct.Equals(rhs.ParamsStruct))) {
		return false
	}

	return true
}

// MarshalLogObject implements zapcore.ObjectMarshaler, enabling
// fast logging of Bar_ArgWithHeaders_Args.
func (v *Bar_ArgWithHeaders_Args) MarshalLogObject(enc zapcore.ObjectEncoder) (err error) {
	if v == nil {
		return nil
	}
	enc.AddString("name", v.Name)
	if v.UserUUID != nil {
		enc.AddString("userUUID", *v.UserUUID)
	}
	if v.ParamsStruct != nil {
		err = multierr.Append(err, enc.AddObject("paramsStruct", v.ParamsStruct))
	}
	return err
}

// GetName returns the value of Name if it is set or its
// zero value if it is unset.
func (v *Bar_ArgWithHeaders_Args) GetName() (o string) {
	if v != nil {
		o = v.Name
	}
	return
}

// GetUserUUID returns the value of UserUUID if it is set or its
// zero value if it is unset.
func (v *Bar_ArgWithHeaders_Args) GetUserUUID() (o string) {
	if v != nil && v.UserUUID != nil {
		return *v.UserUUID
	}

	return
}

// IsSetUserUUID returns true if UserUUID is not nil.
func (v *Bar_ArgWithHeaders_Args) IsSetUserUUID() bool {
	return v != nil && v.UserUUID != nil
}

// GetParamsStruct returns the value of ParamsStruct if it is set or its
// zero value if it is unset.
func (v *Bar_ArgWithHeaders_Args) GetParamsStruct() (o *OptionalParamsStruct) {
	if v != nil && v.ParamsStruct != nil {
		return v.ParamsStruct
	}

	return
}

// IsSetParamsStruct returns true if ParamsStruct is not nil.
func (v *Bar_ArgWithHeaders_Args) IsSetParamsStruct() bool {
	return v != nil && v.ParamsStruct != nil
}

// MethodName returns the name of the Thrift function as specified in
// the IDL, for which this struct represent the arguments.
//
// This will always be "argWithHeaders" for this struct.
func (v *Bar_ArgWithHeaders_Args) MethodName() string {
	return "argWithHeaders"
}

// EnvelopeType returns the kind of value inside this struct.
//
// This will always be Call for this struct.
func (v *Bar_ArgWithHeaders_Args) EnvelopeType() wire.EnvelopeType {
	return wire.Call
}

// Bar_ArgWithHeaders_Helper provides functions that aid in handling the
// parameters and return values of the Bar.argWithHeaders
// function.
var Bar_ArgWithHeaders_Helper = struct {
	// Args accepts the parameters of argWithHeaders in-order and returns
	// the arguments struct for the function.
	Args func(
		name string,
		userUUID *string,
		paramsStruct *OptionalParamsStruct,
	) *Bar_ArgWithHeaders_Args

	// IsException returns true if the given error can be thrown
	// by argWithHeaders.
	//
	// An error can be thrown by argWithHeaders only if the
	// corresponding exception type was mentioned in the 'throws'
	// section for it in the Thrift file.
	IsException func(error) bool

	// WrapResponse returns the result struct for argWithHeaders
	// given its return value and error.
	//
	// This allows mapping values and errors returned by
	// argWithHeaders into a serializable result struct.
	// WrapResponse returns a non-nil error if the provided
	// error cannot be thrown by argWithHeaders
	//
	//   value, err := argWithHeaders(args)
	//   result, err := Bar_ArgWithHeaders_Helper.WrapResponse(value, err)
	//   if err != nil {
	//     return fmt.Errorf("unexpected error from argWithHeaders: %v", err)
	//   }
	//   serialize(result)
	WrapResponse func(*BarResponse, error) (*Bar_ArgWithHeaders_Result, error)

	// UnwrapResponse takes the result struct for argWithHeaders
	// and returns the value or error returned by it.
	//
	// The error is non-nil only if argWithHeaders threw an
	// exception.
	//
	//   result := deserialize(bytes)
	//   value, err := Bar_ArgWithHeaders_Helper.UnwrapResponse(result)
	UnwrapResponse func(*Bar_ArgWithHeaders_Result) (*BarResponse, error)
}{}

func init() {
	Bar_ArgWithHeaders_Helper.Args = func(
		name string,
		userUUID *string,
		paramsStruct *OptionalParamsStruct,
	) *Bar_ArgWithHeaders_Args {
		return &Bar_ArgWithHeaders_Args{
			Name:         name,
			UserUUID:     userUUID,
			ParamsStruct: paramsStruct,
		}
	}

	Bar_ArgWithHeaders_Helper.IsException = func(err error) bool {
		switch err.(type) {
		default:
			return false
		}
	}

	Bar_ArgWithHeaders_Helper.WrapResponse = func(success *BarResponse, err error) (*Bar_ArgWithHeaders_Result, error) {
		if err == nil {
			return &Bar_ArgWithHeaders_Result{Success: success}, nil
		}

		return nil, err
	}
	Bar_ArgWithHeaders_Helper.UnwrapResponse = func(result *Bar_ArgWithHeaders_Result) (success *BarResponse, err error) {

		if result.Success != nil {
			success = result.Success
			return
		}

		err = errors.New("expected a non-void result")
		return
	}

}

// Bar_ArgWithHeaders_Result represents the result of a Bar.argWithHeaders function call.
//
// The result of a argWithHeaders execution is sent and received over the wire as this struct.
//
// Success is set only if the function did not throw an exception.
type Bar_ArgWithHeaders_Result struct {
	// Value returned by argWithHeaders after a successful execution.
	Success *BarResponse `json:"success,omitempty"`
}

// ToWire translates a Bar_ArgWithHeaders_Result struct into a Thrift-level intermediate
// representation. This intermediate representation may be serialized
// into bytes using a ThriftRW protocol implementation.
//
// An error is returned if the struct or any of its fields failed to
// validate.
//
//   x, err := v.ToWire()
//   if err != nil {
//     return err
//   }
//
//   if err := binaryProtocol.Encode(x, writer); err != nil {
//     return err
//   }
func (v *Bar_ArgWithHeaders_Result) ToWire() (wire.Value, error) {
	var (
		fields [1]wire.Field
		i      int = 0
		w      wire.Value
		err    error
	)

	if v.Success != nil {
		w, err = v.Success.ToWire()
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 0, Value: w}
		i++
	}

	if i != 1 {
		return wire.Value{}, fmt.Errorf("Bar_ArgWithHeaders_Result should have exactly one field: got %v fields", i)
	}

	return wire.NewValueStruct(wire.Struct{Fields: fields[:i]}), nil
}

// FromWire deserializes a Bar_ArgWithHeaders_Result struct from its Thrift-level
// representation. The Thrift-level representation may be obtained
// from a ThriftRW protocol implementation.
//
// An error is returned if we were unable to build a Bar_ArgWithHeaders_Result struct
// from the provided intermediate representation.
//
//   x, err := binaryProtocol.Decode(reader, wire.TStruct)
//   if err != nil {
//     return nil, err
//   }
//
//   var v Bar_ArgWithHeaders_Result
//   if err := v.FromWire(x); err != nil {
//     return nil, err
//   }
//   return &v, nil
func (v *Bar_ArgWithHeaders_Result) FromWire(w wire.Value) error {
	var err error

	for _, field := range w.GetStruct().Fields {
		switch field.ID {
		case 0:
			if field.Value.Type() == wire.TStruct {
				v.Success, err = _BarResponse_Read(field.Value)
				if err != nil {
					return err
				}

			}
		}
	}

	count := 0
	if v.Success != nil {
		count++
	}
	if count != 1 {
		return fmt.Errorf("Bar_ArgWithHeaders_Result should have exactly one field: got %v fields", count)
	}

	return nil
}

// String returns a readable string representation of a Bar_ArgWithHeaders_Result
// struct.
func (v *Bar_ArgWithHeaders_Result) String() string {
	if v == nil {
		return "<nil>"
	}

	var fields [1]string
	i := 0
	if v.Success != nil {
		fields[i] = fmt.Sprintf("Success: %v", v.Success)
		i++
	}

	return fmt.Sprintf("Bar_ArgWithHeaders_Result{%v}", strings.Join(fields[:i], ", "))
}

// Equals returns true if all the fields of this Bar_ArgWithHeaders_Result match the
// provided Bar_ArgWithHeaders_Result.
//
// This function performs a deep comparison.
func (v *Bar_ArgWithHeaders_Result) Equals(rhs *Bar_ArgWithHeaders_Result) bool {
	if v == nil {
		return rhs == nil
	} else if rhs == nil {
		return false
	}
	if !((v.Success == nil && rhs.Success == nil) || (v.Success != nil && rhs.Success != nil && v.Success.Equals(rhs.Success))) {
		return false
	}

	return true
}

// MarshalLogObject implements zapcore.ObjectMarshaler, enabling
// fast logging of Bar_ArgWithHeaders_Result.
func (v *Bar_ArgWithHeaders_Result) MarshalLogObject(enc zapcore.ObjectEncoder) (err error) {
	if v == nil {
		return nil
	}
	if v.Success != nil {
		err = multierr.Append(err, enc.AddObject("success", v.Success))
	}
	return err
}

// GetSuccess returns the value of Success if it is set or its
// zero value if it is unset.
func (v *Bar_ArgWithHeaders_Result) GetSuccess() (o *BarResponse) {
	if v != nil && v.Success != nil {
		return v.Success
	}

	return
}

// IsSetSuccess returns true if Success is not nil.
func (v *Bar_ArgWithHeaders_Result) IsSetSuccess() bool {
	return v != nil && v.Success != nil
}

// MethodName returns the name of the Thrift function as specified in
// the IDL, for which this struct represent the result.
//
// This will always be "argWithHeaders" for this struct.
func (v *Bar_ArgWithHeaders_Result) MethodName() string {
	return "argWithHeaders"
}

// EnvelopeType returns the kind of value inside this struct.
//
// This will always be Reply for this struct.
func (v *Bar_ArgWithHeaders_Result) EnvelopeType() wire.EnvelopeType {
	return wire.Reply
}

// Bar_ArgWithManyQueryParams_Args represents the arguments for the Bar.argWithManyQueryParams function.
//
// The arguments for argWithManyQueryParams are sent and received over the wire as this struct.
type Bar_ArgWithManyQueryParams_Args struct {
	AStr            string     `json:"aStr,required"`
	AnOptStr        *string    `json:"anOptStr,omitempty"`
	ABool           bool       `json:"aBool,required"`
	AnOptBool       *bool      `json:"anOptBool,omitempty"`
	AInt8           int8       `json:"aInt8,required"`
	AnOptInt8       *int8      `json:"anOptInt8,omitempty"`
	AInt16          int16      `json:"aInt16,required"`
	AnOptInt16      *int16     `json:"anOptInt16,omitempty"`
	AInt32          int32      `json:"aInt32,required"`
	AnOptInt32      *int32     `json:"anOptInt32,omitempty"`
	AInt64          int64      `json:"aInt64,required"`
	AnOptInt64      *int64     `json:"anOptInt64,omitempty"`
	AFloat64        float64    `json:"aFloat64,required"`
	AnOptFloat64    *float64   `json:"anOptFloat64,omitempty"`
	AUUID           UUID       `json:"aUUID,required"`
	AnOptUUID       *UUID      `json:"anOptUUID,omitempty"`
	AListUUID       []UUID     `json:"aListUUID,required"`
	AnOptListUUID   []UUID     `json:"anOptListUUID,omitempty"`
	AStringList     StringList `json:"aStringList,required"`
	AnOptStringList StringList `json:"anOptStringList,omitempty"`
	AUUIDList       UUIDList   `json:"aUUIDList,required"`
	AnOptUUIDList   UUIDList   `json:"anOptUUIDList,omitempty"`
	ATs             Timestamp  `json:"aTs,required"`
	AnOptTs         *Timestamp `json:"anOptTs,omitempty"`
	AReqDemo        DemoType   `json:"aReqDemo,required"`
	AnOptFruit      *Fruit     `json:"anOptFruit,omitempty"`
	AReqFruits      []Fruit    `json:"aReqFruits,required"`
	AnOptDemos      []DemoType `json:"anOptDemos,omitempty"`
}

type _List_Fruit_ValueList []Fruit

func (v _List_Fruit_ValueList) ForEach(f func(wire.Value) error) error {
	for _, x := range v {
		w, err := x.ToWire()
		if err != nil {
			return err
		}
		err = f(w)
		if err != nil {
			return err
		}
	}
	return nil
}

func (v _List_Fruit_ValueList) Size() int {
	return len(v)
}

func (_List_Fruit_ValueList) ValueType() wire.Type {
	return wire.TI32
}

func (_List_Fruit_ValueList) Close() {}

type _List_DemoType_ValueList []DemoType

func (v _List_DemoType_ValueList) ForEach(f func(wire.Value) error) error {
	for _, x := range v {
		w, err := x.ToWire()
		if err != nil {
			return err
		}
		err = f(w)
		if err != nil {
			return err
		}
	}
	return nil
}

func (v _List_DemoType_ValueList) Size() int {
	return len(v)
}

func (_List_DemoType_ValueList) ValueType() wire.Type {
	return wire.TI32
}

func (_List_DemoType_ValueList) Close() {}

// ToWire translates a Bar_ArgWithManyQueryParams_Args struct into a Thrift-level intermediate
// representation. This intermediate representation may be serialized
// into bytes using a ThriftRW protocol implementation.
//
// An error is returned if the struct or any of its fields failed to
// validate.
//
//   x, err := v.ToWire()
//   if err != nil {
//     return err
//   }
//
//   if err := binaryProtocol.Encode(x, writer); err != nil {
//     return err
//   }
func (v *Bar_ArgWithManyQueryParams_Args) ToWire() (wire.Value, error) {
	var (
		fields [28]wire.Field
		i      int = 0
		w      wire.Value
		err    error
	)

	w, err = wire.NewValueString(v.AStr), error(nil)
	if err != nil {
		return w, err
	}
	fields[i] = wire.Field{ID: 1, Value: w}
	i++
	if v.AnOptStr != nil {
		w, err = wire.NewValueString(*(v.AnOptStr)), error(nil)
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 2, Value: w}
		i++
	}

	w, err = wire.NewValueBool(v.ABool), error(nil)
	if err != nil {
		return w, err
	}
	fields[i] = wire.Field{ID: 3, Value: w}
	i++
	if v.AnOptBool != nil {
		w, err = wire.NewValueBool(*(v.AnOptBool)), error(nil)
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 4, Value: w}
		i++
	}

	w, err = wire.NewValueI8(v.AInt8), error(nil)
	if err != nil {
		return w, err
	}
	fields[i] = wire.Field{ID: 5, Value: w}
	i++
	if v.AnOptInt8 != nil {
		w, err = wire.NewValueI8(*(v.AnOptInt8)), error(nil)
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 6, Value: w}
		i++
	}

	w, err = wire.NewValueI16(v.AInt16), error(nil)
	if err != nil {
		return w, err
	}
	fields[i] = wire.Field{ID: 7, Value: w}
	i++
	if v.AnOptInt16 != nil {
		w, err = wire.NewValueI16(*(v.AnOptInt16)), error(nil)
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 8, Value: w}
		i++
	}

	w, err = wire.NewValueI32(v.AInt32), error(nil)
	if err != nil {
		return w, err
	}
	fields[i] = wire.Field{ID: 9, Value: w}
	i++
	if v.AnOptInt32 != nil {
		w, err = wire.NewValueI32(*(v.AnOptInt32)), error(nil)
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 10, Value: w}
		i++
	}

	w, err = wire.NewValueI64(v.AInt64), error(nil)
	if err != nil {
		return w, err
	}
	fields[i] = wire.Field{ID: 11, Value: w}
	i++
	if v.AnOptInt64 != nil {
		w, err = wire.NewValueI64(*(v.AnOptInt64)), error(nil)
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 12, Value: w}
		i++
	}

	w, err = wire.NewValueDouble(v.AFloat64), error(nil)
	if err != nil {
		return w, err
	}
	fields[i] = wire.Field{ID: 13, Value: w}
	i++
	if v.AnOptFloat64 != nil {
		w, err = wire.NewValueDouble(*(v.AnOptFloat64)), error(nil)
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 14, Value: w}
		i++
	}

	w, err = v.AUUID.ToWire()
	if err != nil {
		return w, err
	}
	fields[i] = wire.Field{ID: 15, Value: w}
	i++
	if v.AnOptUUID != nil {
		w, err = v.AnOptUUID.ToWire()
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 16, Value: w}
		i++
	}

	w, err = wire.NewValueList(_List_UUID_ValueList(v.AListUUID)), error(nil)
	if err != nil {
		return w, err
	}
	fields[i] = wire.Field{ID: 17, Value: w}
	i++
	if v.AnOptListUUID != nil {
		w, err = wire.NewValueList(_List_UUID_ValueList(v.AnOptListUUID)), error(nil)
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 18, Value: w}
		i++
	}

	w, err = v.AStringList.ToWire()
	if err != nil {
		return w, err
	}
	fields[i] = wire.Field{ID: 19, Value: w}
	i++
	if v.AnOptStringList != nil {
		w, err = v.AnOptStringList.ToWire()
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 20, Value: w}
		i++
	}

	w, err = v.AUUIDList.ToWire()
	if err != nil {
		return w, err
	}
	fields[i] = wire.Field{ID: 21, Value: w}
	i++
	if v.AnOptUUIDList != nil {
		w, err = v.AnOptUUIDList.ToWire()
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 22, Value: w}
		i++
	}

	w, err = v.ATs.ToWire()
	if err != nil {
		return w, err
	}
	fields[i] = wire.Field{ID: 23, Value: w}
	i++
	if v.AnOptTs != nil {
		w, err = v.AnOptTs.ToWire()
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 24, Value: w}
		i++
	}

	w, err = v.AReqDemo.ToWire()
	if err != nil {
		return w, err
	}
	fields[i] = wire.Field{ID: 25, Value: w}
	i++
	if v.AnOptFruit != nil {
		w, err = v.AnOptFruit.ToWire()
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 26, Value: w}
		i++
	}

	w, err = wire.NewValueList(_List_Fruit_ValueList(v.AReqFruits)), error(nil)
	if err != nil {
		return w, err
	}
	fields[i] = wire.Field{ID: 27, Value: w}
	i++
	if v.AnOptDemos != nil {
		w, err = wire.NewValueList(_List_DemoType_ValueList(v.AnOptDemos)), error(nil)
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 28, Value: w}
		i++
	}

	return wire.NewValueStruct(wire.Struct{Fields: fields[:i]}), nil
}

func _StringList_Read(w wire.Value) (StringList, error) {
	var x StringList
	err := x.FromWire(w)
	return x, err
}

func _UUIDList_Read(w wire.Value) (UUIDList, error) {
	var x UUIDList
	err := x.FromWire(w)
	return x, err
}

func _DemoType_Read(w wire.Value) (DemoType, error) {
	var v DemoType
	err := v.FromWire(w)
	return v, err
}

func _List_Fruit_Read(l wire.ValueList) ([]Fruit, error) {
	if l.ValueType() != wire.TI32 {
		return nil, nil
	}

	o := make([]Fruit, 0, l.Size())
	err := l.ForEach(func(x wire.Value) error {
		i, err := _Fruit_Read(x)
		if err != nil {
			return err
		}
		o = append(o, i)
		return nil
	})
	l.Close()
	return o, err
}

func _List_DemoType_Read(l wire.ValueList) ([]DemoType, error) {
	if l.ValueType() != wire.TI32 {
		return nil, nil
	}

	o := make([]DemoType, 0, l.Size())
	err := l.ForEach(func(x wire.Value) error {
		i, err := _DemoType_Read(x)
		if err != nil {
			return err
		}
		o = append(o, i)
		return nil
	})
	l.Close()
	return o, err
}

// FromWire deserializes a Bar_ArgWithManyQueryParams_Args struct from its Thrift-level
// representation. The Thrift-level representation may be obtained
// from a ThriftRW protocol implementation.
//
// An error is returned if we were unable to build a Bar_ArgWithManyQueryParams_Args struct
// from the provided intermediate representation.
//
//   x, err := binaryProtocol.Decode(reader, wire.TStruct)
//   if err != nil {
//     return nil, err
//   }
//
//   var v Bar_ArgWithManyQueryParams_Args
//   if err := v.FromWire(x); err != nil {
//     return nil, err
//   }
//   return &v, nil
func (v *Bar_ArgWithManyQueryParams_Args) FromWire(w wire.Value) error {
	var err error

	aStrIsSet := false

	aBoolIsSet := false

	aInt8IsSet := false

	aInt16IsSet := false

	aInt32IsSet := false

	aInt64IsSet := false

	aFloat64IsSet := false

	aUUIDIsSet := false

	aListUUIDIsSet := false

	aStringListIsSet := false

	aUUIDListIsSet := false

	aTsIsSet := false

	aReqDemoIsSet := false

	aReqFruitsIsSet := false

	for _, field := range w.GetStruct().Fields {
		switch field.ID {
		case 1:
			if field.Value.Type() == wire.TBinary {
				v.AStr, err = field.Value.GetString(), error(nil)
				if err != nil {
					return err
				}
				aStrIsSet = true
			}
		case 2:
			if field.Value.Type() == wire.TBinary {
				var x string
				x, err = field.Value.GetString(), error(nil)
				v.AnOptStr = &x
				if err != nil {
					return err
				}

			}
		case 3:
			if field.Value.Type() == wire.TBool {
				v.ABool, err = field.Value.GetBool(), error(nil)
				if err != nil {
					return err
				}
				aBoolIsSet = true
			}
		case 4:
			if field.Value.Type() == wire.TBool {
				var x bool
				x, err = field.Value.GetBool(), error(nil)
				v.AnOptBool = &x
				if err != nil {
					return err
				}

			}
		case 5:
			if field.Value.Type() == wire.TI8 {
				v.AInt8, err = field.Value.GetI8(), error(nil)
				if err != nil {
					return err
				}
				aInt8IsSet = true
			}
		case 6:
			if field.Value.Type() == wire.TI8 {
				var x int8
				x, err = field.Value.GetI8(), error(nil)
				v.AnOptInt8 = &x
				if err != nil {
					return err
				}

			}
		case 7:
			if field.Value.Type() == wire.TI16 {
				v.AInt16, err = field.Value.GetI16(), error(nil)
				if err != nil {
					return err
				}
				aInt16IsSet = true
			}
		case 8:
			if field.Value.Type() == wire.TI16 {
				var x int16
				x, err = field.Value.GetI16(), error(nil)
				v.AnOptInt16 = &x
				if err != nil {
					return err
				}

			}
		case 9:
			if field.Value.Type() == wire.TI32 {
				v.AInt32, err = field.Value.GetI32(), error(nil)
				if err != nil {
					return err
				}
				aInt32IsSet = true
			}
		case 10:
			if field.Value.Type() == wire.TI32 {
				var x int32
				x, err = field.Value.GetI32(), error(nil)
				v.AnOptInt32 = &x
				if err != nil {
					return err
				}

			}
		case 11:
			if field.Value.Type() == wire.TI64 {
				v.AInt64, err = field.Value.GetI64(), error(nil)
				if err != nil {
					return err
				}
				aInt64IsSet = true
			}
		case 12:
			if field.Value.Type() == wire.TI64 {
				var x int64
				x, err = field.Value.GetI64(), error(nil)
				v.AnOptInt64 = &x
				if err != nil {
					return err
				}

			}
		case 13:
			if field.Value.Type() == wire.TDouble {
				v.AFloat64, err = field.Value.GetDouble(), error(nil)
				if err != nil {
					return err
				}
				aFloat64IsSet = true
			}
		case 14:
			if field.Value.Type() == wire.TDouble {
				var x float64
				x, err = field.Value.GetDouble(), error(nil)
				v.AnOptFloat64 = &x
				if err != nil {
					return err
				}

			}
		case 15:
			if field.Value.Type() == wire.TBinary {
				v.AUUID, err = _UUID_Read(field.Value)
				if err != nil {
					return err
				}
				aUUIDIsSet = true
			}
		case 16:
			if field.Value.Type() == wire.TBinary {
				var x UUID
				x, err = _UUID_Read(field.Value)
				v.AnOptUUID = &x
				if err != nil {
					return err
				}

			}
		case 17:
			if field.Value.Type() == wire.TList {
				v.AListUUID, err = _List_UUID_Read(field.Value.GetList())
				if err != nil {
					return err
				}
				aListUUIDIsSet = true
			}
		case 18:
			if field.Value.Type() == wire.TList {
				v.AnOptListUUID, err = _List_UUID_Read(field.Value.GetList())
				if err != nil {
					return err
				}

			}
		case 19:
			if field.Value.Type() == wire.TList {
				v.AStringList, err = _StringList_Read(field.Value)
				if err != nil {
					return err
				}
				aStringListIsSet = true
			}
		case 20:
			if field.Value.Type() == wire.TList {
				v.AnOptStringList, err = _StringList_Read(field.Value)
				if err != nil {
					return err
				}

			}
		case 21:
			if field.Value.Type() == wire.TList {
				v.AUUIDList, err = _UUIDList_Read(field.Value)
				if err != nil {
					return err
				}
				aUUIDListIsSet = true
			}
		case 22:
			if field.Value.Type() == wire.TList {
				v.AnOptUUIDList, err = _UUIDList_Read(field.Value)
				if err != nil {
					return err
				}

			}
		case 23:
			if field.Value.Type() == wire.TI64 {
				v.ATs, err = _Timestamp_Read(field.Value)
				if err != nil {
					return err
				}
				aTsIsSet = true
			}
		case 24:
			if field.Value.Type() == wire.TI64 {
				var x Timestamp
				x, err = _Timestamp_Read(field.Value)
				v.AnOptTs = &x
				if err != nil {
					return err
				}

			}
		case 25:
			if field.Value.Type() == wire.TI32 {
				v.AReqDemo, err = _DemoType_Read(field.Value)
				if err != nil {
					return err
				}
				aReqDemoIsSet = true
			}
		case 26:
			if field.Value.Type() == wire.TI32 {
				var x Fruit
				x, err = _Fruit_Read(field.Value)
				v.AnOptFruit = &x
				if err != nil {
					return err
				}

			}
		case 27:
			if field.Value.Type() == wire.TList {
				v.AReqFruits, err = _List_Fruit_Read(field.Value.GetList())
				if err != nil {
					return err
				}
				aReqFruitsIsSet = true
			}
		case 28:
			if field.Value.Type() == wire.TList {
				v.AnOptDemos, err = _List_DemoType_Read(field.Value.GetList())
				if err != nil {
					return err
				}

			}
		}
	}

	if !aStrIsSet {
		return errors.New("field AStr of Bar_ArgWithManyQueryParams_Args is required")
	}

	if !aBoolIsSet {
		return errors.New("field ABool of Bar_ArgWithManyQueryParams_Args is required")
	}

	if !aInt8IsSet {
		return errors.New("field AInt8 of Bar_ArgWithManyQueryParams_Args is required")
	}

	if !aInt16IsSet {
		return errors.New("field AInt16 of Bar_ArgWithManyQueryParams_Args is required")
	}

	if !aInt32IsSet {
		return errors.New("field AInt32 of Bar_ArgWithManyQueryParams_Args is required")
	}

	if !aInt64IsSet {
		return errors.New("field AInt64 of Bar_ArgWithManyQueryParams_Args is required")
	}

	if !aFloat64IsSet {
		return errors.New("field AFloat64 of Bar_ArgWithManyQueryParams_Args is required")
	}

	if !aUUIDIsSet {
		return errors.New("field AUUID of Bar_ArgWithManyQueryParams_Args is required")
	}

	if !aListUUIDIsSet {
		return errors.New("field AListUUID of Bar_ArgWithManyQueryParams_Args is required")
	}

	if !aStringListIsSet {
		return errors.New("field AStringList of Bar_ArgWithManyQueryParams_Args is required")
	}

	if !aUUIDListIsSet {
		return errors.New("field AUUIDList of Bar_ArgWithManyQueryParams_Args is required")
	}

	if !aTsIsSet {
		return errors.New("field ATs of Bar_ArgWithManyQueryParams_Args is required")
	}

	if !aReqDemoIsSet {
		return errors.New("field AReqDemo of Bar_ArgWithManyQueryParams_Args is required")
	}

	if !aReqFruitsIsSet {
		return errors.New("field AReqFruits of Bar_ArgWithManyQueryParams_Args is required")
	}

	return nil
}

// String returns a readable string representation of a Bar_ArgWithManyQueryParams_Args
// struct.
func (v *Bar_ArgWithManyQueryParams_Args) String() string {
	if v == nil {
		return "<nil>"
	}

	var fields [28]string
	i := 0
	fields[i] = fmt.Sprintf("AStr: %v", v.AStr)
	i++
	if v.AnOptStr != nil {
		fields[i] = fmt.Sprintf("AnOptStr: %v", *(v.AnOptStr))
		i++
	}
	fields[i] = fmt.Sprintf("ABool: %v", v.ABool)
	i++
	if v.AnOptBool != nil {
		fields[i] = fmt.Sprintf("AnOptBool: %v", *(v.AnOptBool))
		i++
	}
	fields[i] = fmt.Sprintf("AInt8: %v", v.AInt8)
	i++
	if v.AnOptInt8 != nil {
		fields[i] = fmt.Sprintf("AnOptInt8: %v", *(v.AnOptInt8))
		i++
	}
	fields[i] = fmt.Sprintf("AInt16: %v", v.AInt16)
	i++
	if v.AnOptInt16 != nil {
		fields[i] = fmt.Sprintf("AnOptInt16: %v", *(v.AnOptInt16))
		i++
	}
	fields[i] = fmt.Sprintf("AInt32: %v", v.AInt32)
	i++
	if v.AnOptInt32 != nil {
		fields[i] = fmt.Sprintf("AnOptInt32: %v", *(v.AnOptInt32))
		i++
	}
	fields[i] = fmt.Sprintf("AInt64: %v", v.AInt64)
	i++
	if v.AnOptInt64 != nil {
		fields[i] = fmt.Sprintf("AnOptInt64: %v", *(v.AnOptInt64))
		i++
	}
	fields[i] = fmt.Sprintf("AFloat64: %v", v.AFloat64)
	i++
	if v.AnOptFloat64 != nil {
		fields[i] = fmt.Sprintf("AnOptFloat64: %v", *(v.AnOptFloat64))
		i++
	}
	fields[i] = fmt.Sprintf("AUUID: %v", v.AUUID)
	i++
	if v.AnOptUUID != nil {
		fields[i] = fmt.Sprintf("AnOptUUID: %v", *(v.AnOptUUID))
		i++
	}
	fields[i] = fmt.Sprintf("AListUUID: %v", v.AListUUID)
	i++
	if v.AnOptListUUID != nil {
		fields[i] = fmt.Sprintf("AnOptListUUID: %v", v.AnOptListUUID)
		i++
	}
	fields[i] = fmt.Sprintf("AStringList: %v", v.AStringList)
	i++
	if v.AnOptStringList != nil {
		fields[i] = fmt.Sprintf("AnOptStringList: %v", v.AnOptStringList)
		i++
	}
	fields[i] = fmt.Sprintf("AUUIDList: %v", v.AUUIDList)
	i++
	if v.AnOptUUIDList != nil {
		fields[i] = fmt.Sprintf("AnOptUUIDList: %v", v.AnOptUUIDList)
		i++
	}
	fields[i] = fmt.Sprintf("ATs: %v", v.ATs)
	i++
	if v.AnOptTs != nil {
		fields[i] = fmt.Sprintf("AnOptTs: %v", *(v.AnOptTs))
		i++
	}
	fields[i] = fmt.Sprintf("AReqDemo: %v", v.AReqDemo)
	i++
	if v.AnOptFruit != nil {
		fields[i] = fmt.Sprintf("AnOptFruit: %v", *(v.AnOptFruit))
		i++
	}
	fields[i] = fmt.Sprintf("AReqFruits: %v", v.AReqFruits)
	i++
	if v.AnOptDemos != nil {
		fields[i] = fmt.Sprintf("AnOptDemos: %v", v.AnOptDemos)
		i++
	}

	return fmt.Sprintf("Bar_ArgWithManyQueryParams_Args{%v}", strings.Join(fields[:i], ", "))
}

func _Bool_EqualsPtr(lhs, rhs *bool) bool {
	if lhs != nil && rhs != nil {

		x := *lhs
		y := *rhs
		return (x == y)
	}
	return lhs == nil && rhs == nil
}

func _Byte_EqualsPtr(lhs, rhs *int8) bool {
	if lhs != nil && rhs != nil {

		x := *lhs
		y := *rhs
		return (x == y)
	}
	return lhs == nil && rhs == nil
}

func _I16_EqualsPtr(lhs, rhs *int16) bool {
	if lhs != nil && rhs != nil {

		x := *lhs
		y := *rhs
		return (x == y)
	}
	return lhs == nil && rhs == nil
}

func _I32_EqualsPtr(lhs, rhs *int32) bool {
	if lhs != nil && rhs != nil {

		x := *lhs
		y := *rhs
		return (x == y)
	}
	return lhs == nil && rhs == nil
}

func _I64_EqualsPtr(lhs, rhs *int64) bool {
	if lhs != nil && rhs != nil {

		x := *lhs
		y := *rhs
		return (x == y)
	}
	return lhs == nil && rhs == nil
}

func _Double_EqualsPtr(lhs, rhs *float64) bool {
	if lhs != nil && rhs != nil {

		x := *lhs
		y := *rhs
		return (x == y)
	}
	return lhs == nil && rhs == nil
}

func _UUID_EqualsPtr(lhs, rhs *UUID) bool {
	if lhs != nil && rhs != nil {

		x := *lhs
		y := *rhs
		return (x == y)
	}
	return lhs == nil && rhs == nil
}

func _Timestamp_EqualsPtr(lhs, rhs *Timestamp) bool {
	if lhs != nil && rhs != nil {

		x := *lhs
		y := *rhs
		return (x == y)
	}
	return lhs == nil && rhs == nil
}

func _Fruit_EqualsPtr(lhs, rhs *Fruit) bool {
	if lhs != nil && rhs != nil {

		x := *lhs
		y := *rhs
		return x.Equals(y)
	}
	return lhs == nil && rhs == nil
}

func _List_Fruit_Equals(lhs, rhs []Fruit) bool {
	if len(lhs) != len(rhs) {
		return false
	}

	for i, lv := range lhs {
		rv := rhs[i]
		if !lv.Equals(rv) {
			return false
		}
	}

	return true
}

func _List_DemoType_Equals(lhs, rhs []DemoType) bool {
	if len(lhs) != len(rhs) {
		return false
	}

	for i, lv := range lhs {
		rv := rhs[i]
		if !lv.Equals(rv) {
			return false
		}
	}

	return true
}

// Equals returns true if all the fields of this Bar_ArgWithManyQueryParams_Args match the
// provided Bar_ArgWithManyQueryParams_Args.
//
// This function performs a deep comparison.
func (v *Bar_ArgWithManyQueryParams_Args) Equals(rhs *Bar_ArgWithManyQueryParams_Args) bool {
	if v == nil {
		return rhs == nil
	} else if rhs == nil {
		return false
	}
	if !(v.AStr == rhs.AStr) {
		return false
	}
	if !_String_EqualsPtr(v.AnOptStr, rhs.AnOptStr) {
		return false
	}
	if !(v.ABool == rhs.ABool) {
		return false
	}
	if !_Bool_EqualsPtr(v.AnOptBool, rhs.AnOptBool) {
		return false
	}
	if !(v.AInt8 == rhs.AInt8) {
		return false
	}
	if !_Byte_EqualsPtr(v.AnOptInt8, rhs.AnOptInt8) {
		return false
	}
	if !(v.AInt16 == rhs.AInt16) {
		return false
	}
	if !_I16_EqualsPtr(v.AnOptInt16, rhs.AnOptInt16) {
		return false
	}
	if !(v.AInt32 == rhs.AInt32) {
		return false
	}
	if !_I32_EqualsPtr(v.AnOptInt32, rhs.AnOptInt32) {
		return false
	}
	if !(v.AInt64 == rhs.AInt64) {
		return false
	}
	if !_I64_EqualsPtr(v.AnOptInt64, rhs.AnOptInt64) {
		return false
	}
	if !(v.AFloat64 == rhs.AFloat64) {
		return false
	}
	if !_Double_EqualsPtr(v.AnOptFloat64, rhs.AnOptFloat64) {
		return false
	}
	if !(v.AUUID == rhs.AUUID) {
		return false
	}
	if !_UUID_EqualsPtr(v.AnOptUUID, rhs.AnOptUUID) {
		return false
	}
	if !_List_UUID_Equals(v.AListUUID, rhs.AListUUID) {
		return false
	}
	if !((v.AnOptListUUID == nil && rhs.AnOptListUUID == nil) || (v.AnOptListUUID != nil && rhs.AnOptListUUID != nil && _List_UUID_Equals(v.AnOptListUUID, rhs.AnOptListUUID))) {
		return false
	}
	if !v.AStringList.Equals(rhs.AStringList) {
		return false
	}
	if !((v.AnOptStringList == nil && rhs.AnOptStringList == nil) || (v.AnOptStringList != nil && rhs.AnOptStringList != nil && v.AnOptStringList.Equals(rhs.AnOptStringList))) {
		return false
	}
	if !v.AUUIDList.Equals(rhs.AUUIDList) {
		return false
	}
	if !((v.AnOptUUIDList == nil && rhs.AnOptUUIDList == nil) || (v.AnOptUUIDList != nil && rhs.AnOptUUIDList != nil && v.AnOptUUIDList.Equals(rhs.AnOptUUIDList))) {
		return false
	}
	if !(v.ATs == rhs.ATs) {
		return false
	}
	if !_Timestamp_EqualsPtr(v.AnOptTs, rhs.AnOptTs) {
		return false
	}
	if !v.AReqDemo.Equals(rhs.AReqDemo) {
		return false
	}
	if !_Fruit_EqualsPtr(v.AnOptFruit, rhs.AnOptFruit) {
		return false
	}
	if !_List_Fruit_Equals(v.AReqFruits, rhs.AReqFruits) {
		return false
	}
	if !((v.AnOptDemos == nil && rhs.AnOptDemos == nil) || (v.AnOptDemos != nil && rhs.AnOptDemos != nil && _List_DemoType_Equals(v.AnOptDemos, rhs.AnOptDemos))) {
		return false
	}

	return true
}

type _List_Fruit_Zapper []Fruit

// MarshalLogArray implements zapcore.ArrayMarshaler, enabling
// fast logging of _List_Fruit_Zapper.
func (l _List_Fruit_Zapper) MarshalLogArray(enc zapcore.ArrayEncoder) (err error) {
	for _, v := range l {
		err = multierr.Append(err, enc.AppendObject(v))
	}
	return err
}

type _List_DemoType_Zapper []DemoType

// MarshalLogArray implements zapcore.ArrayMarshaler, enabling
// fast logging of _List_DemoType_Zapper.
func (l _List_DemoType_Zapper) MarshalLogArray(enc zapcore.ArrayEncoder) (err error) {
	for _, v := range l {
		err = multierr.Append(err, enc.AppendObject(v))
	}
	return err
}

// MarshalLogObject implements zapcore.ObjectMarshaler, enabling
// fast logging of Bar_ArgWithManyQueryParams_Args.
func (v *Bar_ArgWithManyQueryParams_Args) MarshalLogObject(enc zapcore.ObjectEncoder) (err error) {
	if v == nil {
		return nil
	}
	enc.AddString("aStr", v.AStr)
	if v.AnOptStr != nil {
		enc.AddString("anOptStr", *v.AnOptStr)
	}
	enc.AddBool("aBool", v.ABool)
	if v.AnOptBool != nil {
		enc.AddBool("anOptBool", *v.AnOptBool)
	}
	enc.AddInt8("aInt8", v.AInt8)
	if v.AnOptInt8 != nil {
		enc.AddInt8("anOptInt8", *v.AnOptInt8)
	}
	enc.AddInt16("aInt16", v.AInt16)
	if v.AnOptInt16 != nil {
		enc.AddInt16("anOptInt16", *v.AnOptInt16)
	}
	enc.AddInt32("aInt32", v.AInt32)
	if v.AnOptInt32 != nil {
		enc.AddInt32("anOptInt32", *v.AnOptInt32)
	}
	enc.AddInt64("aInt64", v.AInt64)
	if v.AnOptInt64 != nil {
		enc.AddInt64("anOptInt64", *v.AnOptInt64)
	}
	enc.AddFloat64("aFloat64", v.AFloat64)
	if v.AnOptFloat64 != nil {
		enc.AddFloat64("anOptFloat64", *v.AnOptFloat64)
	}
	enc.AddString("aUUID", (string)(v.AUUID))
	if v.AnOptUUID != nil {
		enc.AddString("anOptUUID", (string)(*v.AnOptUUID))
	}
	err = multierr.Append(err, enc.AddArray("aListUUID", (_List_UUID_Zapper)(v.AListUUID)))
	if v.AnOptListUUID != nil {
		err = multierr.Append(err, enc.AddArray("anOptListUUID", (_List_UUID_Zapper)(v.AnOptListUUID)))
	}
	err = multierr.Append(err, enc.AddArray("aStringList", (_List_String_Zapper)(([]string)(v.AStringList))))
	if v.AnOptStringList != nil {
		err = multierr.Append(err, enc.AddArray("anOptStringList", (_List_String_Zapper)(([]string)(v.AnOptStringList))))
	}
	err = multierr.Append(err, enc.AddArray("aUUIDList", (_List_UUID_Zapper)(([]UUID)(v.AUUIDList))))
	if v.AnOptUUIDList != nil {
		err = multierr.Append(err, enc.AddArray("anOptUUIDList", (_List_UUID_Zapper)(([]UUID)(v.AnOptUUIDList))))
	}
	enc.AddInt64("aTs", (int64)(v.ATs))
	if v.AnOptTs != nil {
		enc.AddInt64("anOptTs", (int64)(*v.AnOptTs))
	}
	err = multierr.Append(err, enc.AddObject("aReqDemo", v.AReqDemo))
	if v.AnOptFruit != nil {
		err = multierr.Append(err, enc.AddObject("anOptFruit", *v.AnOptFruit))
	}
	err = multierr.Append(err, enc.AddArray("aReqFruits", (_List_Fruit_Zapper)(v.AReqFruits)))
	if v.AnOptDemos != nil {
		err = multierr.Append(err, enc.AddArray("anOptDemos", (_List_DemoType_Zapper)(v.AnOptDemos)))
	}
	return err
}

// GetAStr returns the value of AStr if it is set or its
// zero value if it is unset.
func (v *Bar_ArgWithManyQueryParams_Args) GetAStr() (o string) {
	if v != nil {
		o = v.AStr
	}
	return
}

// GetAnOptStr returns the value of AnOptStr if it is set or its
// zero value if it is unset.
func (v *Bar_ArgWithManyQueryParams_Args) GetAnOptStr() (o string) {
	if v != nil && v.AnOptStr != nil {
		return *v.AnOptStr
	}

	return
}

// IsSetAnOptStr returns true if AnOptStr is not nil.
func (v *Bar_ArgWithManyQueryParams_Args) IsSetAnOptStr() bool {
	return v != nil && v.AnOptStr != nil
}

// GetABool returns the value of ABool if it is set or its
// zero value if it is unset.
func (v *Bar_ArgWithManyQueryParams_Args) GetABool() (o bool) {
	if v != nil {
		o = v.ABool
	}
	return
}

// GetAnOptBool returns the value of AnOptBool if it is set or its
// zero value if it is unset.
func (v *Bar_ArgWithManyQueryParams_Args) GetAnOptBool() (o bool) {
	if v != nil && v.AnOptBool != nil {
		return *v.AnOptBool
	}

	return
}

// IsSetAnOptBool returns true if AnOptBool is not nil.
func (v *Bar_ArgWithManyQueryParams_Args) IsSetAnOptBool() bool {
	return v != nil && v.AnOptBool != nil
}

// GetAInt8 returns the value of AInt8 if it is set or its
// zero value if it is unset.
func (v *Bar_ArgWithManyQueryParams_Args) GetAInt8() (o int8) {
	if v != nil {
		o = v.AInt8
	}
	return
}

// GetAnOptInt8 returns the value of AnOptInt8 if it is set or its
// zero value if it is unset.
func (v *Bar_ArgWithManyQueryParams_Args) GetAnOptInt8() (o int8) {
	if v != nil && v.AnOptInt8 != nil {
		return *v.AnOptInt8
	}

	return
}

// IsSetAnOptInt8 returns true if AnOptInt8 is not nil.
func (v *Bar_ArgWithManyQueryParams_Args) IsSetAnOptInt8() bool {
	return v != nil && v.AnOptInt8 != nil
}

// GetAInt16 returns the value of AInt16 if it is set or its
// zero value if it is unset.
func (v *Bar_ArgWithManyQueryParams_Args) GetAInt16() (o int16) {
	if v != nil {
		o = v.AInt16
	}
	return
}

// GetAnOptInt16 returns the value of AnOptInt16 if it is set or its
// zero value if it is unset.
func (v *Bar_ArgWithManyQueryParams_Args) GetAnOptInt16() (o int16) {
	if v != nil && v.AnOptInt16 != nil {
		return *v.AnOptInt16
	}

	return
}

// IsSetAnOptInt16 returns true if AnOptInt16 is not nil.
func (v *Bar_ArgWithManyQueryParams_Args) IsSetAnOptInt16() bool {
	return v != nil && v.AnOptInt16 != nil
}

// GetAInt32 returns the value of AInt32 if it is set or its
// zero value if it is unset.
func (v *Bar_ArgWithManyQueryParams_Args) GetAInt32() (o int32) {
	if v != nil {
		o = v.AInt32
	}
	return
}

// GetAnOptInt32 returns the value of AnOptInt32 if it is set or its
// zero value if it is unset.
func (v *Bar_ArgWithManyQueryParams_Args) GetAnOptInt32() (o int32) {
	if v != nil && v.AnOptInt32 != nil {
		return *v.AnOptInt32
	}

	return
}

// IsSetAnOptInt32 returns true if AnOptInt32 is not nil.
func (v *Bar_ArgWithManyQueryParams_Args) IsSetAnOptInt32() bool {
	return v != nil && v.AnOptInt32 != nil
}

// GetAInt64 returns the value of AInt64 if it is set or its
// zero value if it is unset.
func (v *Bar_ArgWithManyQueryParams_Args) GetAInt64() (o int64) {
	if v != nil {
		o = v.AInt64
	}
	return
}

// GetAnOptInt64 returns the value of AnOptInt64 if it is set or its
// zero value if it is unset.
func (v *Bar_ArgWithManyQueryParams_Args) GetAnOptInt64() (o int64) {
	if v != nil && v.AnOptInt64 != nil {
		return *v.AnOptInt64
	}

	return
}

// IsSetAnOptInt64 returns true if AnOptInt64 is not nil.
func (v *Bar_ArgWithManyQueryParams_Args) IsSetAnOptInt64() bool {
	return v != nil && v.AnOptInt64 != nil
}

// GetAFloat64 returns the value of AFloat64 if it is set or its
// zero value if it is unset.
func (v *Bar_ArgWithManyQueryParams_Args) GetAFloat64() (o float64) {
	if v != nil {
		o = v.AFloat64
	}
	return
}

// GetAnOptFloat64 returns the value of AnOptFloat64 if it is set or its
// zero value if it is unset.
func (v *Bar_ArgWithManyQueryParams_Args) GetAnOptFloat64() (o float64) {
	if v != nil && v.AnOptFloat64 != nil {
		return *v.AnOptFloat64
	}

	return
}

// IsSetAnOptFloat64 returns true if AnOptFloat64 is not nil.
func (v *Bar_ArgWithManyQueryParams_Args) IsSetAnOptFloat64() bool {
	return v != nil && v.AnOptFloat64 != nil
}

// GetAUUID returns the value of AUUID if it is set or its
// zero value if it is unset.
func (v *Bar_ArgWithManyQueryParams_Args) GetAUUID() (o UUID) {
	if v != nil {
		o = v.AUUID
	}
	return
}

// GetAnOptUUID returns the value of AnOptUUID if it is set or its
// zero value if it is unset.
func (v *Bar_ArgWithManyQueryParams_Args) GetAnOptUUID() (o UUID) {
	if v != nil && v.AnOptUUID != nil {
		return *v.AnOptUUID
	}

	return
}

// IsSetAnOptUUID returns true if AnOptUUID is not nil.
func (v *Bar_ArgWithManyQueryParams_Args) IsSetAnOptUUID() bool {
	return v != nil && v.AnOptUUID != nil
}

// GetAListUUID returns the value of AListUUID if it is set or its
// zero value if it is unset.
func (v *Bar_ArgWithManyQueryParams_Args) GetAListUUID() (o []UUID) {
	if v != nil {
		o = v.AListUUID
	}
	return
}

// IsSetAListUUID returns true if AListUUID is not nil.
func (v *Bar_ArgWithManyQueryParams_Args) IsSetAListUUID() bool {
	return v != nil && v.AListUUID != nil
}

// GetAnOptListUUID returns the value of AnOptListUUID if it is set or its
// zero value if it is unset.
func (v *Bar_ArgWithManyQueryParams_Args) GetAnOptListUUID() (o []UUID) {
	if v != nil && v.AnOptListUUID != nil {
		return v.AnOptListUUID
	}

	return
}

// IsSetAnOptListUUID returns true if AnOptListUUID is not nil.
func (v *Bar_ArgWithManyQueryParams_Args) IsSetAnOptListUUID() bool {
	return v != nil && v.AnOptListUUID != nil
}

// GetAStringList returns the value of AStringList if it is set or its
// zero value if it is unset.
func (v *Bar_ArgWithManyQueryParams_Args) GetAStringList() (o StringList) {
	if v != nil {
		o = v.AStringList
	}
	return
}

// IsSetAStringList returns true if AStringList is not nil.
func (v *Bar_ArgWithManyQueryParams_Args) IsSetAStringList() bool {
	return v != nil && v.AStringList != nil
}

// GetAnOptStringList returns the value of AnOptStringList if it is set or its
// zero value if it is unset.
func (v *Bar_ArgWithManyQueryParams_Args) GetAnOptStringList() (o StringList) {
	if v != nil && v.AnOptStringList != nil {
		return v.AnOptStringList
	}

	return
}

// IsSetAnOptStringList returns true if AnOptStringList is not nil.
func (v *Bar_ArgWithManyQueryParams_Args) IsSetAnOptStringList() bool {
	return v != nil && v.AnOptStringList != nil
}

// GetAUUIDList returns the value of AUUIDList if it is set or its
// zero value if it is unset.
func (v *Bar_ArgWithManyQueryParams_Args) GetAUUIDList() (o UUIDList) {
	if v != nil {
		o = v.AUUIDList
	}
	return
}

// IsSetAUUIDList returns true if AUUIDList is not nil.
func (v *Bar_ArgWithManyQueryParams_Args) IsSetAUUIDList() bool {
	return v != nil && v.AUUIDList != nil
}

// GetAnOptUUIDList returns the value of AnOptUUIDList if it is set or its
// zero value if it is unset.
func (v *Bar_ArgWithManyQueryParams_Args) GetAnOptUUIDList() (o UUIDList) {
	if v != nil && v.AnOptUUIDList != nil {
		return v.AnOptUUIDList
	}

	return
}

// IsSetAnOptUUIDList returns true if AnOptUUIDList is not nil.
func (v *Bar_ArgWithManyQueryParams_Args) IsSetAnOptUUIDList() bool {
	return v != nil && v.AnOptUUIDList != nil
}

// GetATs returns the value of ATs if it is set or its
// zero value if it is unset.
func (v *Bar_ArgWithManyQueryParams_Args) GetATs() (o Timestamp) {
	if v != nil {
		o = v.ATs
	}
	return
}

// GetAnOptTs returns the value of AnOptTs if it is set or its
// zero value if it is unset.
func (v *Bar_ArgWithManyQueryParams_Args) GetAnOptTs() (o Timestamp) {
	if v != nil && v.AnOptTs != nil {
		return *v.AnOptTs
	}

	return
}

// IsSetAnOptTs returns true if AnOptTs is not nil.
func (v *Bar_ArgWithManyQueryParams_Args) IsSetAnOptTs() bool {
	return v != nil && v.AnOptTs != nil
}

// GetAReqDemo returns the value of AReqDemo if it is set or its
// zero value if it is unset.
func (v *Bar_ArgWithManyQueryParams_Args) GetAReqDemo() (o DemoType) {
	if v != nil {
		o = v.AReqDemo
	}
	return
}

// GetAnOptFruit returns the value of AnOptFruit if it is set or its
// zero value if it is unset.
func (v *Bar_ArgWithManyQueryParams_Args) GetAnOptFruit() (o Fruit) {
	if v != nil && v.AnOptFruit != nil {
		return *v.AnOptFruit
	}

	return
}

// IsSetAnOptFruit returns true if AnOptFruit is not nil.
func (v *Bar_ArgWithManyQueryParams_Args) IsSetAnOptFruit() bool {
	return v != nil && v.AnOptFruit != nil
}

// GetAReqFruits returns the value of AReqFruits if it is set or its
// zero value if it is unset.
func (v *Bar_ArgWithManyQueryParams_Args) GetAReqFruits() (o []Fruit) {
	if v != nil {
		o = v.AReqFruits
	}
	return
}

// IsSetAReqFruits returns true if AReqFruits is not nil.
func (v *Bar_ArgWithManyQueryParams_Args) IsSetAReqFruits() bool {
	return v != nil && v.AReqFruits != nil
}

// GetAnOptDemos returns the value of AnOptDemos if it is set or its
// zero value if it is unset.
func (v *Bar_ArgWithManyQueryParams_Args) GetAnOptDemos() (o []DemoType) {
	if v != nil && v.AnOptDemos != nil {
		return v.AnOptDemos
	}

	return
}

// IsSetAnOptDemos returns true if AnOptDemos is not nil.
func (v *Bar_ArgWithManyQueryParams_Args) IsSetAnOptDemos() bool {
	return v != nil && v.AnOptDemos != nil
}

// MethodName returns the name of the Thrift function as specified in
// the IDL, for which this struct represent the arguments.
//
// This will always be "argWithManyQueryParams" for this struct.
func (v *Bar_ArgWithManyQueryParams_Args) MethodName() string {
	return "argWithManyQueryParams"
}

// EnvelopeType returns the kind of value inside this struct.
//
// This will always be Call for this struct.
func (v *Bar_ArgWithManyQueryParams_Args) EnvelopeType() wire.EnvelopeType {
	return wire.Call
}

// Bar_ArgWithManyQueryParams_Helper provides functions that aid in handling the
// parameters and return values of the Bar.argWithManyQueryParams
// function.
var Bar_ArgWithManyQueryParams_Helper = struct {
	// Args accepts the parameters of argWithManyQueryParams in-order and returns
	// the arguments struct for the function.
	Args func(
		aStr string,
		anOptStr *string,
		aBool bool,
		anOptBool *bool,
		aInt8 int8,
		anOptInt8 *int8,
		aInt16 int16,
		anOptInt16 *int16,
		aInt32 int32,
		anOptInt32 *int32,
		aInt64 int64,
		anOptInt64 *int64,
		aFloat64 float64,
		anOptFloat64 *float64,
		aUUID UUID,
		anOptUUID *UUID,
		aListUUID []UUID,
		anOptListUUID []UUID,
		aStringList StringList,
		anOptStringList StringList,
		aUUIDList UUIDList,
		anOptUUIDList UUIDList,
		aTs Timestamp,
		anOptTs *Timestamp,
		aReqDemo DemoType,
		anOptFruit *Fruit,
		aReqFruits []Fruit,
		anOptDemos []DemoType,
	) *Bar_ArgWithManyQueryParams_Args

	// IsException returns true if the given error can be thrown
	// by argWithManyQueryParams.
	//
	// An error can be thrown by argWithManyQueryParams only if the
	// corresponding exception type was mentioned in the 'throws'
	// section for it in the Thrift file.
	IsException func(error) bool

	// WrapResponse returns the result struct for argWithManyQueryParams
	// given its return value and error.
	//
	// This allows mapping values and errors returned by
	// argWithManyQueryParams into a serializable result struct.
	// WrapResponse returns a non-nil error if the provided
	// error cannot be thrown by argWithManyQueryParams
	//
	//   value, err := argWithManyQueryParams(args)
	//   result, err := Bar_ArgWithManyQueryParams_Helper.WrapResponse(value, err)
	//   if err != nil {
	//     return fmt.Errorf("unexpected error from argWithManyQueryParams: %v", err)
	//   }
	//   serialize(result)
	WrapResponse func(*BarResponse, error) (*Bar_ArgWithManyQueryParams_Result, error)

	// UnwrapResponse takes the result struct for argWithManyQueryParams
	// and returns the value or error returned by it.
	//
	// The error is non-nil only if argWithManyQueryParams threw an
	// exception.
	//
	//   result := deserialize(bytes)
	//   value, err := Bar_ArgWithManyQueryParams_Helper.UnwrapResponse(result)
	UnwrapResponse func(*Bar_ArgWithManyQueryParams_Result) (*BarResponse, error)
}{}

func init() {
	Bar_ArgWithManyQueryParams_Helper.Args = func(
		aStr string,
		anOptStr *string,
		aBool bool,
		anOptBool *bool,
		aInt8 int8,
		anOptInt8 *int8,
		aInt16 int16,
		anOptInt16 *int16,
		aInt32 int32,
		anOptInt32 *int32,
		aInt64 int64,
		anOptInt64 *int64,
		aFloat64 float64,
		anOptFloat64 *float64,
		aUUID UUID,
		anOptUUID *UUID,
		aListUUID []UUID,
		anOptListUUID []UUID,
		aStringList StringList,
		anOptStringList StringList,
		aUUIDList UUIDList,
		anOptUUIDList UUIDList,
		aTs Timestamp,
		anOptTs *Timestamp,
		aReqDemo DemoType,
		anOptFruit *Fruit,
		aReqFruits []Fruit,
		anOptDemos []DemoType,
	) *Bar_ArgWithManyQueryParams_Args {
		return &Bar_ArgWithManyQueryParams_Args{
			AStr:            aStr,
			AnOptStr:        anOptStr,
			ABool:           aBool,
			AnOptBool:       anOptBool,
			AInt8:           aInt8,
			AnOptInt8:       anOptInt8,
			AInt16:          aInt16,
			AnOptInt16:      anOptInt16,
			AInt32:          aInt32,
			AnOptInt32:      anOptInt32,
			AInt64:          aInt64,
			AnOptInt64:      anOptInt64,
			AFloat64:        aFloat64,
			AnOptFloat64:    anOptFloat64,
			AUUID:           aUUID,
			AnOptUUID:       anOptUUID,
			AListUUID:       aListUUID,
			AnOptListUUID:   anOptListUUID,
			AStringList:     aStringList,
			AnOptStringList: anOptStringList,
			AUUIDList:       aUUIDList,
			AnOptUUIDList:   anOptUUIDList,
			ATs:             aTs,
			AnOptTs:         anOptTs,
			AReqDemo:        aReqDemo,
			AnOptFruit:      anOptFruit,
			AReqFruits:      aReqFruits,
			AnOptDemos:      anOptDemos,
		}
	}

	Bar_ArgWithManyQueryParams_Helper.IsException = func(err error) bool {
		switch err.(type) {
		default:
			return false
		}
	}

	Bar_ArgWithManyQueryParams_Helper.WrapResponse = func(success *BarResponse, err error) (*Bar_ArgWithManyQueryParams_Result, error) {
		if err == nil {
			return &Bar_ArgWithManyQueryParams_Result{Success: success}, nil
		}

		return nil, err
	}
	Bar_ArgWithManyQueryParams_Helper.UnwrapResponse = func(result *Bar_ArgWithManyQueryParams_Result) (success *BarResponse, err error) {

		if result.Success != nil {
			success = result.Success
			return
		}

		err = errors.New("expected a non-void result")
		return
	}

}

// Bar_ArgWithManyQueryParams_Result represents the result of a Bar.argWithManyQueryParams function call.
//
// The result of a argWithManyQueryParams execution is sent and received over the wire as this struct.
//
// Success is set only if the function did not throw an exception.
type Bar_ArgWithManyQueryParams_Result struct {
	// Value returned by argWithManyQueryParams after a successful execution.
	Success *BarResponse `json:"success,omitempty"`
}

// ToWire translates a Bar_ArgWithManyQueryParams_Result struct into a Thrift-level intermediate
// representation. This intermediate representation may be serialized
// into bytes using a ThriftRW protocol implementation.
//
// An error is returned if the struct or any of its fields failed to
// validate.
//
//   x, err := v.ToWire()
//   if err != nil {
//     return err
//   }
//
//   if err := binaryProtocol.Encode(x, writer); err != nil {
//     return err
//   }
func (v *Bar_ArgWithManyQueryParams_Result) ToWire() (wire.Value, error) {
	var (
		fields [1]wire.Field
		i      int = 0
		w      wire.Value
		err    error
	)

	if v.Success != nil {
		w, err = v.Success.ToWire()
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 0, Value: w}
		i++
	}

	if i != 1 {
		return wire.Value{}, fmt.Errorf("Bar_ArgWithManyQueryParams_Result should have exactly one field: got %v fields", i)
	}

	return wire.NewValueStruct(wire.Struct{Fields: fields[:i]}), nil
}

// FromWire deserializes a Bar_ArgWithManyQueryParams_Result struct from its Thrift-level
// representation. The Thrift-level representation may be obtained
// from a ThriftRW protocol implementation.
//
// An error is returned if we were unable to build a Bar_ArgWithManyQueryParams_Result struct
// from the provided intermediate representation.
//
//   x, err := binaryProtocol.Decode(reader, wire.TStruct)
//   if err != nil {
//     return nil, err
//   }
//
//   var v Bar_ArgWithManyQueryParams_Result
//   if err := v.FromWire(x); err != nil {
//     return nil, err
//   }
//   return &v, nil
func (v *Bar_ArgWithManyQueryParams_Result) FromWire(w wire.Value) error {
	var err error

	for _, field := range w.GetStruct().Fields {
		switch field.ID {
		case 0:
			if field.Value.Type() == wire.TStruct {
				v.Success, err = _BarResponse_Read(field.Value)
				if err != nil {
					return err
				}

			}
		}
	}

	count := 0
	if v.Success != nil {
		count++
	}
	if count != 1 {
		return fmt.Errorf("Bar_ArgWithManyQueryParams_Result should have exactly one field: got %v fields", count)
	}

	return nil
}

// String returns a readable string representation of a Bar_ArgWithManyQueryParams_Result
// struct.
func (v *Bar_ArgWithManyQueryParams_Result) String() string {
	if v == nil {
		return "<nil>"
	}

	var fields [1]string
	i := 0
	if v.Success != nil {
		fields[i] = fmt.Sprintf("Success: %v", v.Success)
		i++
	}

	return fmt.Sprintf("Bar_ArgWithManyQueryParams_Result{%v}", strings.Join(fields[:i], ", "))
}

// Equals returns true if all the fields of this Bar_ArgWithManyQueryParams_Result match the
// provided Bar_ArgWithManyQueryParams_Result.
//
// This function performs a deep comparison.
func (v *Bar_ArgWithManyQueryParams_Result) Equals(rhs *Bar_ArgWithManyQueryParams_Result) bool {
	if v == nil {
		return rhs == nil
	} else if rhs == nil {
		return false
	}
	if !((v.Success == nil && rhs.Success == nil) || (v.Success != nil && rhs.Success != nil && v.Success.Equals(rhs.Success))) {
		return false
	}

	return true
}

// MarshalLogObject implements zapcore.ObjectMarshaler, enabling
// fast logging of Bar_ArgWithManyQueryParams_Result.
func (v *Bar_ArgWithManyQueryParams_Result) MarshalLogObject(enc zapcore.ObjectEncoder) (err error) {
	if v == nil {
		return nil
	}
	if v.Success != nil {
		err = multierr.Append(err, enc.AddObject("success", v.Success))
	}
	return err
}

// GetSuccess returns the value of Success if it is set or its
// zero value if it is unset.
func (v *Bar_ArgWithManyQueryParams_Result) GetSuccess() (o *BarResponse) {
	if v != nil && v.Success != nil {
		return v.Success
	}

	return
}

// IsSetSuccess returns true if Success is not nil.
func (v *Bar_ArgWithManyQueryParams_Result) IsSetSuccess() bool {
	return v != nil && v.Success != nil
}

// MethodName returns the name of the Thrift function as specified in
// the IDL, for which this struct represent the result.
//
// This will always be "argWithManyQueryParams" for this struct.
func (v *Bar_ArgWithManyQueryParams_Result) MethodName() string {
	return "argWithManyQueryParams"
}

// EnvelopeType returns the kind of value inside this struct.
//
// This will always be Reply for this struct.
func (v *Bar_ArgWithManyQueryParams_Result) EnvelopeType() wire.EnvelopeType {
	return wire.Reply
}

// Bar_ArgWithNearDupQueryParams_Args represents the arguments for the Bar.argWithNearDupQueryParams function.
//
// The arguments for argWithNearDupQueryParams are sent and received over the wire as this struct.
type Bar_ArgWithNearDupQueryParams_Args struct {
	One   string  `json:"one,required"`
	Two   *int32  `json:"two,omitempty"`
	Three *string `json:"three,omitempty"`
	Four  *string `json:"four,omitempty"`
}

// ToWire translates a Bar_ArgWithNearDupQueryParams_Args struct into a Thrift-level intermediate
// representation. This intermediate representation may be serialized
// into bytes using a ThriftRW protocol implementation.
//
// An error is returned if the struct or any of its fields failed to
// validate.
//
//   x, err := v.ToWire()
//   if err != nil {
//     return err
//   }
//
//   if err := binaryProtocol.Encode(x, writer); err != nil {
//     return err
//   }
func (v *Bar_ArgWithNearDupQueryParams_Args) ToWire() (wire.Value, error) {
	var (
		fields [4]wire.Field
		i      int = 0
		w      wire.Value
		err    error
	)

	w, err = wire.NewValueString(v.One), error(nil)
	if err != nil {
		return w, err
	}
	fields[i] = wire.Field{ID: 1, Value: w}
	i++
	if v.Two != nil {
		w, err = wire.NewValueI32(*(v.Two)), error(nil)
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 2, Value: w}
		i++
	}
	if v.Three != nil {
		w, err = wire.NewValueString(*(v.Three)), error(nil)
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 3, Value: w}
		i++
	}
	if v.Four != nil {
		w, err = wire.NewValueString(*(v.Four)), error(nil)
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 4, Value: w}
		i++
	}

	return wire.NewValueStruct(wire.Struct{Fields: fields[:i]}), nil
}

// FromWire deserializes a Bar_ArgWithNearDupQueryParams_Args struct from its Thrift-level
// representation. The Thrift-level representation may be obtained
// from a ThriftRW protocol implementation.
//
// An error is returned if we were unable to build a Bar_ArgWithNearDupQueryParams_Args struct
// from the provided intermediate representation.
//
//   x, err := binaryProtocol.Decode(reader, wire.TStruct)
//   if err != nil {
//     return nil, err
//   }
//
//   var v Bar_ArgWithNearDupQueryParams_Args
//   if err := v.FromWire(x); err != nil {
//     return nil, err
//   }
//   return &v, nil
func (v *Bar_ArgWithNearDupQueryParams_Args) FromWire(w wire.Value) error {
	var err error

	oneIsSet := false

	for _, field := range w.GetStruct().Fields {
		switch field.ID {
		case 1:
			if field.Value.Type() == wire.TBinary {
				v.One, err = field.Value.GetString(), error(nil)
				if err != nil {
					return err
				}
				oneIsSet = true
			}
		case 2:
			if field.Value.Type() == wire.TI32 {
				var x int32
				x, err = field.Value.GetI32(), error(nil)
				v.Two = &x
				if err != nil {
					return err
				}

			}
		case 3:
			if field.Value.Type() == wire.TBinary {
				var x string
				x, err = field.Value.GetString(), error(nil)
				v.Three = &x
				if err != nil {
					return err
				}

			}
		case 4:
			if field.Value.Type() == wire.TBinary {
				var x string
				x, err = field.Value.GetString(), error(nil)
				v.Four = &x
				if err != nil {
					return err
				}

			}
		}
	}

	if !oneIsSet {
		return errors.New("field One of Bar_ArgWithNearDupQueryParams_Args is required")
	}

	return nil
}

// String returns a readable string representation of a Bar_ArgWithNearDupQueryParams_Args
// struct.
func (v *Bar_ArgWithNearDupQueryParams_Args) String() string {
	if v == nil {
		return "<nil>"
	}

	var fields [4]string
	i := 0
	fields[i] = fmt.Sprintf("One: %v", v.One)
	i++
	if v.Two != nil {
		fields[i] = fmt.Sprintf("Two: %v", *(v.Two))
		i++
	}
	if v.Three != nil {
		fields[i] = fmt.Sprintf("Three: %v", *(v.Three))
		i++
	}
	if v.Four != nil {
		fields[i] = fmt.Sprintf("Four: %v", *(v.Four))
		i++
	}

	return fmt.Sprintf("Bar_ArgWithNearDupQueryParams_Args{%v}", strings.Join(fields[:i], ", "))
}

// Equals returns true if all the fields of this Bar_ArgWithNearDupQueryParams_Args match the
// provided Bar_ArgWithNearDupQueryParams_Args.
//
// This function performs a deep comparison.
func (v *Bar_ArgWithNearDupQueryParams_Args) Equals(rhs *Bar_ArgWithNearDupQueryParams_Args) bool {
	if v == nil {
		return rhs == nil
	} else if rhs == nil {
		return false
	}
	if !(v.One == rhs.One) {
		return false
	}
	if !_I32_EqualsPtr(v.Two, rhs.Two) {
		return false
	}
	if !_String_EqualsPtr(v.Three, rhs.Three) {
		return false
	}
	if !_String_EqualsPtr(v.Four, rhs.Four) {
		return false
	}

	return true
}

// MarshalLogObject implements zapcore.ObjectMarshaler, enabling
// fast logging of Bar_ArgWithNearDupQueryParams_Args.
func (v *Bar_ArgWithNearDupQueryParams_Args) MarshalLogObject(enc zapcore.ObjectEncoder) (err error) {
	if v == nil {
		return nil
	}
	enc.AddString("one", v.One)
	if v.Two != nil {
		enc.AddInt32("two", *v.Two)
	}
	if v.Three != nil {
		enc.AddString("three", *v.Three)
	}
	if v.Four != nil {
		enc.AddString("four", *v.Four)
	}
	return err
}

// GetOne returns the value of One if it is set or its
// zero value if it is unset.
func (v *Bar_ArgWithNearDupQueryParams_Args) GetOne() (o string) {
	if v != nil {
		o = v.One
	}
	return
}

// GetTwo returns the value of Two if it is set or its
// zero value if it is unset.
func (v *Bar_ArgWithNearDupQueryParams_Args) GetTwo() (o int32) {
	if v != nil && v.Two != nil {
		return *v.Two
	}

	return
}

// IsSetTwo returns true if Two is not nil.
func (v *Bar_ArgWithNearDupQueryParams_Args) IsSetTwo() bool {
	return v != nil && v.Two != nil
}

// GetThree returns the value of Three if it is set or its
// zero value if it is unset.
func (v *Bar_ArgWithNearDupQueryParams_Args) GetThree() (o string) {
	if v != nil && v.Three != nil {
		return *v.Three
	}

	return
}

// IsSetThree returns true if Three is not nil.
func (v *Bar_ArgWithNearDupQueryParams_Args) IsSetThree() bool {
	return v != nil && v.Three != nil
}

// GetFour returns the value of Four if it is set or its
// zero value if it is unset.
func (v *Bar_ArgWithNearDupQueryParams_Args) GetFour() (o string) {
	if v != nil && v.Four != nil {
		return *v.Four
	}

	return
}

// IsSetFour returns true if Four is not nil.
func (v *Bar_ArgWithNearDupQueryParams_Args) IsSetFour() bool {
	return v != nil && v.Four != nil
}

// MethodName returns the name of the Thrift function as specified in
// the IDL, for which this struct represent the arguments.
//
// This will always be "argWithNearDupQueryParams" for this struct.
func (v *Bar_ArgWithNearDupQueryParams_Args) MethodName() string {
	return "argWithNearDupQueryParams"
}

// EnvelopeType returns the kind of value inside this struct.
//
// This will always be Call for this struct.
func (v *Bar_ArgWithNearDupQueryParams_Args) EnvelopeType() wire.EnvelopeType {
	return wire.Call
}

// Bar_ArgWithNearDupQueryParams_Helper provides functions that aid in handling the
// parameters and return values of the Bar.argWithNearDupQueryParams
// function.
var Bar_ArgWithNearDupQueryParams_Helper = struct {
	// Args accepts the parameters of argWithNearDupQueryParams in-order and returns
	// the arguments struct for the function.
	Args func(
		one string,
		two *int32,
		three *string,
		four *string,
	) *Bar_ArgWithNearDupQueryParams_Args

	// IsException returns true if the given error can be thrown
	// by argWithNearDupQueryParams.
	//
	// An error can be thrown by argWithNearDupQueryParams only if the
	// corresponding exception type was mentioned in the 'throws'
	// section for it in the Thrift file.
	IsException func(error) bool

	// WrapResponse returns the result struct for argWithNearDupQueryParams
	// given its return value and error.
	//
	// This allows mapping values and errors returned by
	// argWithNearDupQueryParams into a serializable result struct.
	// WrapResponse returns a non-nil error if the provided
	// error cannot be thrown by argWithNearDupQueryParams
	//
	//   value, err := argWithNearDupQueryParams(args)
	//   result, err := Bar_ArgWithNearDupQueryParams_Helper.WrapResponse(value, err)
	//   if err != nil {
	//     return fmt.Errorf("unexpected error from argWithNearDupQueryParams: %v", err)
	//   }
	//   serialize(result)
	WrapResponse func(*BarResponse, error) (*Bar_ArgWithNearDupQueryParams_Result, error)

	// UnwrapResponse takes the result struct for argWithNearDupQueryParams
	// and returns the value or error returned by it.
	//
	// The error is non-nil only if argWithNearDupQueryParams threw an
	// exception.
	//
	//   result := deserialize(bytes)
	//   value, err := Bar_ArgWithNearDupQueryParams_Helper.UnwrapResponse(result)
	UnwrapResponse func(*Bar_ArgWithNearDupQueryParams_Result) (*BarResponse, error)
}{}

func init() {
	Bar_ArgWithNearDupQueryParams_Helper.Args = func(
		one string,
		two *int32,
		three *string,
		four *string,
	) *Bar_ArgWithNearDupQueryParams_Args {
		return &Bar_ArgWithNearDupQueryParams_Args{
			One:   one,
			Two:   two,
			Three: three,
			Four:  four,
		}
	}

	Bar_ArgWithNearDupQueryParams_Helper.IsException = func(err error) bool {
		switch err.(type) {
		default:
			return false
		}
	}

	Bar_ArgWithNearDupQueryParams_Helper.WrapResponse = func(success *BarResponse, err error) (*Bar_ArgWithNearDupQueryParams_Result, error) {
		if err == nil {
			return &Bar_ArgWithNearDupQueryParams_Result{Success: success}, nil
		}

		return nil, err
	}
	Bar_ArgWithNearDupQueryParams_Helper.UnwrapResponse = func(result *Bar_ArgWithNearDupQueryParams_Result) (success *BarResponse, err error) {

		if result.Success != nil {
			success = result.Success
			return
		}

		err = errors.New("expected a non-void result")
		return
	}

}

// Bar_ArgWithNearDupQueryParams_Result represents the result of a Bar.argWithNearDupQueryParams function call.
//
// The result of a argWithNearDupQueryParams execution is sent and received over the wire as this struct.
//
// Success is set only if the function did not throw an exception.
type Bar_ArgWithNearDupQueryParams_Result struct {
	// Value returned by argWithNearDupQueryParams after a successful execution.
	Success *BarResponse `json:"success,omitempty"`
}

// ToWire translates a Bar_ArgWithNearDupQueryParams_Result struct into a Thrift-level intermediate
// representation. This intermediate representation may be serialized
// into bytes using a ThriftRW protocol implementation.
//
// An error is returned if the struct or any of its fields failed to
// validate.
//
//   x, err := v.ToWire()
//   if err != nil {
//     return err
//   }
//
//   if err := binaryProtocol.Encode(x, writer); err != nil {
//     return err
//   }
func (v *Bar_ArgWithNearDupQueryParams_Result) ToWire() (wire.Value, error) {
	var (
		fields [1]wire.Field
		i      int = 0
		w      wire.Value
		err    error
	)

	if v.Success != nil {
		w, err = v.Success.ToWire()
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 0, Value: w}
		i++
	}

	if i != 1 {
		return wire.Value{}, fmt.Errorf("Bar_ArgWithNearDupQueryParams_Result should have exactly one field: got %v fields", i)
	}

	return wire.NewValueStruct(wire.Struct{Fields: fields[:i]}), nil
}

// FromWire deserializes a Bar_ArgWithNearDupQueryParams_Result struct from its Thrift-level
// representation. The Thrift-level representation may be obtained
// from a ThriftRW protocol implementation.
//
// An error is returned if we were unable to build a Bar_ArgWithNearDupQueryParams_Result struct
// from the provided intermediate representation.
//
//   x, err := binaryProtocol.Decode(reader, wire.TStruct)
//   if err != nil {
//     return nil, err
//   }
//
//   var v Bar_ArgWithNearDupQueryParams_Result
//   if err := v.FromWire(x); err != nil {
//     return nil, err
//   }
//   return &v, nil
func (v *Bar_ArgWithNearDupQueryParams_Result) FromWire(w wire.Value) error {
	var err error

	for _, field := range w.GetStruct().Fields {
		switch field.ID {
		case 0:
			if field.Value.Type() == wire.TStruct {
				v.Success, err = _BarResponse_Read(field.Value)
				if err != nil {
					return err
				}

			}
		}
	}

	count := 0
	if v.Success != nil {
		count++
	}
	if count != 1 {
		return fmt.Errorf("Bar_ArgWithNearDupQueryParams_Result should have exactly one field: got %v fields", count)
	}

	return nil
}

// String returns a readable string representation of a Bar_ArgWithNearDupQueryParams_Result
// struct.
func (v *Bar_ArgWithNearDupQueryParams_Result) String() string {
	if v == nil {
		return "<nil>"
	}

	var fields [1]string
	i := 0
	if v.Success != nil {
		fields[i] = fmt.Sprintf("Success: %v", v.Success)
		i++
	}

	return fmt.Sprintf("Bar_ArgWithNearDupQueryParams_Result{%v}", strings.Join(fields[:i], ", "))
}

// Equals returns true if all the fields of this Bar_ArgWithNearDupQueryParams_Result match the
// provided Bar_ArgWithNearDupQueryParams_Result.
//
// This function performs a deep comparison.
func (v *Bar_ArgWithNearDupQueryParams_Result) Equals(rhs *Bar_ArgWithNearDupQueryParams_Result) bool {
	if v == nil {
		return rhs == nil
	} else if rhs == nil {
		return false
	}
	if !((v.Success == nil && rhs.Success == nil) || (v.Success != nil && rhs.Success != nil && v.Success.Equals(rhs.Success))) {
		return false
	}

	return true
}

// MarshalLogObject implements zapcore.ObjectMarshaler, enabling
// fast logging of Bar_ArgWithNearDupQueryParams_Result.
func (v *Bar_ArgWithNearDupQueryParams_Result) MarshalLogObject(enc zapcore.ObjectEncoder) (err error) {
	if v == nil {
		return nil
	}
	if v.Success != nil {
		err = multierr.Append(err, enc.AddObject("success", v.Success))
	}
	return err
}

// GetSuccess returns the value of Success if it is set or its
// zero value if it is unset.
func (v *Bar_ArgWithNearDupQueryParams_Result) GetSuccess() (o *BarResponse) {
	if v != nil && v.Success != nil {
		return v.Success
	}

	return
}

// IsSetSuccess returns true if Success is not nil.
func (v *Bar_ArgWithNearDupQueryParams_Result) IsSetSuccess() bool {
	return v != nil && v.Success != nil
}

// MethodName returns the name of the Thrift function as specified in
// the IDL, for which this struct represent the result.
//
// This will always be "argWithNearDupQueryParams" for this struct.
func (v *Bar_ArgWithNearDupQueryParams_Result) MethodName() string {
	return "argWithNearDupQueryParams"
}

// EnvelopeType returns the kind of value inside this struct.
//
// This will always be Reply for this struct.
func (v *Bar_ArgWithNearDupQueryParams_Result) EnvelopeType() wire.EnvelopeType {
	return wire.Reply
}

// Bar_ArgWithNestedQueryParams_Args represents the arguments for the Bar.argWithNestedQueryParams function.
//
// The arguments for argWithNestedQueryParams are sent and received over the wire as this struct.
type Bar_ArgWithNestedQueryParams_Args struct {
	Request *QueryParamsStruct     `json:"request,required"`
	Opt     *QueryParamsOptsStruct `json:"opt,omitempty"`
}

// ToWire translates a Bar_ArgWithNestedQueryParams_Args struct into a Thrift-level intermediate
// representation. This intermediate representation may be serialized
// into bytes using a ThriftRW protocol implementation.
//
// An error is returned if the struct or any of its fields failed to
// validate.
//
//   x, err := v.ToWire()
//   if err != nil {
//     return err
//   }
//
//   if err := binaryProtocol.Encode(x, writer); err != nil {
//     return err
//   }
func (v *Bar_ArgWithNestedQueryParams_Args) ToWire() (wire.Value, error) {
	var (
		fields [2]wire.Field
		i      int = 0
		w      wire.Value
		err    error
	)

	if v.Request == nil {
		return w, errors.New("field Request of Bar_ArgWithNestedQueryParams_Args is required")
	}
	w, err = v.Request.ToWire()
	if err != nil {
		return w, err
	}
	fields[i] = wire.Field{ID: 1, Value: w}
	i++
	if v.Opt != nil {
		w, err = v.Opt.ToWire()
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 2, Value: w}
		i++
	}

	return wire.NewValueStruct(wire.Struct{Fields: fields[:i]}), nil
}

func _QueryParamsStruct_Read(w wire.Value) (*QueryParamsStruct, error) {
	var v QueryParamsStruct
	err := v.FromWire(w)
	return &v, err
}

func _QueryParamsOptsStruct_Read(w wire.Value) (*QueryParamsOptsStruct, error) {
	var v QueryParamsOptsStruct
	err := v.FromWire(w)
	return &v, err
}

// FromWire deserializes a Bar_ArgWithNestedQueryParams_Args struct from its Thrift-level
// representation. The Thrift-level representation may be obtained
// from a ThriftRW protocol implementation.
//
// An error is returned if we were unable to build a Bar_ArgWithNestedQueryParams_Args struct
// from the provided intermediate representation.
//
//   x, err := binaryProtocol.Decode(reader, wire.TStruct)
//   if err != nil {
//     return nil, err
//   }
//
//   var v Bar_ArgWithNestedQueryParams_Args
//   if err := v.FromWire(x); err != nil {
//     return nil, err
//   }
//   return &v, nil
func (v *Bar_ArgWithNestedQueryParams_Args) FromWire(w wire.Value) error {
	var err error

	requestIsSet := false

	for _, field := range w.GetStruct().Fields {
		switch field.ID {
		case 1:
			if field.Value.Type() == wire.TStruct {
				v.Request, err = _QueryParamsStruct_Read(field.Value)
				if err != nil {
					return err
				}
				requestIsSet = true
			}
		case 2:
			if field.Value.Type() == wire.TStruct {
				v.Opt, err = _QueryParamsOptsStruct_Read(field.Value)
				if err != nil {
					return err
				}

			}
		}
	}

	if !requestIsSet {
		return errors.New("field Request of Bar_ArgWithNestedQueryParams_Args is required")
	}

	return nil
}

// String returns a readable string representation of a Bar_ArgWithNestedQueryParams_Args
// struct.
func (v *Bar_ArgWithNestedQueryParams_Args) String() string {
	if v == nil {
		return "<nil>"
	}

	var fields [2]string
	i := 0
	fields[i] = fmt.Sprintf("Request: %v", v.Request)
	i++
	if v.Opt != nil {
		fields[i] = fmt.Sprintf("Opt: %v", v.Opt)
		i++
	}

	return fmt.Sprintf("Bar_ArgWithNestedQueryParams_Args{%v}", strings.Join(fields[:i], ", "))
}

// Equals returns true if all the fields of this Bar_ArgWithNestedQueryParams_Args match the
// provided Bar_ArgWithNestedQueryParams_Args.
//
// This function performs a deep comparison.
func (v *Bar_ArgWithNestedQueryParams_Args) Equals(rhs *Bar_ArgWithNestedQueryParams_Args) bool {
	if v == nil {
		return rhs == nil
	} else if rhs == nil {
		return false
	}
	if !v.Request.Equals(rhs.Request) {
		return false
	}
	if !((v.Opt == nil && rhs.Opt == nil) || (v.Opt != nil && rhs.Opt != nil && v.Opt.Equals(rhs.Opt))) {
		return false
	}

	return true
}

// MarshalLogObject implements zapcore.ObjectMarshaler, enabling
// fast logging of Bar_ArgWithNestedQueryParams_Args.
func (v *Bar_ArgWithNestedQueryParams_Args) MarshalLogObject(enc zapcore.ObjectEncoder) (err error) {
	if v == nil {
		return nil
	}
	err = multierr.Append(err, enc.AddObject("request", v.Request))
	if v.Opt != nil {
		err = multierr.Append(err, enc.AddObject("opt", v.Opt))
	}
	return err
}

// GetRequest returns the value of Request if it is set or its
// zero value if it is unset.
func (v *Bar_ArgWithNestedQueryParams_Args) GetRequest() (o *QueryParamsStruct) {
	if v != nil {
		o = v.Request
	}
	return
}

// IsSetRequest returns true if Request is not nil.
func (v *Bar_ArgWithNestedQueryParams_Args) IsSetRequest() bool {
	return v != nil && v.Request != nil
}

// GetOpt returns the value of Opt if it is set or its
// zero value if it is unset.
func (v *Bar_ArgWithNestedQueryParams_Args) GetOpt() (o *QueryParamsOptsStruct) {
	if v != nil && v.Opt != nil {
		return v.Opt
	}

	return
}

// IsSetOpt returns true if Opt is not nil.
func (v *Bar_ArgWithNestedQueryParams_Args) IsSetOpt() bool {
	return v != nil && v.Opt != nil
}

// MethodName returns the name of the Thrift function as specified in
// the IDL, for which this struct represent the arguments.
//
// This will always be "argWithNestedQueryParams" for this struct.
func (v *Bar_ArgWithNestedQueryParams_Args) MethodName() string {
	return "argWithNestedQueryParams"
}

// EnvelopeType returns the kind of value inside this struct.
//
// This will always be Call for this struct.
func (v *Bar_ArgWithNestedQueryParams_Args) EnvelopeType() wire.EnvelopeType {
	return wire.Call
}

// Bar_ArgWithNestedQueryParams_Helper provides functions that aid in handling the
// parameters and return values of the Bar.argWithNestedQueryParams
// function.
var Bar_ArgWithNestedQueryParams_Helper = struct {
	// Args accepts the parameters of argWithNestedQueryParams in-order and returns
	// the arguments struct for the function.
	Args func(
		request *QueryParamsStruct,
		opt *QueryParamsOptsStruct,
	) *Bar_ArgWithNestedQueryParams_Args

	// IsException returns true if the given error can be thrown
	// by argWithNestedQueryParams.
	//
	// An error can be thrown by argWithNestedQueryParams only if the
	// corresponding exception type was mentioned in the 'throws'
	// section for it in the Thrift file.
	IsException func(error) bool

	// WrapResponse returns the result struct for argWithNestedQueryParams
	// given its return value and error.
	//
	// This allows mapping values and errors returned by
	// argWithNestedQueryParams into a serializable result struct.
	// WrapResponse returns a non-nil error if the provided
	// error cannot be thrown by argWithNestedQueryParams
	//
	//   value, err := argWithNestedQueryParams(args)
	//   result, err := Bar_ArgWithNestedQueryParams_Helper.WrapResponse(value, err)
	//   if err != nil {
	//     return fmt.Errorf("unexpected error from argWithNestedQueryParams: %v", err)
	//   }
	//   serialize(result)
	WrapResponse func(*BarResponse, error) (*Bar_ArgWithNestedQueryParams_Result, error)

	// UnwrapResponse takes the result struct for argWithNestedQueryParams
	// and returns the value or error returned by it.
	//
	// The error is non-nil only if argWithNestedQueryParams threw an
	// exception.
	//
	//   result := deserialize(bytes)
	//   value, err := Bar_ArgWithNestedQueryParams_Helper.UnwrapResponse(result)
	UnwrapResponse func(*Bar_ArgWithNestedQueryParams_Result) (*BarResponse, error)
}{}

func init() {
	Bar_ArgWithNestedQueryParams_Helper.Args = func(
		request *QueryParamsStruct,
		opt *QueryParamsOptsStruct,
	) *Bar_ArgWithNestedQueryParams_Args {
		return &Bar_ArgWithNestedQueryParams_Args{
			Request: request,
			Opt:     opt,
		}
	}

	Bar_ArgWithNestedQueryParams_Helper.IsException = func(err error) bool {
		switch err.(type) {
		default:
			return false
		}
	}

	Bar_ArgWithNestedQueryParams_Helper.WrapResponse = func(success *BarResponse, err error) (*Bar_ArgWithNestedQueryParams_Result, error) {
		if err == nil {
			return &Bar_ArgWithNestedQueryParams_Result{Success: success}, nil
		}

		return nil, err
	}
	Bar_ArgWithNestedQueryParams_Helper.UnwrapResponse = func(result *Bar_ArgWithNestedQueryParams_Result) (success *BarResponse, err error) {

		if result.Success != nil {
			success = result.Success
			return
		}

		err = errors.New("expected a non-void result")
		return
	}

}

// Bar_ArgWithNestedQueryParams_Result represents the result of a Bar.argWithNestedQueryParams function call.
//
// The result of a argWithNestedQueryParams execution is sent and received over the wire as this struct.
//
// Success is set only if the function did not throw an exception.
type Bar_ArgWithNestedQueryParams_Result struct {
	// Value returned by argWithNestedQueryParams after a successful execution.
	Success *BarResponse `json:"success,omitempty"`
}

// ToWire translates a Bar_ArgWithNestedQueryParams_Result struct into a Thrift-level intermediate
// representation. This intermediate representation may be serialized
// into bytes using a ThriftRW protocol implementation.
//
// An error is returned if the struct or any of its fields failed to
// validate.
//
//   x, err := v.ToWire()
//   if err != nil {
//     return err
//   }
//
//   if err := binaryProtocol.Encode(x, writer); err != nil {
//     return err
//   }
func (v *Bar_ArgWithNestedQueryParams_Result) ToWire() (wire.Value, error) {
	var (
		fields [1]wire.Field
		i      int = 0
		w      wire.Value
		err    error
	)

	if v.Success != nil {
		w, err = v.Success.ToWire()
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 0, Value: w}
		i++
	}

	if i != 1 {
		return wire.Value{}, fmt.Errorf("Bar_ArgWithNestedQueryParams_Result should have exactly one field: got %v fields", i)
	}

	return wire.NewValueStruct(wire.Struct{Fields: fields[:i]}), nil
}

// FromWire deserializes a Bar_ArgWithNestedQueryParams_Result struct from its Thrift-level
// representation. The Thrift-level representation may be obtained
// from a ThriftRW protocol implementation.
//
// An error is returned if we were unable to build a Bar_ArgWithNestedQueryParams_Result struct
// from the provided intermediate representation.
//
//   x, err := binaryProtocol.Decode(reader, wire.TStruct)
//   if err != nil {
//     return nil, err
//   }
//
//   var v Bar_ArgWithNestedQueryParams_Result
//   if err := v.FromWire(x); err != nil {
//     return nil, err
//   }
//   return &v, nil
func (v *Bar_ArgWithNestedQueryParams_Result) FromWire(w wire.Value) error {
	var err error

	for _, field := range w.GetStruct().Fields {
		switch field.ID {
		case 0:
			if field.Value.Type() == wire.TStruct {
				v.Success, err = _BarResponse_Read(field.Value)
				if err != nil {
					return err
				}

			}
		}
	}

	count := 0
	if v.Success != nil {
		count++
	}
	if count != 1 {
		return fmt.Errorf("Bar_ArgWithNestedQueryParams_Result should have exactly one field: got %v fields", count)
	}

	return nil
}

// String returns a readable string representation of a Bar_ArgWithNestedQueryParams_Result
// struct.
func (v *Bar_ArgWithNestedQueryParams_Result) String() string {
	if v == nil {
		return "<nil>"
	}

	var fields [1]string
	i := 0
	if v.Success != nil {
		fields[i] = fmt.Sprintf("Success: %v", v.Success)
		i++
	}

	return fmt.Sprintf("Bar_ArgWithNestedQueryParams_Result{%v}", strings.Join(fields[:i], ", "))
}

// Equals returns true if all the fields of this Bar_ArgWithNestedQueryParams_Result match the
// provided Bar_ArgWithNestedQueryParams_Result.
//
// This function performs a deep comparison.
func (v *Bar_ArgWithNestedQueryParams_Result) Equals(rhs *Bar_ArgWithNestedQueryParams_Result) bool {
	if v == nil {
		return rhs == nil
	} else if rhs == nil {
		return false
	}
	if !((v.Success == nil && rhs.Success == nil) || (v.Success != nil && rhs.Success != nil && v.Success.Equals(rhs.Success))) {
		return false
	}

	return true
}

// MarshalLogObject implements zapcore.ObjectMarshaler, enabling
// fast logging of Bar_ArgWithNestedQueryParams_Result.
func (v *Bar_ArgWithNestedQueryParams_Result) MarshalLogObject(enc zapcore.ObjectEncoder) (err error) {
	if v == nil {
		return nil
	}
	if v.Success != nil {
		err = multierr.Append(err, enc.AddObject("success", v.Success))
	}
	return err
}

// GetSuccess returns the value of Success if it is set or its
// zero value if it is unset.
func (v *Bar_ArgWithNestedQueryParams_Result) GetSuccess() (o *BarResponse) {
	if v != nil && v.Success != nil {
		return v.Success
	}

	return
}

// IsSetSuccess returns true if Success is not nil.
func (v *Bar_ArgWithNestedQueryParams_Result) IsSetSuccess() bool {
	return v != nil && v.Success != nil
}

// MethodName returns the name of the Thrift function as specified in
// the IDL, for which this struct represent the result.
//
// This will always be "argWithNestedQueryParams" for this struct.
func (v *Bar_ArgWithNestedQueryParams_Result) MethodName() string {
	return "argWithNestedQueryParams"
}

// EnvelopeType returns the kind of value inside this struct.
//
// This will always be Reply for this struct.
func (v *Bar_ArgWithNestedQueryParams_Result) EnvelopeType() wire.EnvelopeType {
	return wire.Reply
}

// Bar_ArgWithParams_Args represents the arguments for the Bar.argWithParams function.
//
// The arguments for argWithParams are sent and received over the wire as this struct.
type Bar_ArgWithParams_Args struct {
	UUID   string        `json:"uuid,required"`
	Params *ParamsStruct `json:"params,omitempty"`
}

// ToWire translates a Bar_ArgWithParams_Args struct into a Thrift-level intermediate
// representation. This intermediate representation may be serialized
// into bytes using a ThriftRW protocol implementation.
//
// An error is returned if the struct or any of its fields failed to
// validate.
//
//   x, err := v.ToWire()
//   if err != nil {
//     return err
//   }
//
//   if err := binaryProtocol.Encode(x, writer); err != nil {
//     return err
//   }
func (v *Bar_ArgWithParams_Args) ToWire() (wire.Value, error) {
	var (
		fields [2]wire.Field
		i      int = 0
		w      wire.Value
		err    error
	)

	w, err = wire.NewValueString(v.UUID), error(nil)
	if err != nil {
		return w, err
	}
	fields[i] = wire.Field{ID: 1, Value: w}
	i++
	if v.Params != nil {
		w, err = v.Params.ToWire()
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 2, Value: w}
		i++
	}

	return wire.NewValueStruct(wire.Struct{Fields: fields[:i]}), nil
}

func _ParamsStruct_Read(w wire.Value) (*ParamsStruct, error) {
	var v ParamsStruct
	err := v.FromWire(w)
	return &v, err
}

// FromWire deserializes a Bar_ArgWithParams_Args struct from its Thrift-level
// representation. The Thrift-level representation may be obtained
// from a ThriftRW protocol implementation.
//
// An error is returned if we were unable to build a Bar_ArgWithParams_Args struct
// from the provided intermediate representation.
//
//   x, err := binaryProtocol.Decode(reader, wire.TStruct)
//   if err != nil {
//     return nil, err
//   }
//
//   var v Bar_ArgWithParams_Args
//   if err := v.FromWire(x); err != nil {
//     return nil, err
//   }
//   return &v, nil
func (v *Bar_ArgWithParams_Args) FromWire(w wire.Value) error {
	var err error

	uuidIsSet := false

	for _, field := range w.GetStruct().Fields {
		switch field.ID {
		case 1:
			if field.Value.Type() == wire.TBinary {
				v.UUID, err = field.Value.GetString(), error(nil)
				if err != nil {
					return err
				}
				uuidIsSet = true
			}
		case 2:
			if field.Value.Type() == wire.TStruct {
				v.Params, err = _ParamsStruct_Read(field.Value)
				if err != nil {
					return err
				}

			}
		}
	}

	if !uuidIsSet {
		return errors.New("field UUID of Bar_ArgWithParams_Args is required")
	}

	return nil
}

// String returns a readable string representation of a Bar_ArgWithParams_Args
// struct.
func (v *Bar_ArgWithParams_Args) String() string {
	if v == nil {
		return "<nil>"
	}

	var fields [2]string
	i := 0
	fields[i] = fmt.Sprintf("UUID: %v", v.UUID)
	i++
	if v.Params != nil {
		fields[i] = fmt.Sprintf("Params: %v", v.Params)
		i++
	}

	return fmt.Sprintf("Bar_ArgWithParams_Args{%v}", strings.Join(fields[:i], ", "))
}

// Equals returns true if all the fields of this Bar_ArgWithParams_Args match the
// provided Bar_ArgWithParams_Args.
//
// This function performs a deep comparison.
func (v *Bar_ArgWithParams_Args) Equals(rhs *Bar_ArgWithParams_Args) bool {
	if v == nil {
		return rhs == nil
	} else if rhs == nil {
		return false
	}
	if !(v.UUID == rhs.UUID) {
		return false
	}
	if !((v.Params == nil && rhs.Params == nil) || (v.Params != nil && rhs.Params != nil && v.Params.Equals(rhs.Params))) {
		return false
	}

	return true
}

// MarshalLogObject implements zapcore.ObjectMarshaler, enabling
// fast logging of Bar_ArgWithParams_Args.
func (v *Bar_ArgWithParams_Args) MarshalLogObject(enc zapcore.ObjectEncoder) (err error) {
	if v == nil {
		return nil
	}
	enc.AddString("uuid", v.UUID)
	if v.Params != nil {
		err = multierr.Append(err, enc.AddObject("params", v.Params))
	}
	return err
}

// GetUUID returns the value of UUID if it is set or its
// zero value if it is unset.
func (v *Bar_ArgWithParams_Args) GetUUID() (o string) {
	if v != nil {
		o = v.UUID
	}
	return
}

// GetParams returns the value of Params if it is set or its
// zero value if it is unset.
func (v *Bar_ArgWithParams_Args) GetParams() (o *ParamsStruct) {
	if v != nil && v.Params != nil {
		return v.Params
	}

	return
}

// IsSetParams returns true if Params is not nil.
func (v *Bar_ArgWithParams_Args) IsSetParams() bool {
	return v != nil && v.Params != nil
}

// MethodName returns the name of the Thrift function as specified in
// the IDL, for which this struct represent the arguments.
//
// This will always be "argWithParams" for this struct.
func (v *Bar_ArgWithParams_Args) MethodName() string {
	return "argWithParams"
}

// EnvelopeType returns the kind of value inside this struct.
//
// This will always be Call for this struct.
func (v *Bar_ArgWithParams_Args) EnvelopeType() wire.EnvelopeType {
	return wire.Call
}

// Bar_ArgWithParams_Helper provides functions that aid in handling the
// parameters and return values of the Bar.argWithParams
// function.
var Bar_ArgWithParams_Helper = struct {
	// Args accepts the parameters of argWithParams in-order and returns
	// the arguments struct for the function.
	Args func(
		uuid string,
		params *ParamsStruct,
	) *Bar_ArgWithParams_Args

	// IsException returns true if the given error can be thrown
	// by argWithParams.
	//
	// An error can be thrown by argWithParams only if the
	// corresponding exception type was mentioned in the 'throws'
	// section for it in the Thrift file.
	IsException func(error) bool

	// WrapResponse returns the result struct for argWithParams
	// given its return value and error.
	//
	// This allows mapping values and errors returned by
	// argWithParams into a serializable result struct.
	// WrapResponse returns a non-nil error if the provided
	// error cannot be thrown by argWithParams
	//
	//   value, err := argWithParams(args)
	//   result, err := Bar_ArgWithParams_Helper.WrapResponse(value, err)
	//   if err != nil {
	//     return fmt.Errorf("unexpected error from argWithParams: %v", err)
	//   }
	//   serialize(result)
	WrapResponse func(*BarResponse, error) (*Bar_ArgWithParams_Result, error)

	// UnwrapResponse takes the result struct for argWithParams
	// and returns the value or error returned by it.
	//
	// The error is non-nil only if argWithParams threw an
	// exception.
	//
	//   result := deserialize(bytes)
	//   value, err := Bar_ArgWithParams_Helper.UnwrapResponse(result)
	UnwrapResponse func(*Bar_ArgWithParams_Result) (*BarResponse, error)
}{}

func init() {
	Bar_ArgWithParams_Helper.Args = func(
		uuid string,
		params *ParamsStruct,
	) *Bar_ArgWithParams_Args {
		return &Bar_ArgWithParams_Args{
			UUID:   uuid,
			Params: params,
		}
	}

	Bar_ArgWithParams_Helper.IsException = func(err error) bool {
		switch err.(type) {
		default:
			return false
		}
	}

	Bar_ArgWithParams_Helper.WrapResponse = func(success *BarResponse, err error) (*Bar_ArgWithParams_Result, error) {
		if err == nil {
			return &Bar_ArgWithParams_Result{Success: success}, nil
		}

		return nil, err
	}
	Bar_ArgWithParams_Helper.UnwrapResponse = func(result *Bar_ArgWithParams_Result) (success *BarResponse, err error) {

		if result.Success != nil {
			success = result.Success
			return
		}

		err = errors.New("expected a non-void result")
		return
	}

}

// Bar_ArgWithParams_Result represents the result of a Bar.argWithParams function call.
//
// The result of a argWithParams execution is sent and received over the wire as this struct.
//
// Success is set only if the function did not throw an exception.
type Bar_ArgWithParams_Result struct {
	// Value returned by argWithParams after a successful execution.
	Success *BarResponse `json:"success,omitempty"`
}

// ToWire translates a Bar_ArgWithParams_Result struct into a Thrift-level intermediate
// representation. This intermediate representation may be serialized
// into bytes using a ThriftRW protocol implementation.
//
// An error is returned if the struct or any of its fields failed to
// validate.
//
//   x, err := v.ToWire()
//   if err != nil {
//     return err
//   }
//
//   if err := binaryProtocol.Encode(x, writer); err != nil {
//     return err
//   }
func (v *Bar_ArgWithParams_Result) ToWire() (wire.Value, error) {
	var (
		fields [1]wire.Field
		i      int = 0
		w      wire.Value
		err    error
	)

	if v.Success != nil {
		w, err = v.Success.ToWire()
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 0, Value: w}
		i++
	}

	if i != 1 {
		return wire.Value{}, fmt.Errorf("Bar_ArgWithParams_Result should have exactly one field: got %v fields", i)
	}

	return wire.NewValueStruct(wire.Struct{Fields: fields[:i]}), nil
}

// FromWire deserializes a Bar_ArgWithParams_Result struct from its Thrift-level
// representation. The Thrift-level representation may be obtained
// from a ThriftRW protocol implementation.
//
// An error is returned if we were unable to build a Bar_ArgWithParams_Result struct
// from the provided intermediate representation.
//
//   x, err := binaryProtocol.Decode(reader, wire.TStruct)
//   if err != nil {
//     return nil, err
//   }
//
//   var v Bar_ArgWithParams_Result
//   if err := v.FromWire(x); err != nil {
//     return nil, err
//   }
//   return &v, nil
func (v *Bar_ArgWithParams_Result) FromWire(w wire.Value) error {
	var err error

	for _, field := range w.GetStruct().Fields {
		switch field.ID {
		case 0:
			if field.Value.Type() == wire.TStruct {
				v.Success, err = _BarResponse_Read(field.Value)
				if err != nil {
					return err
				}

			}
		}
	}

	count := 0
	if v.Success != nil {
		count++
	}
	if count != 1 {
		return fmt.Errorf("Bar_ArgWithParams_Result should have exactly one field: got %v fields", count)
	}

	return nil
}

// String returns a readable string representation of a Bar_ArgWithParams_Result
// struct.
func (v *Bar_ArgWithParams_Result) String() string {
	if v == nil {
		return "<nil>"
	}

	var fields [1]string
	i := 0
	if v.Success != nil {
		fields[i] = fmt.Sprintf("Success: %v", v.Success)
		i++
	}

	return fmt.Sprintf("Bar_ArgWithParams_Result{%v}", strings.Join(fields[:i], ", "))
}

// Equals returns true if all the fields of this Bar_ArgWithParams_Result match the
// provided Bar_ArgWithParams_Result.
//
// This function performs a deep comparison.
func (v *Bar_ArgWithParams_Result) Equals(rhs *Bar_ArgWithParams_Result) bool {
	if v == nil {
		return rhs == nil
	} else if rhs == nil {
		return false
	}
	if !((v.Success == nil && rhs.Success == nil) || (v.Success != nil && rhs.Success != nil && v.Success.Equals(rhs.Success))) {
		return false
	}

	return true
}

// MarshalLogObject implements zapcore.ObjectMarshaler, enabling
// fast logging of Bar_ArgWithParams_Result.
func (v *Bar_ArgWithParams_Result) MarshalLogObject(enc zapcore.ObjectEncoder) (err error) {
	if v == nil {
		return nil
	}
	if v.Success != nil {
		err = multierr.Append(err, enc.AddObject("success", v.Success))
	}
	return err
}

// GetSuccess returns the value of Success if it is set or its
// zero value if it is unset.
func (v *Bar_ArgWithParams_Result) GetSuccess() (o *BarResponse) {
	if v != nil && v.Success != nil {
		return v.Success
	}

	return
}

// IsSetSuccess returns true if Success is not nil.
func (v *Bar_ArgWithParams_Result) IsSetSuccess() bool {
	return v != nil && v.Success != nil
}

// MethodName returns the name of the Thrift function as specified in
// the IDL, for which this struct represent the result.
//
// This will always be "argWithParams" for this struct.
func (v *Bar_ArgWithParams_Result) MethodName() string {
	return "argWithParams"
}

// EnvelopeType returns the kind of value inside this struct.
//
// This will always be Reply for this struct.
func (v *Bar_ArgWithParams_Result) EnvelopeType() wire.EnvelopeType {
	return wire.Reply
}

// Bar_ArgWithParamsAndDuplicateFields_Args represents the arguments for the Bar.argWithParamsAndDuplicateFields function.
//
// The arguments for argWithParamsAndDuplicateFields are sent and received over the wire as this struct.
type Bar_ArgWithParamsAndDuplicateFields_Args struct {
	Request    *RequestWithDuplicateType `json:"request,required"`
	EntityUUID string                    `json:"entityUUID,required"`
}

// ToWire translates a Bar_ArgWithParamsAndDuplicateFields_Args struct into a Thrift-level intermediate
// representation. This intermediate representation may be serialized
// into bytes using a ThriftRW protocol implementation.
//
// An error is returned if the struct or any of its fields failed to
// validate.
//
//   x, err := v.ToWire()
//   if err != nil {
//     return err
//   }
//
//   if err := binaryProtocol.Encode(x, writer); err != nil {
//     return err
//   }
func (v *Bar_ArgWithParamsAndDuplicateFields_Args) ToWire() (wire.Value, error) {
	var (
		fields [2]wire.Field
		i      int = 0
		w      wire.Value
		err    error
	)

	if v.Request == nil {
		return w, errors.New("field Request of Bar_ArgWithParamsAndDuplicateFields_Args is required")
	}
	w, err = v.Request.ToWire()
	if err != nil {
		return w, err
	}
	fields[i] = wire.Field{ID: 1, Value: w}
	i++

	w, err = wire.NewValueString(v.EntityUUID), error(nil)
	if err != nil {
		return w, err
	}
	fields[i] = wire.Field{ID: 2, Value: w}
	i++

	return wire.NewValueStruct(wire.Struct{Fields: fields[:i]}), nil
}

func _RequestWithDuplicateType_Read(w wire.Value) (*RequestWithDuplicateType, error) {
	var v RequestWithDuplicateType
	err := v.FromWire(w)
	return &v, err
}

// FromWire deserializes a Bar_ArgWithParamsAndDuplicateFields_Args struct from its Thrift-level
// representation. The Thrift-level representation may be obtained
// from a ThriftRW protocol implementation.
//
// An error is returned if we were unable to build a Bar_ArgWithParamsAndDuplicateFields_Args struct
// from the provided intermediate representation.
//
//   x, err := binaryProtocol.Decode(reader, wire.TStruct)
//   if err != nil {
//     return nil, err
//   }
//
//   var v Bar_ArgWithParamsAndDuplicateFields_Args
//   if err := v.FromWire(x); err != nil {
//     return nil, err
//   }
//   return &v, nil
func (v *Bar_ArgWithParamsAndDuplicateFields_Args) FromWire(w wire.Value) error {
	var err error

	requestIsSet := false
	entityUUIDIsSet := false

	for _, field := range w.GetStruct().Fields {
		switch field.ID {
		case 1:
			if field.Value.Type() == wire.TStruct {
				v.Request, err = _RequestWithDuplicateType_Read(field.Value)
				if err != nil {
					return err
				}
				requestIsSet = true
			}
		case 2:
			if field.Value.Type() == wire.TBinary {
				v.EntityUUID, err = field.Value.GetString(), error(nil)
				if err != nil {
					return err
				}
				entityUUIDIsSet = true
			}
		}
	}

	if !requestIsSet {
		return errors.New("field Request of Bar_ArgWithParamsAndDuplicateFields_Args is required")
	}

	if !entityUUIDIsSet {
		return errors.New("field EntityUUID of Bar_ArgWithParamsAndDuplicateFields_Args is required")
	}

	return nil
}

// String returns a readable string representation of a Bar_ArgWithParamsAndDuplicateFields_Args
// struct.
func (v *Bar_ArgWithParamsAndDuplicateFields_Args) String() string {
	if v == nil {
		return "<nil>"
	}

	var fields [2]string
	i := 0
	fields[i] = fmt.Sprintf("Request: %v", v.Request)
	i++
	fields[i] = fmt.Sprintf("EntityUUID: %v", v.EntityUUID)
	i++

	return fmt.Sprintf("Bar_ArgWithParamsAndDuplicateFields_Args{%v}", strings.Join(fields[:i], ", "))
}

// Equals returns true if all the fields of this Bar_ArgWithParamsAndDuplicateFields_Args match the
// provided Bar_ArgWithParamsAndDuplicateFields_Args.
//
// This function performs a deep comparison.
func (v *Bar_ArgWithParamsAndDuplicateFields_Args) Equals(rhs *Bar_ArgWithParamsAndDuplicateFields_Args) bool {
	if v == nil {
		return rhs == nil
	} else if rhs == nil {
		return false
	}
	if !v.Request.Equals(rhs.Request) {
		return false
	}
	if !(v.EntityUUID == rhs.EntityUUID) {
		return false
	}

	return true
}

// MarshalLogObject implements zapcore.ObjectMarshaler, enabling
// fast logging of Bar_ArgWithParamsAndDuplicateFields_Args.
func (v *Bar_ArgWithParamsAndDuplicateFields_Args) MarshalLogObject(enc zapcore.ObjectEncoder) (err error) {
	if v == nil {
		return nil
	}
	err = multierr.Append(err, enc.AddObject("request", v.Request))
	enc.AddString("entityUUID", v.EntityUUID)
	return err
}

// GetRequest returns the value of Request if it is set or its
// zero value if it is unset.
func (v *Bar_ArgWithParamsAndDuplicateFields_Args) GetRequest() (o *RequestWithDuplicateType) {
	if v != nil {
		o = v.Request
	}
	return
}

// IsSetRequest returns true if Request is not nil.
func (v *Bar_ArgWithParamsAndDuplicateFields_Args) IsSetRequest() bool {
	return v != nil && v.Request != nil
}

// GetEntityUUID returns the value of EntityUUID if it is set or its
// zero value if it is unset.
func (v *Bar_ArgWithParamsAndDuplicateFields_Args) GetEntityUUID() (o string) {
	if v != nil {
		o = v.EntityUUID
	}
	return
}

// MethodName returns the name of the Thrift function as specified in
// the IDL, for which this struct represent the arguments.
//
// This will always be "argWithParamsAndDuplicateFields" for this struct.
func (v *Bar_ArgWithParamsAndDuplicateFields_Args) MethodName() string {
	return "argWithParamsAndDuplicateFields"
}

// EnvelopeType returns the kind of value inside this struct.
//
// This will always be Call for this struct.
func (v *Bar_ArgWithParamsAndDuplicateFields_Args) EnvelopeType() wire.EnvelopeType {
	return wire.Call
}

// Bar_ArgWithParamsAndDuplicateFields_Helper provides functions that aid in handling the
// parameters and return values of the Bar.argWithParamsAndDuplicateFields
// function.
var Bar_ArgWithParamsAndDuplicateFields_Helper = struct {
	// Args accepts the parameters of argWithParamsAndDuplicateFields in-order and returns
	// the arguments struct for the function.
	Args func(
		request *RequestWithDuplicateType,
		entityUUID string,
	) *Bar_ArgWithParamsAndDuplicateFields_Args

	// IsException returns true if the given error can be thrown
	// by argWithParamsAndDuplicateFields.
	//
	// An error can be thrown by argWithParamsAndDuplicateFields only if the
	// corresponding exception type was mentioned in the 'throws'
	// section for it in the Thrift file.
	IsException func(error) bool

	// WrapResponse returns the result struct for argWithParamsAndDuplicateFields
	// given its return value and error.
	//
	// This allows mapping values and errors returned by
	// argWithParamsAndDuplicateFields into a serializable result struct.
	// WrapResponse returns a non-nil error if the provided
	// error cannot be thrown by argWithParamsAndDuplicateFields
	//
	//   value, err := argWithParamsAndDuplicateFields(args)
	//   result, err := Bar_ArgWithParamsAndDuplicateFields_Helper.WrapResponse(value, err)
	//   if err != nil {
	//     return fmt.Errorf("unexpected error from argWithParamsAndDuplicateFields: %v", err)
	//   }
	//   serialize(result)
	WrapResponse func(*BarResponse, error) (*Bar_ArgWithParamsAndDuplicateFields_Result, error)

	// UnwrapResponse takes the result struct for argWithParamsAndDuplicateFields
	// and returns the value or error returned by it.
	//
	// The error is non-nil only if argWithParamsAndDuplicateFields threw an
	// exception.
	//
	//   result := deserialize(bytes)
	//   value, err := Bar_ArgWithParamsAndDuplicateFields_Helper.UnwrapResponse(result)
	UnwrapResponse func(*Bar_ArgWithParamsAndDuplicateFields_Result) (*BarResponse, error)
}{}

func init() {
	Bar_ArgWithParamsAndDuplicateFields_Helper.Args = func(
		request *RequestWithDuplicateType,
		entityUUID string,
	) *Bar_ArgWithParamsAndDuplicateFields_Args {
		return &Bar_ArgWithParamsAndDuplicateFields_Args{
			Request:    request,
			EntityUUID: entityUUID,
		}
	}

	Bar_ArgWithParamsAndDuplicateFields_Helper.IsException = func(err error) bool {
		switch err.(type) {
		default:
			return false
		}
	}

	Bar_ArgWithParamsAndDuplicateFields_Helper.WrapResponse = func(success *BarResponse, err error) (*Bar_ArgWithParamsAndDuplicateFields_Result, error) {
		if err == nil {
			return &Bar_ArgWithParamsAndDuplicateFields_Result{Success: success}, nil
		}

		return nil, err
	}
	Bar_ArgWithParamsAndDuplicateFields_Helper.UnwrapResponse = func(result *Bar_ArgWithParamsAndDuplicateFields_Result) (success *BarResponse, err error) {

		if result.Success != nil {
			success = result.Success
			return
		}

		err = errors.New("expected a non-void result")
		return
	}

}

// Bar_ArgWithParamsAndDuplicateFields_Result represents the result of a Bar.argWithParamsAndDuplicateFields function call.
//
// The result of a argWithParamsAndDuplicateFields execution is sent and received over the wire as this struct.
//
// Success is set only if the function did not throw an exception.
type Bar_ArgWithParamsAndDuplicateFields_Result struct {
	// Value returned by argWithParamsAndDuplicateFields after a successful execution.
	Success *BarResponse `json:"success,omitempty"`
}

// ToWire translates a Bar_ArgWithParamsAndDuplicateFields_Result struct into a Thrift-level intermediate
// representation. This intermediate representation may be serialized
// into bytes using a ThriftRW protocol implementation.
//
// An error is returned if the struct or any of its fields failed to
// validate.
//
//   x, err := v.ToWire()
//   if err != nil {
//     return err
//   }
//
//   if err := binaryProtocol.Encode(x, writer); err != nil {
//     return err
//   }
func (v *Bar_ArgWithParamsAndDuplicateFields_Result) ToWire() (wire.Value, error) {
	var (
		fields [1]wire.Field
		i      int = 0
		w      wire.Value
		err    error
	)

	if v.Success != nil {
		w, err = v.Success.ToWire()
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 0, Value: w}
		i++
	}

	if i != 1 {
		return wire.Value{}, fmt.Errorf("Bar_ArgWithParamsAndDuplicateFields_Result should have exactly one field: got %v fields", i)
	}

	return wire.NewValueStruct(wire.Struct{Fields: fields[:i]}), nil
}

// FromWire deserializes a Bar_ArgWithParamsAndDuplicateFields_Result struct from its Thrift-level
// representation. The Thrift-level representation may be obtained
// from a ThriftRW protocol implementation.
//
// An error is returned if we were unable to build a Bar_ArgWithParamsAndDuplicateFields_Result struct
// from the provided intermediate representation.
//
//   x, err := binaryProtocol.Decode(reader, wire.TStruct)
//   if err != nil {
//     return nil, err
//   }
//
//   var v Bar_ArgWithParamsAndDuplicateFields_Result
//   if err := v.FromWire(x); err != nil {
//     return nil, err
//   }
//   return &v, nil
func (v *Bar_ArgWithParamsAndDuplicateFields_Result) FromWire(w wire.Value) error {
	var err error

	for _, field := range w.GetStruct().Fields {
		switch field.ID {
		case 0:
			if field.Value.Type() == wire.TStruct {
				v.Success, err = _BarResponse_Read(field.Value)
				if err != nil {
					return err
				}

			}
		}
	}

	count := 0
	if v.Success != nil {
		count++
	}
	if count != 1 {
		return fmt.Errorf("Bar_ArgWithParamsAndDuplicateFields_Result should have exactly one field: got %v fields", count)
	}

	return nil
}

// String returns a readable string representation of a Bar_ArgWithParamsAndDuplicateFields_Result
// struct.
func (v *Bar_ArgWithParamsAndDuplicateFields_Result) String() string {
	if v == nil {
		return "<nil>"
	}

	var fields [1]string
	i := 0
	if v.Success != nil {
		fields[i] = fmt.Sprintf("Success: %v", v.Success)
		i++
	}

	return fmt.Sprintf("Bar_ArgWithParamsAndDuplicateFields_Result{%v}", strings.Join(fields[:i], ", "))
}

// Equals returns true if all the fields of this Bar_ArgWithParamsAndDuplicateFields_Result match the
// provided Bar_ArgWithParamsAndDuplicateFields_Result.
//
// This function performs a deep comparison.
func (v *Bar_ArgWithParamsAndDuplicateFields_Result) Equals(rhs *Bar_ArgWithParamsAndDuplicateFields_Result) bool {
	if v == nil {
		return rhs == nil
	} else if rhs == nil {
		return false
	}
	if !((v.Success == nil && rhs.Success == nil) || (v.Success != nil && rhs.Success != nil && v.Success.Equals(rhs.Success))) {
		return false
	}

	return true
}

// MarshalLogObject implements zapcore.ObjectMarshaler, enabling
// fast logging of Bar_ArgWithParamsAndDuplicateFields_Result.
func (v *Bar_ArgWithParamsAndDuplicateFields_Result) MarshalLogObject(enc zapcore.ObjectEncoder) (err error) {
	if v == nil {
		return nil
	}
	if v.Success != nil {
		err = multierr.Append(err, enc.AddObject("success", v.Success))
	}
	return err
}

// GetSuccess returns the value of Success if it is set or its
// zero value if it is unset.
func (v *Bar_ArgWithParamsAndDuplicateFields_Result) GetSuccess() (o *BarResponse) {
	if v != nil && v.Success != nil {
		return v.Success
	}

	return
}

// IsSetSuccess returns true if Success is not nil.
func (v *Bar_ArgWithParamsAndDuplicateFields_Result) IsSetSuccess() bool {
	return v != nil && v.Success != nil
}

// MethodName returns the name of the Thrift function as specified in
// the IDL, for which this struct represent the result.
//
// This will always be "argWithParamsAndDuplicateFields" for this struct.
func (v *Bar_ArgWithParamsAndDuplicateFields_Result) MethodName() string {
	return "argWithParamsAndDuplicateFields"
}

// EnvelopeType returns the kind of value inside this struct.
//
// This will always be Reply for this struct.
func (v *Bar_ArgWithParamsAndDuplicateFields_Result) EnvelopeType() wire.EnvelopeType {
	return wire.Reply
}

// Bar_ArgWithQueryHeader_Args represents the arguments for the Bar.argWithQueryHeader function.
//
// The arguments for argWithQueryHeader are sent and received over the wire as this struct.
type Bar_ArgWithQueryHeader_Args struct {
	UserUUID *string `json:"userUUID,omitempty"`
}

// ToWire translates a Bar_ArgWithQueryHeader_Args struct into a Thrift-level intermediate
// representation. This intermediate representation may be serialized
// into bytes using a ThriftRW protocol implementation.
//
// An error is returned if the struct or any of its fields failed to
// validate.
//
//   x, err := v.ToWire()
//   if err != nil {
//     return err
//   }
//
//   if err := binaryProtocol.Encode(x, writer); err != nil {
//     return err
//   }
func (v *Bar_ArgWithQueryHeader_Args) ToWire() (wire.Value, error) {
	var (
		fields [1]wire.Field
		i      int = 0
		w      wire.Value
		err    error
	)

	if v.UserUUID != nil {
		w, err = wire.NewValueString(*(v.UserUUID)), error(nil)
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 1, Value: w}
		i++
	}

	return wire.NewValueStruct(wire.Struct{Fields: fields[:i]}), nil
}

// FromWire deserializes a Bar_ArgWithQueryHeader_Args struct from its Thrift-level
// representation. The Thrift-level representation may be obtained
// from a ThriftRW protocol implementation.
//
// An error is returned if we were unable to build a Bar_ArgWithQueryHeader_Args struct
// from the provided intermediate representation.
//
//   x, err := binaryProtocol.Decode(reader, wire.TStruct)
//   if err != nil {
//     return nil, err
//   }
//
//   var v Bar_ArgWithQueryHeader_Args
//   if err := v.FromWire(x); err != nil {
//     return nil, err
//   }
//   return &v, nil
func (v *Bar_ArgWithQueryHeader_Args) FromWire(w wire.Value) error {
	var err error

	for _, field := range w.GetStruct().Fields {
		switch field.ID {
		case 1:
			if field.Value.Type() == wire.TBinary {
				var x string
				x, err = field.Value.GetString(), error(nil)
				v.UserUUID = &x
				if err != nil {
					return err
				}

			}
		}
	}

	return nil
}

// String returns a readable string representation of a Bar_ArgWithQueryHeader_Args
// struct.
func (v *Bar_ArgWithQueryHeader_Args) String() string {
	if v == nil {
		return "<nil>"
	}

	var fields [1]string
	i := 0
	if v.UserUUID != nil {
		fields[i] = fmt.Sprintf("UserUUID: %v", *(v.UserUUID))
		i++
	}

	return fmt.Sprintf("Bar_ArgWithQueryHeader_Args{%v}", strings.Join(fields[:i], ", "))
}

// Equals returns true if all the fields of this Bar_ArgWithQueryHeader_Args match the
// provided Bar_ArgWithQueryHeader_Args.
//
// This function performs a deep comparison.
func (v *Bar_ArgWithQueryHeader_Args) Equals(rhs *Bar_ArgWithQueryHeader_Args) bool {
	if v == nil {
		return rhs == nil
	} else if rhs == nil {
		return false
	}
	if !_String_EqualsPtr(v.UserUUID, rhs.UserUUID) {
		return false
	}

	return true
}

// MarshalLogObject implements zapcore.ObjectMarshaler, enabling
// fast logging of Bar_ArgWithQueryHeader_Args.
func (v *Bar_ArgWithQueryHeader_Args) MarshalLogObject(enc zapcore.ObjectEncoder) (err error) {
	if v == nil {
		return nil
	}
	if v.UserUUID != nil {
		enc.AddString("userUUID", *v.UserUUID)
	}
	return err
}

// GetUserUUID returns the value of UserUUID if it is set or its
// zero value if it is unset.
func (v *Bar_ArgWithQueryHeader_Args) GetUserUUID() (o string) {
	if v != nil && v.UserUUID != nil {
		return *v.UserUUID
	}

	return
}

// IsSetUserUUID returns true if UserUUID is not nil.
func (v *Bar_ArgWithQueryHeader_Args) IsSetUserUUID() bool {
	return v != nil && v.UserUUID != nil
}

// MethodName returns the name of the Thrift function as specified in
// the IDL, for which this struct represent the arguments.
//
// This will always be "argWithQueryHeader" for this struct.
func (v *Bar_ArgWithQueryHeader_Args) MethodName() string {
	return "argWithQueryHeader"
}

// EnvelopeType returns the kind of value inside this struct.
//
// This will always be Call for this struct.
func (v *Bar_ArgWithQueryHeader_Args) EnvelopeType() wire.EnvelopeType {
	return wire.Call
}

// Bar_ArgWithQueryHeader_Helper provides functions that aid in handling the
// parameters and return values of the Bar.argWithQueryHeader
// function.
var Bar_ArgWithQueryHeader_Helper = struct {
	// Args accepts the parameters of argWithQueryHeader in-order and returns
	// the arguments struct for the function.
	Args func(
		userUUID *string,
	) *Bar_ArgWithQueryHeader_Args

	// IsException returns true if the given error can be thrown
	// by argWithQueryHeader.
	//
	// An error can be thrown by argWithQueryHeader only if the
	// corresponding exception type was mentioned in the 'throws'
	// section for it in the Thrift file.
	IsException func(error) bool

	// WrapResponse returns the result struct for argWithQueryHeader
	// given its return value and error.
	//
	// This allows mapping values and errors returned by
	// argWithQueryHeader into a serializable result struct.
	// WrapResponse returns a non-nil error if the provided
	// error cannot be thrown by argWithQueryHeader
	//
	//   value, err := argWithQueryHeader(args)
	//   result, err := Bar_ArgWithQueryHeader_Helper.WrapResponse(value, err)
	//   if err != nil {
	//     return fmt.Errorf("unexpected error from argWithQueryHeader: %v", err)
	//   }
	//   serialize(result)
	WrapResponse func(*BarResponse, error) (*Bar_ArgWithQueryHeader_Result, error)

	// UnwrapResponse takes the result struct for argWithQueryHeader
	// and returns the value or error returned by it.
	//
	// The error is non-nil only if argWithQueryHeader threw an
	// exception.
	//
	//   result := deserialize(bytes)
	//   value, err := Bar_ArgWithQueryHeader_Helper.UnwrapResponse(result)
	UnwrapResponse func(*Bar_ArgWithQueryHeader_Result) (*BarResponse, error)
}{}

func init() {
	Bar_ArgWithQueryHeader_Helper.Args = func(
		userUUID *string,
	) *Bar_ArgWithQueryHeader_Args {
		return &Bar_ArgWithQueryHeader_Args{
			UserUUID: userUUID,
		}
	}

	Bar_ArgWithQueryHeader_Helper.IsException = func(err error) bool {
		switch err.(type) {
		default:
			return false
		}
	}

	Bar_ArgWithQueryHeader_Helper.WrapResponse = func(success *BarResponse, err error) (*Bar_ArgWithQueryHeader_Result, error) {
		if err == nil {
			return &Bar_ArgWithQueryHeader_Result{Success: success}, nil
		}

		return nil, err
	}
	Bar_ArgWithQueryHeader_Helper.UnwrapResponse = func(result *Bar_ArgWithQueryHeader_Result) (success *BarResponse, err error) {

		if result.Success != nil {
			success = result.Success
			return
		}

		err = errors.New("expected a non-void result")
		return
	}

}

// Bar_ArgWithQueryHeader_Result represents the result of a Bar.argWithQueryHeader function call.
//
// The result of a argWithQueryHeader execution is sent and received over the wire as this struct.
//
// Success is set only if the function did not throw an exception.
type Bar_ArgWithQueryHeader_Result struct {
	// Value returned by argWithQueryHeader after a successful execution.
	Success *BarResponse `json:"success,omitempty"`
}

// ToWire translates a Bar_ArgWithQueryHeader_Result struct into a Thrift-level intermediate
// representation. This intermediate representation may be serialized
// into bytes using a ThriftRW protocol implementation.
//
// An error is returned if the struct or any of its fields failed to
// validate.
//
//   x, err := v.ToWire()
//   if err != nil {
//     return err
//   }
//
//   if err := binaryProtocol.Encode(x, writer); err != nil {
//     return err
//   }
func (v *Bar_ArgWithQueryHeader_Result) ToWire() (wire.Value, error) {
	var (
		fields [1]wire.Field
		i      int = 0
		w      wire.Value
		err    error
	)

	if v.Success != nil {
		w, err = v.Success.ToWire()
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 0, Value: w}
		i++
	}

	if i != 1 {
		return wire.Value{}, fmt.Errorf("Bar_ArgWithQueryHeader_Result should have exactly one field: got %v fields", i)
	}

	return wire.NewValueStruct(wire.Struct{Fields: fields[:i]}), nil
}

// FromWire deserializes a Bar_ArgWithQueryHeader_Result struct from its Thrift-level
// representation. The Thrift-level representation may be obtained
// from a ThriftRW protocol implementation.
//
// An error is returned if we were unable to build a Bar_ArgWithQueryHeader_Result struct
// from the provided intermediate representation.
//
//   x, err := binaryProtocol.Decode(reader, wire.TStruct)
//   if err != nil {
//     return nil, err
//   }
//
//   var v Bar_ArgWithQueryHeader_Result
//   if err := v.FromWire(x); err != nil {
//     return nil, err
//   }
//   return &v, nil
func (v *Bar_ArgWithQueryHeader_Result) FromWire(w wire.Value) error {
	var err error

	for _, field := range w.GetStruct().Fields {
		switch field.ID {
		case 0:
			if field.Value.Type() == wire.TStruct {
				v.Success, err = _BarResponse_Read(field.Value)
				if err != nil {
					return err
				}

			}
		}
	}

	count := 0
	if v.Success != nil {
		count++
	}
	if count != 1 {
		return fmt.Errorf("Bar_ArgWithQueryHeader_Result should have exactly one field: got %v fields", count)
	}

	return nil
}

// String returns a readable string representation of a Bar_ArgWithQueryHeader_Result
// struct.
func (v *Bar_ArgWithQueryHeader_Result) String() string {
	if v == nil {
		return "<nil>"
	}

	var fields [1]string
	i := 0
	if v.Success != nil {
		fields[i] = fmt.Sprintf("Success: %v", v.Success)
		i++
	}

	return fmt.Sprintf("Bar_ArgWithQueryHeader_Result{%v}", strings.Join(fields[:i], ", "))
}

// Equals returns true if all the fields of this Bar_ArgWithQueryHeader_Result match the
// provided Bar_ArgWithQueryHeader_Result.
//
// This function performs a deep comparison.
func (v *Bar_ArgWithQueryHeader_Result) Equals(rhs *Bar_ArgWithQueryHeader_Result) bool {
	if v == nil {
		return rhs == nil
	} else if rhs == nil {
		return false
	}
	if !((v.Success == nil && rhs.Success == nil) || (v.Success != nil && rhs.Success != nil && v.Success.Equals(rhs.Success))) {
		return false
	}

	return true
}

// MarshalLogObject implements zapcore.ObjectMarshaler, enabling
// fast logging of Bar_ArgWithQueryHeader_Result.
func (v *Bar_ArgWithQueryHeader_Result) MarshalLogObject(enc zapcore.ObjectEncoder) (err error) {
	if v == nil {
		return nil
	}
	if v.Success != nil {
		err = multierr.Append(err, enc.AddObject("success", v.Success))
	}
	return err
}

// GetSuccess returns the value of Success if it is set or its
// zero value if it is unset.
func (v *Bar_ArgWithQueryHeader_Result) GetSuccess() (o *BarResponse) {
	if v != nil && v.Success != nil {
		return v.Success
	}

	return
}

// IsSetSuccess returns true if Success is not nil.
func (v *Bar_ArgWithQueryHeader_Result) IsSetSuccess() bool {
	return v != nil && v.Success != nil
}

// MethodName returns the name of the Thrift function as specified in
// the IDL, for which this struct represent the result.
//
// This will always be "argWithQueryHeader" for this struct.
func (v *Bar_ArgWithQueryHeader_Result) MethodName() string {
	return "argWithQueryHeader"
}

// EnvelopeType returns the kind of value inside this struct.
//
// This will always be Reply for this struct.
func (v *Bar_ArgWithQueryHeader_Result) EnvelopeType() wire.EnvelopeType {
	return wire.Reply
}

// Bar_ArgWithQueryParams_Args represents the arguments for the Bar.argWithQueryParams function.
//
// The arguments for argWithQueryParams are sent and received over the wire as this struct.
type Bar_ArgWithQueryParams_Args struct {
	Name     string   `json:"name,required"`
	UserUUID *string  `json:"userUUID,omitempty"`
	Foo      []string `json:"foo,omitempty"`
	Bar      []int8   `json:"bar,required"`
}

type _List_Byte_ValueList []int8

func (v _List_Byte_ValueList) ForEach(f func(wire.Value) error) error {
	for _, x := range v {
		w, err := wire.NewValueI8(x), error(nil)
		if err != nil {
			return err
		}
		err = f(w)
		if err != nil {
			return err
		}
	}
	return nil
}

func (v _List_Byte_ValueList) Size() int {
	return len(v)
}

func (_List_Byte_ValueList) ValueType() wire.Type {
	return wire.TI8
}

func (_List_Byte_ValueList) Close() {}

// ToWire translates a Bar_ArgWithQueryParams_Args struct into a Thrift-level intermediate
// representation. This intermediate representation may be serialized
// into bytes using a ThriftRW protocol implementation.
//
// An error is returned if the struct or any of its fields failed to
// validate.
//
//   x, err := v.ToWire()
//   if err != nil {
//     return err
//   }
//
//   if err := binaryProtocol.Encode(x, writer); err != nil {
//     return err
//   }
func (v *Bar_ArgWithQueryParams_Args) ToWire() (wire.Value, error) {
	var (
		fields [4]wire.Field
		i      int = 0
		w      wire.Value
		err    error
	)

	w, err = wire.NewValueString(v.Name), error(nil)
	if err != nil {
		return w, err
	}
	fields[i] = wire.Field{ID: 1, Value: w}
	i++
	if v.UserUUID != nil {
		w, err = wire.NewValueString(*(v.UserUUID)), error(nil)
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 2, Value: w}
		i++
	}
	if v.Foo != nil {
		w, err = wire.NewValueList(_List_String_ValueList(v.Foo)), error(nil)
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 3, Value: w}
		i++
	}

	w, err = wire.NewValueList(_List_Byte_ValueList(v.Bar)), error(nil)
	if err != nil {
		return w, err
	}
	fields[i] = wire.Field{ID: 4, Value: w}
	i++

	return wire.NewValueStruct(wire.Struct{Fields: fields[:i]}), nil
}

func _List_Byte_Read(l wire.ValueList) ([]int8, error) {
	if l.ValueType() != wire.TI8 {
		return nil, nil
	}

	o := make([]int8, 0, l.Size())
	err := l.ForEach(func(x wire.Value) error {
		i, err := x.GetI8(), error(nil)
		if err != nil {
			return err
		}
		o = append(o, i)
		return nil
	})
	l.Close()
	return o, err
}

// FromWire deserializes a Bar_ArgWithQueryParams_Args struct from its Thrift-level
// representation. The Thrift-level representation may be obtained
// from a ThriftRW protocol implementation.
//
// An error is returned if we were unable to build a Bar_ArgWithQueryParams_Args struct
// from the provided intermediate representation.
//
//   x, err := binaryProtocol.Decode(reader, wire.TStruct)
//   if err != nil {
//     return nil, err
//   }
//
//   var v Bar_ArgWithQueryParams_Args
//   if err := v.FromWire(x); err != nil {
//     return nil, err
//   }
//   return &v, nil
func (v *Bar_ArgWithQueryParams_Args) FromWire(w wire.Value) error {
	var err error

	nameIsSet := false

	barIsSet := false

	for _, field := range w.GetStruct().Fields {
		switch field.ID {
		case 1:
			if field.Value.Type() == wire.TBinary {
				v.Name, err = field.Value.GetString(), error(nil)
				if err != nil {
					return err
				}
				nameIsSet = true
			}
		case 2:
			if field.Value.Type() == wire.TBinary {
				var x string
				x, err = field.Value.GetString(), error(nil)
				v.UserUUID = &x
				if err != nil {
					return err
				}

			}
		case 3:
			if field.Value.Type() == wire.TList {
				v.Foo, err = _List_String_Read(field.Value.GetList())
				if err != nil {
					return err
				}

			}
		case 4:
			if field.Value.Type() == wire.TList {
				v.Bar, err = _List_Byte_Read(field.Value.GetList())
				if err != nil {
					return err
				}
				barIsSet = true
			}
		}
	}

	if !nameIsSet {
		return errors.New("field Name of Bar_ArgWithQueryParams_Args is required")
	}

	if !barIsSet {
		return errors.New("field Bar of Bar_ArgWithQueryParams_Args is required")
	}

	return nil
}

// String returns a readable string representation of a Bar_ArgWithQueryParams_Args
// struct.
func (v *Bar_ArgWithQueryParams_Args) String() string {
	if v == nil {
		return "<nil>"
	}

	var fields [4]string
	i := 0
	fields[i] = fmt.Sprintf("Name: %v", v.Name)
	i++
	if v.UserUUID != nil {
		fields[i] = fmt.Sprintf("UserUUID: %v", *(v.UserUUID))
		i++
	}
	if v.Foo != nil {
		fields[i] = fmt.Sprintf("Foo: %v", v.Foo)
		i++
	}
	fields[i] = fmt.Sprintf("Bar: %v", v.Bar)
	i++

	return fmt.Sprintf("Bar_ArgWithQueryParams_Args{%v}", strings.Join(fields[:i], ", "))
}

func _List_Byte_Equals(lhs, rhs []int8) bool {
	if len(lhs) != len(rhs) {
		return false
	}

	for i, lv := range lhs {
		rv := rhs[i]
		if !(lv == rv) {
			return false
		}
	}

	return true
}

// Equals returns true if all the fields of this Bar_ArgWithQueryParams_Args match the
// provided Bar_ArgWithQueryParams_Args.
//
// This function performs a deep comparison.
func (v *Bar_ArgWithQueryParams_Args) Equals(rhs *Bar_ArgWithQueryParams_Args) bool {
	if v == nil {
		return rhs == nil
	} else if rhs == nil {
		return false
	}
	if !(v.Name == rhs.Name) {
		return false
	}
	if !_String_EqualsPtr(v.UserUUID, rhs.UserUUID) {
		return false
	}
	if !((v.Foo == nil && rhs.Foo == nil) || (v.Foo != nil && rhs.Foo != nil && _List_String_Equals(v.Foo, rhs.Foo))) {
		return false
	}
	if !_List_Byte_Equals(v.Bar, rhs.Bar) {
		return false
	}

	return true
}

type _List_Byte_Zapper []int8

// MarshalLogArray implements zapcore.ArrayMarshaler, enabling
// fast logging of _List_Byte_Zapper.
func (l _List_Byte_Zapper) MarshalLogArray(enc zapcore.ArrayEncoder) (err error) {
	for _, v := range l {
		enc.AppendInt8(v)
	}
	return err
}

// MarshalLogObject implements zapcore.ObjectMarshaler, enabling
// fast logging of Bar_ArgWithQueryParams_Args.
func (v *Bar_ArgWithQueryParams_Args) MarshalLogObject(enc zapcore.ObjectEncoder) (err error) {
	if v == nil {
		return nil
	}
	enc.AddString("name", v.Name)
	if v.UserUUID != nil {
		enc.AddString("userUUID", *v.UserUUID)
	}
	if v.Foo != nil {
		err = multierr.Append(err, enc.AddArray("foo", (_List_String_Zapper)(v.Foo)))
	}
	err = multierr.Append(err, enc.AddArray("bar", (_List_Byte_Zapper)(v.Bar)))
	return err
}

// GetName returns the value of Name if it is set or its
// zero value if it is unset.
func (v *Bar_ArgWithQueryParams_Args) GetName() (o string) {
	if v != nil {
		o = v.Name
	}
	return
}

// GetUserUUID returns the value of UserUUID if it is set or its
// zero value if it is unset.
func (v *Bar_ArgWithQueryParams_Args) GetUserUUID() (o string) {
	if v != nil && v.UserUUID != nil {
		return *v.UserUUID
	}

	return
}

// IsSetUserUUID returns true if UserUUID is not nil.
func (v *Bar_ArgWithQueryParams_Args) IsSetUserUUID() bool {
	return v != nil && v.UserUUID != nil
}

// GetFoo returns the value of Foo if it is set or its
// zero value if it is unset.
func (v *Bar_ArgWithQueryParams_Args) GetFoo() (o []string) {
	if v != nil && v.Foo != nil {
		return v.Foo
	}

	return
}

// IsSetFoo returns true if Foo is not nil.
func (v *Bar_ArgWithQueryParams_Args) IsSetFoo() bool {
	return v != nil && v.Foo != nil
}

// GetBar returns the value of Bar if it is set or its
// zero value if it is unset.
func (v *Bar_ArgWithQueryParams_Args) GetBar() (o []int8) {
	if v != nil {
		o = v.Bar
	}
	return
}

// IsSetBar returns true if Bar is not nil.
func (v *Bar_ArgWithQueryParams_Args) IsSetBar() bool {
	return v != nil && v.Bar != nil
}

// MethodName returns the name of the Thrift function as specified in
// the IDL, for which this struct represent the arguments.
//
// This will always be "argWithQueryParams" for this struct.
func (v *Bar_ArgWithQueryParams_Args) MethodName() string {
	return "argWithQueryParams"
}

// EnvelopeType returns the kind of value inside this struct.
//
// This will always be Call for this struct.
func (v *Bar_ArgWithQueryParams_Args) EnvelopeType() wire.EnvelopeType {
	return wire.Call
}

// Bar_ArgWithQueryParams_Helper provides functions that aid in handling the
// parameters and return values of the Bar.argWithQueryParams
// function.
var Bar_ArgWithQueryParams_Helper = struct {
	// Args accepts the parameters of argWithQueryParams in-order and returns
	// the arguments struct for the function.
	Args func(
		name string,
		userUUID *string,
		foo []string,
		bar []int8,
	) *Bar_ArgWithQueryParams_Args

	// IsException returns true if the given error can be thrown
	// by argWithQueryParams.
	//
	// An error can be thrown by argWithQueryParams only if the
	// corresponding exception type was mentioned in the 'throws'
	// section for it in the Thrift file.
	IsException func(error) bool

	// WrapResponse returns the result struct for argWithQueryParams
	// given its return value and error.
	//
	// This allows mapping values and errors returned by
	// argWithQueryParams into a serializable result struct.
	// WrapResponse returns a non-nil error if the provided
	// error cannot be thrown by argWithQueryParams
	//
	//   value, err := argWithQueryParams(args)
	//   result, err := Bar_ArgWithQueryParams_Helper.WrapResponse(value, err)
	//   if err != nil {
	//     return fmt.Errorf("unexpected error from argWithQueryParams: %v", err)
	//   }
	//   serialize(result)
	WrapResponse func(*BarResponse, error) (*Bar_ArgWithQueryParams_Result, error)

	// UnwrapResponse takes the result struct for argWithQueryParams
	// and returns the value or error returned by it.
	//
	// The error is non-nil only if argWithQueryParams threw an
	// exception.
	//
	//   result := deserialize(bytes)
	//   value, err := Bar_ArgWithQueryParams_Helper.UnwrapResponse(result)
	UnwrapResponse func(*Bar_ArgWithQueryParams_Result) (*BarResponse, error)
}{}

func init() {
	Bar_ArgWithQueryParams_Helper.Args = func(
		name string,
		userUUID *string,
		foo []string,
		bar []int8,
	) *Bar_ArgWithQueryParams_Args {
		return &Bar_ArgWithQueryParams_Args{
			Name:     name,
			UserUUID: userUUID,
			Foo:      foo,
			Bar:      bar,
		}
	}

	Bar_ArgWithQueryParams_Helper.IsException = func(err error) bool {
		switch err.(type) {
		default:
			return false
		}
	}

	Bar_ArgWithQueryParams_Helper.WrapResponse = func(success *BarResponse, err error) (*Bar_ArgWithQueryParams_Result, error) {
		if err == nil {
			return &Bar_ArgWithQueryParams_Result{Success: success}, nil
		}

		return nil, err
	}
	Bar_ArgWithQueryParams_Helper.UnwrapResponse = func(result *Bar_ArgWithQueryParams_Result) (success *BarResponse, err error) {

		if result.Success != nil {
			success = result.Success
			return
		}

		err = errors.New("expected a non-void result")
		return
	}

}

// Bar_ArgWithQueryParams_Result represents the result of a Bar.argWithQueryParams function call.
//
// The result of a argWithQueryParams execution is sent and received over the wire as this struct.
//
// Success is set only if the function did not throw an exception.
type Bar_ArgWithQueryParams_Result struct {
	// Value returned by argWithQueryParams after a successful execution.
	Success *BarResponse `json:"success,omitempty"`
}

// ToWire translates a Bar_ArgWithQueryParams_Result struct into a Thrift-level intermediate
// representation. This intermediate representation may be serialized
// into bytes using a ThriftRW protocol implementation.
//
// An error is returned if the struct or any of its fields failed to
// validate.
//
//   x, err := v.ToWire()
//   if err != nil {
//     return err
//   }
//
//   if err := binaryProtocol.Encode(x, writer); err != nil {
//     return err
//   }
func (v *Bar_ArgWithQueryParams_Result) ToWire() (wire.Value, error) {
	var (
		fields [1]wire.Field
		i      int = 0
		w      wire.Value
		err    error
	)

	if v.Success != nil {
		w, err = v.Success.ToWire()
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 0, Value: w}
		i++
	}

	if i != 1 {
		return wire.Value{}, fmt.Errorf("Bar_ArgWithQueryParams_Result should have exactly one field: got %v fields", i)
	}

	return wire.NewValueStruct(wire.Struct{Fields: fields[:i]}), nil
}

// FromWire deserializes a Bar_ArgWithQueryParams_Result struct from its Thrift-level
// representation. The Thrift-level representation may be obtained
// from a ThriftRW protocol implementation.
//
// An error is returned if we were unable to build a Bar_ArgWithQueryParams_Result struct
// from the provided intermediate representation.
//
//   x, err := binaryProtocol.Decode(reader, wire.TStruct)
//   if err != nil {
//     return nil, err
//   }
//
//   var v Bar_ArgWithQueryParams_Result
//   if err := v.FromWire(x); err != nil {
//     return nil, err
//   }
//   return &v, nil
func (v *Bar_ArgWithQueryParams_Result) FromWire(w wire.Value) error {
	var err error

	for _, field := range w.GetStruct().Fields {
		switch field.ID {
		case 0:
			if field.Value.Type() == wire.TStruct {
				v.Success, err = _BarResponse_Read(field.Value)
				if err != nil {
					return err
				}

			}
		}
	}

	count := 0
	if v.Success != nil {
		count++
	}
	if count != 1 {
		return fmt.Errorf("Bar_ArgWithQueryParams_Result should have exactly one field: got %v fields", count)
	}

	return nil
}

// String returns a readable string representation of a Bar_ArgWithQueryParams_Result
// struct.
func (v *Bar_ArgWithQueryParams_Result) String() string {
	if v == nil {
		return "<nil>"
	}

	var fields [1]string
	i := 0
	if v.Success != nil {
		fields[i] = fmt.Sprintf("Success: %v", v.Success)
		i++
	}

	return fmt.Sprintf("Bar_ArgWithQueryParams_Result{%v}", strings.Join(fields[:i], ", "))
}

// Equals returns true if all the fields of this Bar_ArgWithQueryParams_Result match the
// provided Bar_ArgWithQueryParams_Result.
//
// This function performs a deep comparison.
func (v *Bar_ArgWithQueryParams_Result) Equals(rhs *Bar_ArgWithQueryParams_Result) bool {
	if v == nil {
		return rhs == nil
	} else if rhs == nil {
		return false
	}
	if !((v.Success == nil && rhs.Success == nil) || (v.Success != nil && rhs.Success != nil && v.Success.Equals(rhs.Success))) {
		return false
	}

	return true
}

// MarshalLogObject implements zapcore.ObjectMarshaler, enabling
// fast logging of Bar_ArgWithQueryParams_Result.
func (v *Bar_ArgWithQueryParams_Result) MarshalLogObject(enc zapcore.ObjectEncoder) (err error) {
	if v == nil {
		return nil
	}
	if v.Success != nil {
		err = multierr.Append(err, enc.AddObject("success", v.Success))
	}
	return err
}

// GetSuccess returns the value of Success if it is set or its
// zero value if it is unset.
func (v *Bar_ArgWithQueryParams_Result) GetSuccess() (o *BarResponse) {
	if v != nil && v.Success != nil {
		return v.Success
	}

	return
}

// IsSetSuccess returns true if Success is not nil.
func (v *Bar_ArgWithQueryParams_Result) IsSetSuccess() bool {
	return v != nil && v.Success != nil
}

// MethodName returns the name of the Thrift function as specified in
// the IDL, for which this struct represent the result.
//
// This will always be "argWithQueryParams" for this struct.
func (v *Bar_ArgWithQueryParams_Result) MethodName() string {
	return "argWithQueryParams"
}

// EnvelopeType returns the kind of value inside this struct.
//
// This will always be Reply for this struct.
func (v *Bar_ArgWithQueryParams_Result) EnvelopeType() wire.EnvelopeType {
	return wire.Reply
}

// Bar_DeleteFoo_Args represents the arguments for the Bar.deleteFoo function.
//
// The arguments for deleteFoo are sent and received over the wire as this struct.
type Bar_DeleteFoo_Args struct {
	UserUUID string `json:"userUUID,required"`
}

// ToWire translates a Bar_DeleteFoo_Args struct into a Thrift-level intermediate
// representation. This intermediate representation may be serialized
// into bytes using a ThriftRW protocol implementation.
//
// An error is returned if the struct or any of its fields failed to
// validate.
//
//   x, err := v.ToWire()
//   if err != nil {
//     return err
//   }
//
//   if err := binaryProtocol.Encode(x, writer); err != nil {
//     return err
//   }
func (v *Bar_DeleteFoo_Args) ToWire() (wire.Value, error) {
	var (
		fields [1]wire.Field
		i      int = 0
		w      wire.Value
		err    error
	)

	w, err = wire.NewValueString(v.UserUUID), error(nil)
	if err != nil {
		return w, err
	}
	fields[i] = wire.Field{ID: 1, Value: w}
	i++

	return wire.NewValueStruct(wire.Struct{Fields: fields[:i]}), nil
}

// FromWire deserializes a Bar_DeleteFoo_Args struct from its Thrift-level
// representation. The Thrift-level representation may be obtained
// from a ThriftRW protocol implementation.
//
// An error is returned if we were unable to build a Bar_DeleteFoo_Args struct
// from the provided intermediate representation.
//
//   x, err := binaryProtocol.Decode(reader, wire.TStruct)
//   if err != nil {
//     return nil, err
//   }
//
//   var v Bar_DeleteFoo_Args
//   if err := v.FromWire(x); err != nil {
//     return nil, err
//   }
//   return &v, nil
func (v *Bar_DeleteFoo_Args) FromWire(w wire.Value) error {
	var err error

	userUUIDIsSet := false

	for _, field := range w.GetStruct().Fields {
		switch field.ID {
		case 1:
			if field.Value.Type() == wire.TBinary {
				v.UserUUID, err = field.Value.GetString(), error(nil)
				if err != nil {
					return err
				}
				userUUIDIsSet = true
			}
		}
	}

	if !userUUIDIsSet {
		return errors.New("field UserUUID of Bar_DeleteFoo_Args is required")
	}

	return nil
}

// String returns a readable string representation of a Bar_DeleteFoo_Args
// struct.
func (v *Bar_DeleteFoo_Args) String() string {
	if v == nil {
		return "<nil>"
	}

	var fields [1]string
	i := 0
	fields[i] = fmt.Sprintf("UserUUID: %v", v.UserUUID)
	i++

	return fmt.Sprintf("Bar_DeleteFoo_Args{%v}", strings.Join(fields[:i], ", "))
}

// Equals returns true if all the fields of this Bar_DeleteFoo_Args match the
// provided Bar_DeleteFoo_Args.
//
// This function performs a deep comparison.
func (v *Bar_DeleteFoo_Args) Equals(rhs *Bar_DeleteFoo_Args) bool {
	if v == nil {
		return rhs == nil
	} else if rhs == nil {
		return false
	}
	if !(v.UserUUID == rhs.UserUUID) {
		return false
	}

	return true
}

// MarshalLogObject implements zapcore.ObjectMarshaler, enabling
// fast logging of Bar_DeleteFoo_Args.
func (v *Bar_DeleteFoo_Args) MarshalLogObject(enc zapcore.ObjectEncoder) (err error) {
	if v == nil {
		return nil
	}
	enc.AddString("userUUID", v.UserUUID)
	return err
}

// GetUserUUID returns the value of UserUUID if it is set or its
// zero value if it is unset.
func (v *Bar_DeleteFoo_Args) GetUserUUID() (o string) {
	if v != nil {
		o = v.UserUUID
	}
	return
}

// MethodName returns the name of the Thrift function as specified in
// the IDL, for which this struct represent the arguments.
//
// This will always be "deleteFoo" for this struct.
func (v *Bar_DeleteFoo_Args) MethodName() string {
	return "deleteFoo"
}

// EnvelopeType returns the kind of value inside this struct.
//
// This will always be Call for this struct.
func (v *Bar_DeleteFoo_Args) EnvelopeType() wire.EnvelopeType {
	return wire.Call
}

// Bar_DeleteFoo_Helper provides functions that aid in handling the
// parameters and return values of the Bar.deleteFoo
// function.
var Bar_DeleteFoo_Helper = struct {
	// Args accepts the parameters of deleteFoo in-order and returns
	// the arguments struct for the function.
	Args func(
		userUUID string,
	) *Bar_DeleteFoo_Args

	// IsException returns true if the given error can be thrown
	// by deleteFoo.
	//
	// An error can be thrown by deleteFoo only if the
	// corresponding exception type was mentioned in the 'throws'
	// section for it in the Thrift file.
	IsException func(error) bool

	// WrapResponse returns the result struct for deleteFoo
	// given the error returned by it. The provided error may
	// be nil if deleteFoo did not fail.
	//
	// This allows mapping errors returned by deleteFoo into a
	// serializable result struct. WrapResponse returns a
	// non-nil error if the provided error cannot be thrown by
	// deleteFoo
	//
	//   err := deleteFoo(args)
	//   result, err := Bar_DeleteFoo_Helper.WrapResponse(err)
	//   if err != nil {
	//     return fmt.Errorf("unexpected error from deleteFoo: %v", err)
	//   }
	//   serialize(result)
	WrapResponse func(error) (*Bar_DeleteFoo_Result, error)

	// UnwrapResponse takes the result struct for deleteFoo
	// and returns the erorr returned by it (if any).
	//
	// The error is non-nil only if deleteFoo threw an
	// exception.
	//
	//   result := deserialize(bytes)
	//   err := Bar_DeleteFoo_Helper.UnwrapResponse(result)
	UnwrapResponse func(*Bar_DeleteFoo_Result) error
}{}

func init() {
	Bar_DeleteFoo_Helper.Args = func(
		userUUID string,
	) *Bar_DeleteFoo_Args {
		return &Bar_DeleteFoo_Args{
			UserUUID: userUUID,
		}
	}

	Bar_DeleteFoo_Helper.IsException = func(err error) bool {
		switch err.(type) {
		default:
			return false
		}
	}

	Bar_DeleteFoo_Helper.WrapResponse = func(err error) (*Bar_DeleteFoo_Result, error) {
		if err == nil {
			return &Bar_DeleteFoo_Result{}, nil
		}

		return nil, err
	}
	Bar_DeleteFoo_Helper.UnwrapResponse = func(result *Bar_DeleteFoo_Result) (err error) {
		return
	}

}

// Bar_DeleteFoo_Result represents the result of a Bar.deleteFoo function call.
//
// The result of a deleteFoo execution is sent and received over the wire as this struct.
type Bar_DeleteFoo_Result struct {
}

// ToWire translates a Bar_DeleteFoo_Result struct into a Thrift-level intermediate
// representation. This intermediate representation may be serialized
// into bytes using a ThriftRW protocol implementation.
//
// An error is returned if the struct or any of its fields failed to
// validate.
//
//   x, err := v.ToWire()
//   if err != nil {
//     return err
//   }
//
//   if err := binaryProtocol.Encode(x, writer); err != nil {
//     return err
//   }
func (v *Bar_DeleteFoo_Result) ToWire() (wire.Value, error) {
	var (
		fields [0]wire.Field
		i      int = 0
	)

	return wire.NewValueStruct(wire.Struct{Fields: fields[:i]}), nil
}

// FromWire deserializes a Bar_DeleteFoo_Result struct from its Thrift-level
// representation. The Thrift-level representation may be obtained
// from a ThriftRW protocol implementation.
//
// An error is returned if we were unable to build a Bar_DeleteFoo_Result struct
// from the provided intermediate representation.
//
//   x, err := binaryProtocol.Decode(reader, wire.TStruct)
//   if err != nil {
//     return nil, err
//   }
//
//   var v Bar_DeleteFoo_Result
//   if err := v.FromWire(x); err != nil {
//     return nil, err
//   }
//   return &v, nil
func (v *Bar_DeleteFoo_Result) FromWire(w wire.Value) error {

	for _, field := range w.GetStruct().Fields {
		switch field.ID {
		}
	}

	return nil
}

// String returns a readable string representation of a Bar_DeleteFoo_Result
// struct.
func (v *Bar_DeleteFoo_Result) String() string {
	if v == nil {
		return "<nil>"
	}

	var fields [0]string
	i := 0

	return fmt.Sprintf("Bar_DeleteFoo_Result{%v}", strings.Join(fields[:i], ", "))
}

// Equals returns true if all the fields of this Bar_DeleteFoo_Result match the
// provided Bar_DeleteFoo_Result.
//
// This function performs a deep comparison.
func (v *Bar_DeleteFoo_Result) Equals(rhs *Bar_DeleteFoo_Result) bool {
	if v == nil {
		return rhs == nil
	} else if rhs == nil {
		return false
	}

	return true
}

// MarshalLogObject implements zapcore.ObjectMarshaler, enabling
// fast logging of Bar_DeleteFoo_Result.
func (v *Bar_DeleteFoo_Result) MarshalLogObject(enc zapcore.ObjectEncoder) (err error) {
	if v == nil {
		return nil
	}
	return err
}

// MethodName returns the name of the Thrift function as specified in
// the IDL, for which this struct represent the result.
//
// This will always be "deleteFoo" for this struct.
func (v *Bar_DeleteFoo_Result) MethodName() string {
	return "deleteFoo"
}

// EnvelopeType returns the kind of value inside this struct.
//
// This will always be Reply for this struct.
func (v *Bar_DeleteFoo_Result) EnvelopeType() wire.EnvelopeType {
	return wire.Reply
}

// Bar_DeleteWithQueryParams_Args represents the arguments for the Bar.deleteWithQueryParams function.
//
// The arguments for deleteWithQueryParams are sent and received over the wire as this struct.
type Bar_DeleteWithQueryParams_Args struct {
	Filter string `json:"filter,required"`
	Count  *int32 `json:"count,omitempty"`
}

// ToWire translates a Bar_DeleteWithQueryParams_Args struct into a Thrift-level intermediate
// representation. This intermediate representation may be serialized
// into bytes using a ThriftRW protocol implementation.
//
// An error is returned if the struct or any of its fields failed to
// validate.
//
//   x, err := v.ToWire()
//   if err != nil {
//     return err
//   }
//
//   if err := binaryProtocol.Encode(x, writer); err != nil {
//     return err
//   }
func (v *Bar_DeleteWithQueryParams_Args) ToWire() (wire.Value, error) {
	var (
		fields [2]wire.Field
		i      int = 0
		w      wire.Value
		err    error
	)

	w, err = wire.NewValueString(v.Filter), error(nil)
	if err != nil {
		return w, err
	}
	fields[i] = wire.Field{ID: 2, Value: w}
	i++
	if v.Count != nil {
		w, err = wire.NewValueI32(*(v.Count)), error(nil)
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 3, Value: w}
		i++
	}

	return wire.NewValueStruct(wire.Struct{Fields: fields[:i]}), nil
}

// FromWire deserializes a Bar_DeleteWithQueryParams_Args struct from its Thrift-level
// representation. The Thrift-level representation may be obtained
// from a ThriftRW protocol implementation.
//
// An error is returned if we were unable to build a Bar_DeleteWithQueryParams_Args struct
// from the provided intermediate representation.
//
//   x, err := binaryProtocol.Decode(reader, wire.TStruct)
//   if err != nil {
//     return nil, err
//   }
//
//   var v Bar_DeleteWithQueryParams_Args
//   if err := v.FromWire(x); err != nil {
//     return nil, err
//   }
//   return &v, nil
func (v *Bar_DeleteWithQueryParams_Args) FromWire(w wire.Value) error {
	var err error

	filterIsSet := false

	for _, field := range w.GetStruct().Fields {
		switch field.ID {
		case 2:
			if field.Value.Type() == wire.TBinary {
				v.Filter, err = field.Value.GetString(), error(nil)
				if err != nil {
					return err
				}
				filterIsSet = true
			}
		case 3:
			if field.Value.Type() == wire.TI32 {
				var x int32
				x, err = field.Value.GetI32(), error(nil)
				v.Count = &x
				if err != nil {
					return err
				}

			}
		}
	}

	if !filterIsSet {
		return errors.New("field Filter of Bar_DeleteWithQueryParams_Args is required")
	}

	return nil
}

// String returns a readable string representation of a Bar_DeleteWithQueryParams_Args
// struct.
func (v *Bar_DeleteWithQueryParams_Args) String() string {
	if v == nil {
		return "<nil>"
	}

	var fields [2]string
	i := 0
	fields[i] = fmt.Sprintf("Filter: %v", v.Filter)
	i++
	if v.Count != nil {
		fields[i] = fmt.Sprintf("Count: %v", *(v.Count))
		i++
	}

	return fmt.Sprintf("Bar_DeleteWithQueryParams_Args{%v}", strings.Join(fields[:i], ", "))
}

// Equals returns true if all the fields of this Bar_DeleteWithQueryParams_Args match the
// provided Bar_DeleteWithQueryParams_Args.
//
// This function performs a deep comparison.
func (v *Bar_DeleteWithQueryParams_Args) Equals(rhs *Bar_DeleteWithQueryParams_Args) bool {
	if v == nil {
		return rhs == nil
	} else if rhs == nil {
		return false
	}
	if !(v.Filter == rhs.Filter) {
		return false
	}
	if !_I32_EqualsPtr(v.Count, rhs.Count) {
		return false
	}

	return true
}

// MarshalLogObject implements zapcore.ObjectMarshaler, enabling
// fast logging of Bar_DeleteWithQueryParams_Args.
func (v *Bar_DeleteWithQueryParams_Args) MarshalLogObject(enc zapcore.ObjectEncoder) (err error) {
	if v == nil {
		return nil
	}
	enc.AddString("filter", v.Filter)
	if v.Count != nil {
		enc.AddInt32("count", *v.Count)
	}
	return err
}

// GetFilter returns the value of Filter if it is set or its
// zero value if it is unset.
func (v *Bar_DeleteWithQueryParams_Args) GetFilter() (o string) {
	if v != nil {
		o = v.Filter
	}
	return
}

// GetCount returns the value of Count if it is set or its
// zero value if it is unset.
func (v *Bar_DeleteWithQueryParams_Args) GetCount() (o int32) {
	if v != nil && v.Count != nil {
		return *v.Count
	}

	return
}

// IsSetCount returns true if Count is not nil.
func (v *Bar_DeleteWithQueryParams_Args) IsSetCount() bool {
	return v != nil && v.Count != nil
}

// MethodName returns the name of the Thrift function as specified in
// the IDL, for which this struct represent the arguments.
//
// This will always be "deleteWithQueryParams" for this struct.
func (v *Bar_DeleteWithQueryParams_Args) MethodName() string {
	return "deleteWithQueryParams"
}

// EnvelopeType returns the kind of value inside this struct.
//
// This will always be Call for this struct.
func (v *Bar_DeleteWithQueryParams_Args) EnvelopeType() wire.EnvelopeType {
	return wire.Call
}

// Bar_DeleteWithQueryParams_Helper provides functions that aid in handling the
// parameters and return values of the Bar.deleteWithQueryParams
// function.
var Bar_DeleteWithQueryParams_Helper = struct {
	// Args accepts the parameters of deleteWithQueryParams in-order and returns
	// the arguments struct for the function.
	Args func(
		filter string,
		count *int32,
	) *Bar_DeleteWithQueryParams_Args

	// IsException returns true if the given error can be thrown
	// by deleteWithQueryParams.
	//
	// An error can be thrown by deleteWithQueryParams only if the
	// corresponding exception type was mentioned in the 'throws'
	// section for it in the Thrift file.
	IsException func(error) bool

	// WrapResponse returns the result struct for deleteWithQueryParams
	// given the error returned by it. The provided error may
	// be nil if deleteWithQueryParams did not fail.
	//
	// This allows mapping errors returned by deleteWithQueryParams into a
	// serializable result struct. WrapResponse returns a
	// non-nil error if the provided error cannot be thrown by
	// deleteWithQueryParams
	//
	//   err := deleteWithQueryParams(args)
	//   result, err := Bar_DeleteWithQueryParams_Helper.WrapResponse(err)
	//   if err != nil {
	//     return fmt.Errorf("unexpected error from deleteWithQueryParams: %v", err)
	//   }
	//   serialize(result)
	WrapResponse func(error) (*Bar_DeleteWithQueryParams_Result, error)

	// UnwrapResponse takes the result struct for deleteWithQueryParams
	// and returns the erorr returned by it (if any).
	//
	// The error is non-nil only if deleteWithQueryParams threw an
	// exception.
	//
	//   result := deserialize(bytes)
	//   err := Bar_DeleteWithQueryParams_Helper.UnwrapResponse(result)
	UnwrapResponse func(*Bar_DeleteWithQueryParams_Result) error
}{}

func init() {
	Bar_DeleteWithQueryParams_Helper.Args = func(
		filter string,
		count *int32,
	) *Bar_DeleteWithQueryParams_Args {
		return &Bar_DeleteWithQueryParams_Args{
			Filter: filter,
			Count:  count,
		}
	}

	Bar_DeleteWithQueryParams_Helper.IsException = func(err error) bool {
		switch err.(type) {
		default:
			return false
		}
	}

	Bar_DeleteWithQueryParams_Helper.WrapResponse = func(err error) (*Bar_DeleteWithQueryParams_Result, error) {
		if err == nil {
			return &Bar_DeleteWithQueryParams_Result{}, nil
		}

		return nil, err
	}
	Bar_DeleteWithQueryParams_Helper.UnwrapResponse = func(result *Bar_DeleteWithQueryParams_Result) (err error) {
		return
	}

}

// Bar_DeleteWithQueryParams_Result represents the result of a Bar.deleteWithQueryParams function call.
//
// The result of a deleteWithQueryParams execution is sent and received over the wire as this struct.
type Bar_DeleteWithQueryParams_Result struct {
}

// ToWire translates a Bar_DeleteWithQueryParams_Result struct into a Thrift-level intermediate
// representation. This intermediate representation may be serialized
// into bytes using a ThriftRW protocol implementation.
//
// An error is returned if the struct or any of its fields failed to
// validate.
//
//   x, err := v.ToWire()
//   if err != nil {
//     return err
//   }
//
//   if err := binaryProtocol.Encode(x, writer); err != nil {
//     return err
//   }
func (v *Bar_DeleteWithQueryParams_Result) ToWire() (wire.Value, error) {
	var (
		fields [0]wire.Field
		i      int = 0
	)

	return wire.NewValueStruct(wire.Struct{Fields: fields[:i]}), nil
}

// FromWire deserializes a Bar_DeleteWithQueryParams_Result struct from its Thrift-level
// representation. The Thrift-level representation may be obtained
// from a ThriftRW protocol implementation.
//
// An error is returned if we were unable to build a Bar_DeleteWithQueryParams_Result struct
// from the provided intermediate representation.
//
//   x, err := binaryProtocol.Decode(reader, wire.TStruct)
//   if err != nil {
//     return nil, err
//   }
//
//   var v Bar_DeleteWithQueryParams_Result
//   if err := v.FromWire(x); err != nil {
//     return nil, err
//   }
//   return &v, nil
func (v *Bar_DeleteWithQueryParams_Result) FromWire(w wire.Value) error {

	for _, field := range w.GetStruct().Fields {
		switch field.ID {
		}
	}

	return nil
}

// String returns a readable string representation of a Bar_DeleteWithQueryParams_Result
// struct.
func (v *Bar_DeleteWithQueryParams_Result) String() string {
	if v == nil {
		return "<nil>"
	}

	var fields [0]string
	i := 0

	return fmt.Sprintf("Bar_DeleteWithQueryParams_Result{%v}", strings.Join(fields[:i], ", "))
}

// Equals returns true if all the fields of this Bar_DeleteWithQueryParams_Result match the
// provided Bar_DeleteWithQueryParams_Result.
//
// This function performs a deep comparison.
func (v *Bar_DeleteWithQueryParams_Result) Equals(rhs *Bar_DeleteWithQueryParams_Result) bool {
	if v == nil {
		return rhs == nil
	} else if rhs == nil {
		return false
	}

	return true
}

// MarshalLogObject implements zapcore.ObjectMarshaler, enabling
// fast logging of Bar_DeleteWithQueryParams_Result.
func (v *Bar_DeleteWithQueryParams_Result) MarshalLogObject(enc zapcore.ObjectEncoder) (err error) {
	if v == nil {
		return nil
	}
	return err
}

// MethodName returns the name of the Thrift function as specified in
// the IDL, for which this struct represent the result.
//
// This will always be "deleteWithQueryParams" for this struct.
func (v *Bar_DeleteWithQueryParams_Result) MethodName() string {
	return "deleteWithQueryParams"
}

// EnvelopeType returns the kind of value inside this struct.
//
// This will always be Reply for this struct.
func (v *Bar_DeleteWithQueryParams_Result) EnvelopeType() wire.EnvelopeType {
	return wire.Reply
}

// Bar_HelloWorld_Args represents the arguments for the Bar.helloWorld function.
//
// The arguments for helloWorld are sent and received over the wire as this struct.
type Bar_HelloWorld_Args struct {
}

// ToWire translates a Bar_HelloWorld_Args struct into a Thrift-level intermediate
// representation. This intermediate representation may be serialized
// into bytes using a ThriftRW protocol implementation.
//
// An error is returned if the struct or any of its fields failed to
// validate.
//
//   x, err := v.ToWire()
//   if err != nil {
//     return err
//   }
//
//   if err := binaryProtocol.Encode(x, writer); err != nil {
//     return err
//   }
func (v *Bar_HelloWorld_Args) ToWire() (wire.Value, error) {
	var (
		fields [0]wire.Field
		i      int = 0
	)

	return wire.NewValueStruct(wire.Struct{Fields: fields[:i]}), nil
}

// FromWire deserializes a Bar_HelloWorld_Args struct from its Thrift-level
// representation. The Thrift-level representation may be obtained
// from a ThriftRW protocol implementation.
//
// An error is returned if we were unable to build a Bar_HelloWorld_Args struct
// from the provided intermediate representation.
//
//   x, err := binaryProtocol.Decode(reader, wire.TStruct)
//   if err != nil {
//     return nil, err
//   }
//
//   var v Bar_HelloWorld_Args
//   if err := v.FromWire(x); err != nil {
//     return nil, err
//   }
//   return &v, nil
func (v *Bar_HelloWorld_Args) FromWire(w wire.Value) error {

	for _, field := range w.GetStruct().Fields {
		switch field.ID {
		}
	}

	return nil
}

// String returns a readable string representation of a Bar_HelloWorld_Args
// struct.
func (v *Bar_HelloWorld_Args) String() string {
	if v == nil {
		return "<nil>"
	}

	var fields [0]string
	i := 0

	return fmt.Sprintf("Bar_HelloWorld_Args{%v}", strings.Join(fields[:i], ", "))
}

// Equals returns true if all the fields of this Bar_HelloWorld_Args match the
// provided Bar_HelloWorld_Args.
//
// This function performs a deep comparison.
func (v *Bar_HelloWorld_Args) Equals(rhs *Bar_HelloWorld_Args) bool {
	if v == nil {
		return rhs == nil
	} else if rhs == nil {
		return false
	}

	return true
}

// MarshalLogObject implements zapcore.ObjectMarshaler, enabling
// fast logging of Bar_HelloWorld_Args.
func (v *Bar_HelloWorld_Args) MarshalLogObject(enc zapcore.ObjectEncoder) (err error) {
	if v == nil {
		return nil
	}
	return err
}

// MethodName returns the name of the Thrift function as specified in
// the IDL, for which this struct represent the arguments.
//
// This will always be "helloWorld" for this struct.
func (v *Bar_HelloWorld_Args) MethodName() string {
	return "helloWorld"
}

// EnvelopeType returns the kind of value inside this struct.
//
// This will always be Call for this struct.
func (v *Bar_HelloWorld_Args) EnvelopeType() wire.EnvelopeType {
	return wire.Call
}

// Bar_HelloWorld_Helper provides functions that aid in handling the
// parameters and return values of the Bar.helloWorld
// function.
var Bar_HelloWorld_Helper = struct {
	// Args accepts the parameters of helloWorld in-order and returns
	// the arguments struct for the function.
	Args func() *Bar_HelloWorld_Args

	// IsException returns true if the given error can be thrown
	// by helloWorld.
	//
	// An error can be thrown by helloWorld only if the
	// corresponding exception type was mentioned in the 'throws'
	// section for it in the Thrift file.
	IsException func(error) bool

	// WrapResponse returns the result struct for helloWorld
	// given its return value and error.
	//
	// This allows mapping values and errors returned by
	// helloWorld into a serializable result struct.
	// WrapResponse returns a non-nil error if the provided
	// error cannot be thrown by helloWorld
	//
	//   value, err := helloWorld(args)
	//   result, err := Bar_HelloWorld_Helper.WrapResponse(value, err)
	//   if err != nil {
	//     return fmt.Errorf("unexpected error from helloWorld: %v", err)
	//   }
	//   serialize(result)
	WrapResponse func(string, error) (*Bar_HelloWorld_Result, error)

	// UnwrapResponse takes the result struct for helloWorld
	// and returns the value or error returned by it.
	//
	// The error is non-nil only if helloWorld threw an
	// exception.
	//
	//   result := deserialize(bytes)
	//   value, err := Bar_HelloWorld_Helper.UnwrapResponse(result)
	UnwrapResponse func(*Bar_HelloWorld_Result) (string, error)
}{}

func init() {
	Bar_HelloWorld_Helper.Args = func() *Bar_HelloWorld_Args {
		return &Bar_HelloWorld_Args{}
	}

	Bar_HelloWorld_Helper.IsException = func(err error) bool {
		switch err.(type) {
		case *BarException:
			return true
		default:
			return false
		}
	}

	Bar_HelloWorld_Helper.WrapResponse = func(success string, err error) (*Bar_HelloWorld_Result, error) {
		if err == nil {
			return &Bar_HelloWorld_Result{Success: &success}, nil
		}

		switch e := err.(type) {
		case *BarException:
			if e == nil {
				return nil, errors.New("WrapResponse received non-nil error type with nil value for Bar_HelloWorld_Result.BarException")
			}
			return &Bar_HelloWorld_Result{BarException: e}, nil
		}

		return nil, err
	}
	Bar_HelloWorld_Helper.UnwrapResponse = func(result *Bar_HelloWorld_Result) (success string, err error) {
		if result.BarException != nil {
			err = result.BarException
			return
		}

		if result.Success != nil {
			success = *result.Success
			return
		}

		err = errors.New("expected a non-void result")
		return
	}

}

// Bar_HelloWorld_Result represents the result of a Bar.helloWorld function call.
//
// The result of a helloWorld execution is sent and received over the wire as this struct.
//
// Success is set only if the function did not throw an exception.
type Bar_HelloWorld_Result struct {
	// Value returned by helloWorld after a successful execution.
	Success      *string       `json:"success,omitempty"`
	BarException *BarException `json:"barException,omitempty"`
}

// ToWire translates a Bar_HelloWorld_Result struct into a Thrift-level intermediate
// representation. This intermediate representation may be serialized
// into bytes using a ThriftRW protocol implementation.
//
// An error is returned if the struct or any of its fields failed to
// validate.
//
//   x, err := v.ToWire()
//   if err != nil {
//     return err
//   }
//
//   if err := binaryProtocol.Encode(x, writer); err != nil {
//     return err
//   }
func (v *Bar_HelloWorld_Result) ToWire() (wire.Value, error) {
	var (
		fields [2]wire.Field
		i      int = 0
		w      wire.Value
		err    error
	)

	if v.Success != nil {
		w, err = wire.NewValueString(*(v.Success)), error(nil)
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 0, Value: w}
		i++
	}
	if v.BarException != nil {
		w, err = v.BarException.ToWire()
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 1, Value: w}
		i++
	}

	if i != 1 {
		return wire.Value{}, fmt.Errorf("Bar_HelloWorld_Result should have exactly one field: got %v fields", i)
	}

	return wire.NewValueStruct(wire.Struct{Fields: fields[:i]}), nil
}

// FromWire deserializes a Bar_HelloWorld_Result struct from its Thrift-level
// representation. The Thrift-level representation may be obtained
// from a ThriftRW protocol implementation.
//
// An error is returned if we were unable to build a Bar_HelloWorld_Result struct
// from the provided intermediate representation.
//
//   x, err := binaryProtocol.Decode(reader, wire.TStruct)
//   if err != nil {
//     return nil, err
//   }
//
//   var v Bar_HelloWorld_Result
//   if err := v.FromWire(x); err != nil {
//     return nil, err
//   }
//   return &v, nil
func (v *Bar_HelloWorld_Result) FromWire(w wire.Value) error {
	var err error

	for _, field := range w.GetStruct().Fields {
		switch field.ID {
		case 0:
			if field.Value.Type() == wire.TBinary {
				var x string
				x, err = field.Value.GetString(), error(nil)
				v.Success = &x
				if err != nil {
					return err
				}

			}
		case 1:
			if field.Value.Type() == wire.TStruct {
				v.BarException, err = _BarException_Read(field.Value)
				if err != nil {
					return err
				}

			}
		}
	}

	count := 0
	if v.Success != nil {
		count++
	}
	if v.BarException != nil {
		count++
	}
	if count != 1 {
		return fmt.Errorf("Bar_HelloWorld_Result should have exactly one field: got %v fields", count)
	}

	return nil
}

// String returns a readable string representation of a Bar_HelloWorld_Result
// struct.
func (v *Bar_HelloWorld_Result) String() string {
	if v == nil {
		return "<nil>"
	}

	var fields [2]string
	i := 0
	if v.Success != nil {
		fields[i] = fmt.Sprintf("Success: %v", *(v.Success))
		i++
	}
	if v.BarException != nil {
		fields[i] = fmt.Sprintf("BarException: %v", v.BarException)
		i++
	}

	return fmt.Sprintf("Bar_HelloWorld_Result{%v}", strings.Join(fields[:i], ", "))
}

// Equals returns true if all the fields of this Bar_HelloWorld_Result match the
// provided Bar_HelloWorld_Result.
//
// This function performs a deep comparison.
func (v *Bar_HelloWorld_Result) Equals(rhs *Bar_HelloWorld_Result) bool {
	if v == nil {
		return rhs == nil
	} else if rhs == nil {
		return false
	}
	if !_String_EqualsPtr(v.Success, rhs.Success) {
		return false
	}
	if !((v.BarException == nil && rhs.BarException == nil) || (v.BarException != nil && rhs.BarException != nil && v.BarException.Equals(rhs.BarException))) {
		return false
	}

	return true
}

// MarshalLogObject implements zapcore.ObjectMarshaler, enabling
// fast logging of Bar_HelloWorld_Result.
func (v *Bar_HelloWorld_Result) MarshalLogObject(enc zapcore.ObjectEncoder) (err error) {
	if v == nil {
		return nil
	}
	if v.Success != nil {
		enc.AddString("success", *v.Success)
	}
	if v.BarException != nil {
		err = multierr.Append(err, enc.AddObject("barException", v.BarException))
	}
	return err
}

// GetSuccess returns the value of Success if it is set or its
// zero value if it is unset.
func (v *Bar_HelloWorld_Result) GetSuccess() (o string) {
	if v != nil && v.Success != nil {
		return *v.Success
	}

	return
}

// IsSetSuccess returns true if Success is not nil.
func (v *Bar_HelloWorld_Result) IsSetSuccess() bool {
	return v != nil && v.Success != nil
}

// GetBarException returns the value of BarException if it is set or its
// zero value if it is unset.
func (v *Bar_HelloWorld_Result) GetBarException() (o *BarException) {
	if v != nil && v.BarException != nil {
		return v.BarException
	}

	return
}

// IsSetBarException returns true if BarException is not nil.
func (v *Bar_HelloWorld_Result) IsSetBarException() bool {
	return v != nil && v.BarException != nil
}

// MethodName returns the name of the Thrift function as specified in
// the IDL, for which this struct represent the result.
//
// This will always be "helloWorld" for this struct.
func (v *Bar_HelloWorld_Result) MethodName() string {
	return "helloWorld"
}

// EnvelopeType returns the kind of value inside this struct.
//
// This will always be Reply for this struct.
func (v *Bar_HelloWorld_Result) EnvelopeType() wire.EnvelopeType {
	return wire.Reply
}

// Bar_ListAndEnum_Args represents the arguments for the Bar.listAndEnum function.
//
// The arguments for listAndEnum are sent and received over the wire as this struct.
type Bar_ListAndEnum_Args struct {
	DemoIds  []string   `json:"demoIds,required"`
	DemoType *DemoType  `json:"demoType,omitempty"`
	Demos    []DemoType `json:"demos,omitempty"`
}

// ToWire translates a Bar_ListAndEnum_Args struct into a Thrift-level intermediate
// representation. This intermediate representation may be serialized
// into bytes using a ThriftRW protocol implementation.
//
// An error is returned if the struct or any of its fields failed to
// validate.
//
//   x, err := v.ToWire()
//   if err != nil {
//     return err
//   }
//
//   if err := binaryProtocol.Encode(x, writer); err != nil {
//     return err
//   }
func (v *Bar_ListAndEnum_Args) ToWire() (wire.Value, error) {
	var (
		fields [3]wire.Field
		i      int = 0
		w      wire.Value
		err    error
	)

	w, err = wire.NewValueList(_List_String_ValueList(v.DemoIds)), error(nil)
	if err != nil {
		return w, err
	}
	fields[i] = wire.Field{ID: 1, Value: w}
	i++
	if v.DemoType != nil {
		w, err = v.DemoType.ToWire()
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 2, Value: w}
		i++
	}
	if v.Demos != nil {
		w, err = wire.NewValueList(_List_DemoType_ValueList(v.Demos)), error(nil)
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 3, Value: w}
		i++
	}

	return wire.NewValueStruct(wire.Struct{Fields: fields[:i]}), nil
}

// FromWire deserializes a Bar_ListAndEnum_Args struct from its Thrift-level
// representation. The Thrift-level representation may be obtained
// from a ThriftRW protocol implementation.
//
// An error is returned if we were unable to build a Bar_ListAndEnum_Args struct
// from the provided intermediate representation.
//
//   x, err := binaryProtocol.Decode(reader, wire.TStruct)
//   if err != nil {
//     return nil, err
//   }
//
//   var v Bar_ListAndEnum_Args
//   if err := v.FromWire(x); err != nil {
//     return nil, err
//   }
//   return &v, nil
func (v *Bar_ListAndEnum_Args) FromWire(w wire.Value) error {
	var err error

	demoIdsIsSet := false

	for _, field := range w.GetStruct().Fields {
		switch field.ID {
		case 1:
			if field.Value.Type() == wire.TList {
				v.DemoIds, err = _List_String_Read(field.Value.GetList())
				if err != nil {
					return err
				}
				demoIdsIsSet = true
			}
		case 2:
			if field.Value.Type() == wire.TI32 {
				var x DemoType
				x, err = _DemoType_Read(field.Value)
				v.DemoType = &x
				if err != nil {
					return err
				}

			}
		case 3:
			if field.Value.Type() == wire.TList {
				v.Demos, err = _List_DemoType_Read(field.Value.GetList())
				if err != nil {
					return err
				}

			}
		}
	}

	if !demoIdsIsSet {
		return errors.New("field DemoIds of Bar_ListAndEnum_Args is required")
	}

	return nil
}

// String returns a readable string representation of a Bar_ListAndEnum_Args
// struct.
func (v *Bar_ListAndEnum_Args) String() string {
	if v == nil {
		return "<nil>"
	}

	var fields [3]string
	i := 0
	fields[i] = fmt.Sprintf("DemoIds: %v", v.DemoIds)
	i++
	if v.DemoType != nil {
		fields[i] = fmt.Sprintf("DemoType: %v", *(v.DemoType))
		i++
	}
	if v.Demos != nil {
		fields[i] = fmt.Sprintf("Demos: %v", v.Demos)
		i++
	}

	return fmt.Sprintf("Bar_ListAndEnum_Args{%v}", strings.Join(fields[:i], ", "))
}

func _DemoType_EqualsPtr(lhs, rhs *DemoType) bool {
	if lhs != nil && rhs != nil {

		x := *lhs
		y := *rhs
		return x.Equals(y)
	}
	return lhs == nil && rhs == nil
}

// Equals returns true if all the fields of this Bar_ListAndEnum_Args match the
// provided Bar_ListAndEnum_Args.
//
// This function performs a deep comparison.
func (v *Bar_ListAndEnum_Args) Equals(rhs *Bar_ListAndEnum_Args) bool {
	if v == nil {
		return rhs == nil
	} else if rhs == nil {
		return false
	}
	if !_List_String_Equals(v.DemoIds, rhs.DemoIds) {
		return false
	}
	if !_DemoType_EqualsPtr(v.DemoType, rhs.DemoType) {
		return false
	}
	if !((v.Demos == nil && rhs.Demos == nil) || (v.Demos != nil && rhs.Demos != nil && _List_DemoType_Equals(v.Demos, rhs.Demos))) {
		return false
	}

	return true
}

// MarshalLogObject implements zapcore.ObjectMarshaler, enabling
// fast logging of Bar_ListAndEnum_Args.
func (v *Bar_ListAndEnum_Args) MarshalLogObject(enc zapcore.ObjectEncoder) (err error) {
	if v == nil {
		return nil
	}
	err = multierr.Append(err, enc.AddArray("demoIds", (_List_String_Zapper)(v.DemoIds)))
	if v.DemoType != nil {
		err = multierr.Append(err, enc.AddObject("demoType", *v.DemoType))
	}
	if v.Demos != nil {
		err = multierr.Append(err, enc.AddArray("demos", (_List_DemoType_Zapper)(v.Demos)))
	}
	return err
}

// GetDemoIds returns the value of DemoIds if it is set or its
// zero value if it is unset.
func (v *Bar_ListAndEnum_Args) GetDemoIds() (o []string) {
	if v != nil {
		o = v.DemoIds
	}
	return
}

// IsSetDemoIds returns true if DemoIds is not nil.
func (v *Bar_ListAndEnum_Args) IsSetDemoIds() bool {
	return v != nil && v.DemoIds != nil
}

// GetDemoType returns the value of DemoType if it is set or its
// zero value if it is unset.
func (v *Bar_ListAndEnum_Args) GetDemoType() (o DemoType) {
	if v != nil && v.DemoType != nil {
		return *v.DemoType
	}

	return
}

// IsSetDemoType returns true if DemoType is not nil.
func (v *Bar_ListAndEnum_Args) IsSetDemoType() bool {
	return v != nil && v.DemoType != nil
}

// GetDemos returns the value of Demos if it is set or its
// zero value if it is unset.
func (v *Bar_ListAndEnum_Args) GetDemos() (o []DemoType) {
	if v != nil && v.Demos != nil {
		return v.Demos
	}

	return
}

// IsSetDemos returns true if Demos is not nil.
func (v *Bar_ListAndEnum_Args) IsSetDemos() bool {
	return v != nil && v.Demos != nil
}

// MethodName returns the name of the Thrift function as specified in
// the IDL, for which this struct represent the arguments.
//
// This will always be "listAndEnum" for this struct.
func (v *Bar_ListAndEnum_Args) MethodName() string {
	return "listAndEnum"
}

// EnvelopeType returns the kind of value inside this struct.
//
// This will always be Call for this struct.
func (v *Bar_ListAndEnum_Args) EnvelopeType() wire.EnvelopeType {
	return wire.Call
}

// Bar_ListAndEnum_Helper provides functions that aid in handling the
// parameters and return values of the Bar.listAndEnum
// function.
var Bar_ListAndEnum_Helper = struct {
	// Args accepts the parameters of listAndEnum in-order and returns
	// the arguments struct for the function.
	Args func(
		demoIds []string,
		demoType *DemoType,
		demos []DemoType,
	) *Bar_ListAndEnum_Args

	// IsException returns true if the given error can be thrown
	// by listAndEnum.
	//
	// An error can be thrown by listAndEnum only if the
	// corresponding exception type was mentioned in the 'throws'
	// section for it in the Thrift file.
	IsException func(error) bool

	// WrapResponse returns the result struct for listAndEnum
	// given its return value and error.
	//
	// This allows mapping values and errors returned by
	// listAndEnum into a serializable result struct.
	// WrapResponse returns a non-nil error if the provided
	// error cannot be thrown by listAndEnum
	//
	//   value, err := listAndEnum(args)
	//   result, err := Bar_ListAndEnum_Helper.WrapResponse(value, err)
	//   if err != nil {
	//     return fmt.Errorf("unexpected error from listAndEnum: %v", err)
	//   }
	//   serialize(result)
	WrapResponse func(string, error) (*Bar_ListAndEnum_Result, error)

	// UnwrapResponse takes the result struct for listAndEnum
	// and returns the value or error returned by it.
	//
	// The error is non-nil only if listAndEnum threw an
	// exception.
	//
	//   result := deserialize(bytes)
	//   value, err := Bar_ListAndEnum_Helper.UnwrapResponse(result)
	UnwrapResponse func(*Bar_ListAndEnum_Result) (string, error)
}{}

func init() {
	Bar_ListAndEnum_Helper.Args = func(
		demoIds []string,
		demoType *DemoType,
		demos []DemoType,
	) *Bar_ListAndEnum_Args {
		return &Bar_ListAndEnum_Args{
			DemoIds:  demoIds,
			DemoType: demoType,
			Demos:    demos,
		}
	}

	Bar_ListAndEnum_Helper.IsException = func(err error) bool {
		switch err.(type) {
		case *BarException:
			return true
		default:
			return false
		}
	}

	Bar_ListAndEnum_Helper.WrapResponse = func(success string, err error) (*Bar_ListAndEnum_Result, error) {
		if err == nil {
			return &Bar_ListAndEnum_Result{Success: &success}, nil
		}

		switch e := err.(type) {
		case *BarException:
			if e == nil {
				return nil, errors.New("WrapResponse received non-nil error type with nil value for Bar_ListAndEnum_Result.BarException")
			}
			return &Bar_ListAndEnum_Result{BarException: e}, nil
		}

		return nil, err
	}
	Bar_ListAndEnum_Helper.UnwrapResponse = func(result *Bar_ListAndEnum_Result) (success string, err error) {
		if result.BarException != nil {
			err = result.BarException
			return
		}

		if result.Success != nil {
			success = *result.Success
			return
		}

		err = errors.New("expected a non-void result")
		return
	}

}

// Bar_ListAndEnum_Result represents the result of a Bar.listAndEnum function call.
//
// The result of a listAndEnum execution is sent and received over the wire as this struct.
//
// Success is set only if the function did not throw an exception.
type Bar_ListAndEnum_Result struct {
	// Value returned by listAndEnum after a successful execution.
	Success      *string       `json:"success,omitempty"`
	BarException *BarException `json:"barException,omitempty"`
}

// ToWire translates a Bar_ListAndEnum_Result struct into a Thrift-level intermediate
// representation. This intermediate representation may be serialized
// into bytes using a ThriftRW protocol implementation.
//
// An error is returned if the struct or any of its fields failed to
// validate.
//
//   x, err := v.ToWire()
//   if err != nil {
//     return err
//   }
//
//   if err := binaryProtocol.Encode(x, writer); err != nil {
//     return err
//   }
func (v *Bar_ListAndEnum_Result) ToWire() (wire.Value, error) {
	var (
		fields [2]wire.Field
		i      int = 0
		w      wire.Value
		err    error
	)

	if v.Success != nil {
		w, err = wire.NewValueString(*(v.Success)), error(nil)
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 0, Value: w}
		i++
	}
	if v.BarException != nil {
		w, err = v.BarException.ToWire()
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 1, Value: w}
		i++
	}

	if i != 1 {
		return wire.Value{}, fmt.Errorf("Bar_ListAndEnum_Result should have exactly one field: got %v fields", i)
	}

	return wire.NewValueStruct(wire.Struct{Fields: fields[:i]}), nil
}

// FromWire deserializes a Bar_ListAndEnum_Result struct from its Thrift-level
// representation. The Thrift-level representation may be obtained
// from a ThriftRW protocol implementation.
//
// An error is returned if we were unable to build a Bar_ListAndEnum_Result struct
// from the provided intermediate representation.
//
//   x, err := binaryProtocol.Decode(reader, wire.TStruct)
//   if err != nil {
//     return nil, err
//   }
//
//   var v Bar_ListAndEnum_Result
//   if err := v.FromWire(x); err != nil {
//     return nil, err
//   }
//   return &v, nil
func (v *Bar_ListAndEnum_Result) FromWire(w wire.Value) error {
	var err error

	for _, field := range w.GetStruct().Fields {
		switch field.ID {
		case 0:
			if field.Value.Type() == wire.TBinary {
				var x string
				x, err = field.Value.GetString(), error(nil)
				v.Success = &x
				if err != nil {
					return err
				}

			}
		case 1:
			if field.Value.Type() == wire.TStruct {
				v.BarException, err = _BarException_Read(field.Value)
				if err != nil {
					return err
				}

			}
		}
	}

	count := 0
	if v.Success != nil {
		count++
	}
	if v.BarException != nil {
		count++
	}
	if count != 1 {
		return fmt.Errorf("Bar_ListAndEnum_Result should have exactly one field: got %v fields", count)
	}

	return nil
}

// String returns a readable string representation of a Bar_ListAndEnum_Result
// struct.
func (v *Bar_ListAndEnum_Result) String() string {
	if v == nil {
		return "<nil>"
	}

	var fields [2]string
	i := 0
	if v.Success != nil {
		fields[i] = fmt.Sprintf("Success: %v", *(v.Success))
		i++
	}
	if v.BarException != nil {
		fields[i] = fmt.Sprintf("BarException: %v", v.BarException)
		i++
	}

	return fmt.Sprintf("Bar_ListAndEnum_Result{%v}", strings.Join(fields[:i], ", "))
}

// Equals returns true if all the fields of this Bar_ListAndEnum_Result match the
// provided Bar_ListAndEnum_Result.
//
// This function performs a deep comparison.
func (v *Bar_ListAndEnum_Result) Equals(rhs *Bar_ListAndEnum_Result) bool {
	if v == nil {
		return rhs == nil
	} else if rhs == nil {
		return false
	}
	if !_String_EqualsPtr(v.Success, rhs.Success) {
		return false
	}
	if !((v.BarException == nil && rhs.BarException == nil) || (v.BarException != nil && rhs.BarException != nil && v.BarException.Equals(rhs.BarException))) {
		return false
	}

	return true
}

// MarshalLogObject implements zapcore.ObjectMarshaler, enabling
// fast logging of Bar_ListAndEnum_Result.
func (v *Bar_ListAndEnum_Result) MarshalLogObject(enc zapcore.ObjectEncoder) (err error) {
	if v == nil {
		return nil
	}
	if v.Success != nil {
		enc.AddString("success", *v.Success)
	}
	if v.BarException != nil {
		err = multierr.Append(err, enc.AddObject("barException", v.BarException))
	}
	return err
}

// GetSuccess returns the value of Success if it is set or its
// zero value if it is unset.
func (v *Bar_ListAndEnum_Result) GetSuccess() (o string) {
	if v != nil && v.Success != nil {
		return *v.Success
	}

	return
}

// IsSetSuccess returns true if Success is not nil.
func (v *Bar_ListAndEnum_Result) IsSetSuccess() bool {
	return v != nil && v.Success != nil
}

// GetBarException returns the value of BarException if it is set or its
// zero value if it is unset.
func (v *Bar_ListAndEnum_Result) GetBarException() (o *BarException) {
	if v != nil && v.BarException != nil {
		return v.BarException
	}

	return
}

// IsSetBarException returns true if BarException is not nil.
func (v *Bar_ListAndEnum_Result) IsSetBarException() bool {
	return v != nil && v.BarException != nil
}

// MethodName returns the name of the Thrift function as specified in
// the IDL, for which this struct represent the result.
//
// This will always be "listAndEnum" for this struct.
func (v *Bar_ListAndEnum_Result) MethodName() string {
	return "listAndEnum"
}

// EnvelopeType returns the kind of value inside this struct.
//
// This will always be Reply for this struct.
func (v *Bar_ListAndEnum_Result) EnvelopeType() wire.EnvelopeType {
	return wire.Reply
}

// Bar_MissingArg_Args represents the arguments for the Bar.missingArg function.
//
// The arguments for missingArg are sent and received over the wire as this struct.
type Bar_MissingArg_Args struct {
}

// ToWire translates a Bar_MissingArg_Args struct into a Thrift-level intermediate
// representation. This intermediate representation may be serialized
// into bytes using a ThriftRW protocol implementation.
//
// An error is returned if the struct or any of its fields failed to
// validate.
//
//   x, err := v.ToWire()
//   if err != nil {
//     return err
//   }
//
//   if err := binaryProtocol.Encode(x, writer); err != nil {
//     return err
//   }
func (v *Bar_MissingArg_Args) ToWire() (wire.Value, error) {
	var (
		fields [0]wire.Field
		i      int = 0
	)

	return wire.NewValueStruct(wire.Struct{Fields: fields[:i]}), nil
}

// FromWire deserializes a Bar_MissingArg_Args struct from its Thrift-level
// representation. The Thrift-level representation may be obtained
// from a ThriftRW protocol implementation.
//
// An error is returned if we were unable to build a Bar_MissingArg_Args struct
// from the provided intermediate representation.
//
//   x, err := binaryProtocol.Decode(reader, wire.TStruct)
//   if err != nil {
//     return nil, err
//   }
//
//   var v Bar_MissingArg_Args
//   if err := v.FromWire(x); err != nil {
//     return nil, err
//   }
//   return &v, nil
func (v *Bar_MissingArg_Args) FromWire(w wire.Value) error {

	for _, field := range w.GetStruct().Fields {
		switch field.ID {
		}
	}

	return nil
}

// String returns a readable string representation of a Bar_MissingArg_Args
// struct.
func (v *Bar_MissingArg_Args) String() string {
	if v == nil {
		return "<nil>"
	}

	var fields [0]string
	i := 0

	return fmt.Sprintf("Bar_MissingArg_Args{%v}", strings.Join(fields[:i], ", "))
}

// Equals returns true if all the fields of this Bar_MissingArg_Args match the
// provided Bar_MissingArg_Args.
//
// This function performs a deep comparison.
func (v *Bar_MissingArg_Args) Equals(rhs *Bar_MissingArg_Args) bool {
	if v == nil {
		return rhs == nil
	} else if rhs == nil {
		return false
	}

	return true
}

// MarshalLogObject implements zapcore.ObjectMarshaler, enabling
// fast logging of Bar_MissingArg_Args.
func (v *Bar_MissingArg_Args) MarshalLogObject(enc zapcore.ObjectEncoder) (err error) {
	if v == nil {
		return nil
	}
	return err
}

// MethodName returns the name of the Thrift function as specified in
// the IDL, for which this struct represent the arguments.
//
// This will always be "missingArg" for this struct.
func (v *Bar_MissingArg_Args) MethodName() string {
	return "missingArg"
}

// EnvelopeType returns the kind of value inside this struct.
//
// This will always be Call for this struct.
func (v *Bar_MissingArg_Args) EnvelopeType() wire.EnvelopeType {
	return wire.Call
}

// Bar_MissingArg_Helper provides functions that aid in handling the
// parameters and return values of the Bar.missingArg
// function.
var Bar_MissingArg_Helper = struct {
	// Args accepts the parameters of missingArg in-order and returns
	// the arguments struct for the function.
	Args func() *Bar_MissingArg_Args

	// IsException returns true if the given error can be thrown
	// by missingArg.
	//
	// An error can be thrown by missingArg only if the
	// corresponding exception type was mentioned in the 'throws'
	// section for it in the Thrift file.
	IsException func(error) bool

	// WrapResponse returns the result struct for missingArg
	// given its return value and error.
	//
	// This allows mapping values and errors returned by
	// missingArg into a serializable result struct.
	// WrapResponse returns a non-nil error if the provided
	// error cannot be thrown by missingArg
	//
	//   value, err := missingArg(args)
	//   result, err := Bar_MissingArg_Helper.WrapResponse(value, err)
	//   if err != nil {
	//     return fmt.Errorf("unexpected error from missingArg: %v", err)
	//   }
	//   serialize(result)
	WrapResponse func(*BarResponse, error) (*Bar_MissingArg_Result, error)

	// UnwrapResponse takes the result struct for missingArg
	// and returns the value or error returned by it.
	//
	// The error is non-nil only if missingArg threw an
	// exception.
	//
	//   result := deserialize(bytes)
	//   value, err := Bar_MissingArg_Helper.UnwrapResponse(result)
	UnwrapResponse func(*Bar_MissingArg_Result) (*BarResponse, error)
}{}

func init() {
	Bar_MissingArg_Helper.Args = func() *Bar_MissingArg_Args {
		return &Bar_MissingArg_Args{}
	}

	Bar_MissingArg_Helper.IsException = func(err error) bool {
		switch err.(type) {
		case *BarException:
			return true
		default:
			return false
		}
	}

	Bar_MissingArg_Helper.WrapResponse = func(success *BarResponse, err error) (*Bar_MissingArg_Result, error) {
		if err == nil {
			return &Bar_MissingArg_Result{Success: success}, nil
		}

		switch e := err.(type) {
		case *BarException:
			if e == nil {
				return nil, errors.New("WrapResponse received non-nil error type with nil value for Bar_MissingArg_Result.BarException")
			}
			return &Bar_MissingArg_Result{BarException: e}, nil
		}

		return nil, err
	}
	Bar_MissingArg_Helper.UnwrapResponse = func(result *Bar_MissingArg_Result) (success *BarResponse, err error) {
		if result.BarException != nil {
			err = result.BarException
			return
		}

		if result.Success != nil {
			success = result.Success
			return
		}

		err = errors.New("expected a non-void result")
		return
	}

}

// Bar_MissingArg_Result represents the result of a Bar.missingArg function call.
//
// The result of a missingArg execution is sent and received over the wire as this struct.
//
// Success is set only if the function did not throw an exception.
type Bar_MissingArg_Result struct {
	// Value returned by missingArg after a successful execution.
	Success      *BarResponse  `json:"success,omitempty"`
	BarException *BarException `json:"barException,omitempty"`
}

// ToWire translates a Bar_MissingArg_Result struct into a Thrift-level intermediate
// representation. This intermediate representation may be serialized
// into bytes using a ThriftRW protocol implementation.
//
// An error is returned if the struct or any of its fields failed to
// validate.
//
//   x, err := v.ToWire()
//   if err != nil {
//     return err
//   }
//
//   if err := binaryProtocol.Encode(x, writer); err != nil {
//     return err
//   }
func (v *Bar_MissingArg_Result) ToWire() (wire.Value, error) {
	var (
		fields [2]wire.Field
		i      int = 0
		w      wire.Value
		err    error
	)

	if v.Success != nil {
		w, err = v.Success.ToWire()
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 0, Value: w}
		i++
	}
	if v.BarException != nil {
		w, err = v.BarException.ToWire()
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 1, Value: w}
		i++
	}

	if i != 1 {
		return wire.Value{}, fmt.Errorf("Bar_MissingArg_Result should have exactly one field: got %v fields", i)
	}

	return wire.NewValueStruct(wire.Struct{Fields: fields[:i]}), nil
}

// FromWire deserializes a Bar_MissingArg_Result struct from its Thrift-level
// representation. The Thrift-level representation may be obtained
// from a ThriftRW protocol implementation.
//
// An error is returned if we were unable to build a Bar_MissingArg_Result struct
// from the provided intermediate representation.
//
//   x, err := binaryProtocol.Decode(reader, wire.TStruct)
//   if err != nil {
//     return nil, err
//   }
//
//   var v Bar_MissingArg_Result
//   if err := v.FromWire(x); err != nil {
//     return nil, err
//   }
//   return &v, nil
func (v *Bar_MissingArg_Result) FromWire(w wire.Value) error {
	var err error

	for _, field := range w.GetStruct().Fields {
		switch field.ID {
		case 0:
			if field.Value.Type() == wire.TStruct {
				v.Success, err = _BarResponse_Read(field.Value)
				if err != nil {
					return err
				}

			}
		case 1:
			if field.Value.Type() == wire.TStruct {
				v.BarException, err = _BarException_Read(field.Value)
				if err != nil {
					return err
				}

			}
		}
	}

	count := 0
	if v.Success != nil {
		count++
	}
	if v.BarException != nil {
		count++
	}
	if count != 1 {
		return fmt.Errorf("Bar_MissingArg_Result should have exactly one field: got %v fields", count)
	}

	return nil
}

// String returns a readable string representation of a Bar_MissingArg_Result
// struct.
func (v *Bar_MissingArg_Result) String() string {
	if v == nil {
		return "<nil>"
	}

	var fields [2]string
	i := 0
	if v.Success != nil {
		fields[i] = fmt.Sprintf("Success: %v", v.Success)
		i++
	}
	if v.BarException != nil {
		fields[i] = fmt.Sprintf("BarException: %v", v.BarException)
		i++
	}

	return fmt.Sprintf("Bar_MissingArg_Result{%v}", strings.Join(fields[:i], ", "))
}

// Equals returns true if all the fields of this Bar_MissingArg_Result match the
// provided Bar_MissingArg_Result.
//
// This function performs a deep comparison.
func (v *Bar_MissingArg_Result) Equals(rhs *Bar_MissingArg_Result) bool {
	if v == nil {
		return rhs == nil
	} else if rhs == nil {
		return false
	}
	if !((v.Success == nil && rhs.Success == nil) || (v.Success != nil && rhs.Success != nil && v.Success.Equals(rhs.Success))) {
		return false
	}
	if !((v.BarException == nil && rhs.BarException == nil) || (v.BarException != nil && rhs.BarException != nil && v.BarException.Equals(rhs.BarException))) {
		return false
	}

	return true
}

// MarshalLogObject implements zapcore.ObjectMarshaler, enabling
// fast logging of Bar_MissingArg_Result.
func (v *Bar_MissingArg_Result) MarshalLogObject(enc zapcore.ObjectEncoder) (err error) {
	if v == nil {
		return nil
	}
	if v.Success != nil {
		err = multierr.Append(err, enc.AddObject("success", v.Success))
	}
	if v.BarException != nil {
		err = multierr.Append(err, enc.AddObject("barException", v.BarException))
	}
	return err
}

// GetSuccess returns the value of Success if it is set or its
// zero value if it is unset.
func (v *Bar_MissingArg_Result) GetSuccess() (o *BarResponse) {
	if v != nil && v.Success != nil {
		return v.Success
	}

	return
}

// IsSetSuccess returns true if Success is not nil.
func (v *Bar_MissingArg_Result) IsSetSuccess() bool {
	return v != nil && v.Success != nil
}

// GetBarException returns the value of BarException if it is set or its
// zero value if it is unset.
func (v *Bar_MissingArg_Result) GetBarException() (o *BarException) {
	if v != nil && v.BarException != nil {
		return v.BarException
	}

	return
}

// IsSetBarException returns true if BarException is not nil.
func (v *Bar_MissingArg_Result) IsSetBarException() bool {
	return v != nil && v.BarException != nil
}

// MethodName returns the name of the Thrift function as specified in
// the IDL, for which this struct represent the result.
//
// This will always be "missingArg" for this struct.
func (v *Bar_MissingArg_Result) MethodName() string {
	return "missingArg"
}

// EnvelopeType returns the kind of value inside this struct.
//
// This will always be Reply for this struct.
func (v *Bar_MissingArg_Result) EnvelopeType() wire.EnvelopeType {
	return wire.Reply
}

// Bar_NoRequest_Args represents the arguments for the Bar.noRequest function.
//
// The arguments for noRequest are sent and received over the wire as this struct.
type Bar_NoRequest_Args struct {
}

// ToWire translates a Bar_NoRequest_Args struct into a Thrift-level intermediate
// representation. This intermediate representation may be serialized
// into bytes using a ThriftRW protocol implementation.
//
// An error is returned if the struct or any of its fields failed to
// validate.
//
//   x, err := v.ToWire()
//   if err != nil {
//     return err
//   }
//
//   if err := binaryProtocol.Encode(x, writer); err != nil {
//     return err
//   }
func (v *Bar_NoRequest_Args) ToWire() (wire.Value, error) {
	var (
		fields [0]wire.Field
		i      int = 0
	)

	return wire.NewValueStruct(wire.Struct{Fields: fields[:i]}), nil
}

// FromWire deserializes a Bar_NoRequest_Args struct from its Thrift-level
// representation. The Thrift-level representation may be obtained
// from a ThriftRW protocol implementation.
//
// An error is returned if we were unable to build a Bar_NoRequest_Args struct
// from the provided intermediate representation.
//
//   x, err := binaryProtocol.Decode(reader, wire.TStruct)
//   if err != nil {
//     return nil, err
//   }
//
//   var v Bar_NoRequest_Args
//   if err := v.FromWire(x); err != nil {
//     return nil, err
//   }
//   return &v, nil
func (v *Bar_NoRequest_Args) FromWire(w wire.Value) error {

	for _, field := range w.GetStruct().Fields {
		switch field.ID {
		}
	}

	return nil
}

// String returns a readable string representation of a Bar_NoRequest_Args
// struct.
func (v *Bar_NoRequest_Args) String() string {
	if v == nil {
		return "<nil>"
	}

	var fields [0]string
	i := 0

	return fmt.Sprintf("Bar_NoRequest_Args{%v}", strings.Join(fields[:i], ", "))
}

// Equals returns true if all the fields of this Bar_NoRequest_Args match the
// provided Bar_NoRequest_Args.
//
// This function performs a deep comparison.
func (v *Bar_NoRequest_Args) Equals(rhs *Bar_NoRequest_Args) bool {
	if v == nil {
		return rhs == nil
	} else if rhs == nil {
		return false
	}

	return true
}

// MarshalLogObject implements zapcore.ObjectMarshaler, enabling
// fast logging of Bar_NoRequest_Args.
func (v *Bar_NoRequest_Args) MarshalLogObject(enc zapcore.ObjectEncoder) (err error) {
	if v == nil {
		return nil
	}
	return err
}

// MethodName returns the name of the Thrift function as specified in
// the IDL, for which this struct represent the arguments.
//
// This will always be "noRequest" for this struct.
func (v *Bar_NoRequest_Args) MethodName() string {
	return "noRequest"
}

// EnvelopeType returns the kind of value inside this struct.
//
// This will always be Call for this struct.
func (v *Bar_NoRequest_Args) EnvelopeType() wire.EnvelopeType {
	return wire.Call
}

// Bar_NoRequest_Helper provides functions that aid in handling the
// parameters and return values of the Bar.noRequest
// function.
var Bar_NoRequest_Helper = struct {
	// Args accepts the parameters of noRequest in-order and returns
	// the arguments struct for the function.
	Args func() *Bar_NoRequest_Args

	// IsException returns true if the given error can be thrown
	// by noRequest.
	//
	// An error can be thrown by noRequest only if the
	// corresponding exception type was mentioned in the 'throws'
	// section for it in the Thrift file.
	IsException func(error) bool

	// WrapResponse returns the result struct for noRequest
	// given its return value and error.
	//
	// This allows mapping values and errors returned by
	// noRequest into a serializable result struct.
	// WrapResponse returns a non-nil error if the provided
	// error cannot be thrown by noRequest
	//
	//   value, err := noRequest(args)
	//   result, err := Bar_NoRequest_Helper.WrapResponse(value, err)
	//   if err != nil {
	//     return fmt.Errorf("unexpected error from noRequest: %v", err)
	//   }
	//   serialize(result)
	WrapResponse func(*BarResponse, error) (*Bar_NoRequest_Result, error)

	// UnwrapResponse takes the result struct for noRequest
	// and returns the value or error returned by it.
	//
	// The error is non-nil only if noRequest threw an
	// exception.
	//
	//   result := deserialize(bytes)
	//   value, err := Bar_NoRequest_Helper.UnwrapResponse(result)
	UnwrapResponse func(*Bar_NoRequest_Result) (*BarResponse, error)
}{}

func init() {
	Bar_NoRequest_Helper.Args = func() *Bar_NoRequest_Args {
		return &Bar_NoRequest_Args{}
	}

	Bar_NoRequest_Helper.IsException = func(err error) bool {
		switch err.(type) {
		case *BarException:
			return true
		default:
			return false
		}
	}

	Bar_NoRequest_Helper.WrapResponse = func(success *BarResponse, err error) (*Bar_NoRequest_Result, error) {
		if err == nil {
			return &Bar_NoRequest_Result{Success: success}, nil
		}

		switch e := err.(type) {
		case *BarException:
			if e == nil {
				return nil, errors.New("WrapResponse received non-nil error type with nil value for Bar_NoRequest_Result.BarException")
			}
			return &Bar_NoRequest_Result{BarException: e}, nil
		}

		return nil, err
	}
	Bar_NoRequest_Helper.UnwrapResponse = func(result *Bar_NoRequest_Result) (success *BarResponse, err error) {
		if result.BarException != nil {
			err = result.BarException
			return
		}

		if result.Success != nil {
			success = result.Success
			return
		}

		err = errors.New("expected a non-void result")
		return
	}

}

// Bar_NoRequest_Result represents the result of a Bar.noRequest function call.
//
// The result of a noRequest execution is sent and received over the wire as this struct.
//
// Success is set only if the function did not throw an exception.
type Bar_NoRequest_Result struct {
	// Value returned by noRequest after a successful execution.
	Success      *BarResponse  `json:"success,omitempty"`
	BarException *BarException `json:"barException,omitempty"`
}

// ToWire translates a Bar_NoRequest_Result struct into a Thrift-level intermediate
// representation. This intermediate representation may be serialized
// into bytes using a ThriftRW protocol implementation.
//
// An error is returned if the struct or any of its fields failed to
// validate.
//
//   x, err := v.ToWire()
//   if err != nil {
//     return err
//   }
//
//   if err := binaryProtocol.Encode(x, writer); err != nil {
//     return err
//   }
func (v *Bar_NoRequest_Result) ToWire() (wire.Value, error) {
	var (
		fields [2]wire.Field
		i      int = 0
		w      wire.Value
		err    error
	)

	if v.Success != nil {
		w, err = v.Success.ToWire()
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 0, Value: w}
		i++
	}
	if v.BarException != nil {
		w, err = v.BarException.ToWire()
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 1, Value: w}
		i++
	}

	if i != 1 {
		return wire.Value{}, fmt.Errorf("Bar_NoRequest_Result should have exactly one field: got %v fields", i)
	}

	return wire.NewValueStruct(wire.Struct{Fields: fields[:i]}), nil
}

// FromWire deserializes a Bar_NoRequest_Result struct from its Thrift-level
// representation. The Thrift-level representation may be obtained
// from a ThriftRW protocol implementation.
//
// An error is returned if we were unable to build a Bar_NoRequest_Result struct
// from the provided intermediate representation.
//
//   x, err := binaryProtocol.Decode(reader, wire.TStruct)
//   if err != nil {
//     return nil, err
//   }
//
//   var v Bar_NoRequest_Result
//   if err := v.FromWire(x); err != nil {
//     return nil, err
//   }
//   return &v, nil
func (v *Bar_NoRequest_Result) FromWire(w wire.Value) error {
	var err error

	for _, field := range w.GetStruct().Fields {
		switch field.ID {
		case 0:
			if field.Value.Type() == wire.TStruct {
				v.Success, err = _BarResponse_Read(field.Value)
				if err != nil {
					return err
				}

			}
		case 1:
			if field.Value.Type() == wire.TStruct {
				v.BarException, err = _BarException_Read(field.Value)
				if err != nil {
					return err
				}

			}
		}
	}

	count := 0
	if v.Success != nil {
		count++
	}
	if v.BarException != nil {
		count++
	}
	if count != 1 {
		return fmt.Errorf("Bar_NoRequest_Result should have exactly one field: got %v fields", count)
	}

	return nil
}

// String returns a readable string representation of a Bar_NoRequest_Result
// struct.
func (v *Bar_NoRequest_Result) String() string {
	if v == nil {
		return "<nil>"
	}

	var fields [2]string
	i := 0
	if v.Success != nil {
		fields[i] = fmt.Sprintf("Success: %v", v.Success)
		i++
	}
	if v.BarException != nil {
		fields[i] = fmt.Sprintf("BarException: %v", v.BarException)
		i++
	}

	return fmt.Sprintf("Bar_NoRequest_Result{%v}", strings.Join(fields[:i], ", "))
}

// Equals returns true if all the fields of this Bar_NoRequest_Result match the
// provided Bar_NoRequest_Result.
//
// This function performs a deep comparison.
func (v *Bar_NoRequest_Result) Equals(rhs *Bar_NoRequest_Result) bool {
	if v == nil {
		return rhs == nil
	} else if rhs == nil {
		return false
	}
	if !((v.Success == nil && rhs.Success == nil) || (v.Success != nil && rhs.Success != nil && v.Success.Equals(rhs.Success))) {
		return false
	}
	if !((v.BarException == nil && rhs.BarException == nil) || (v.BarException != nil && rhs.BarException != nil && v.BarException.Equals(rhs.BarException))) {
		return false
	}

	return true
}

// MarshalLogObject implements zapcore.ObjectMarshaler, enabling
// fast logging of Bar_NoRequest_Result.
func (v *Bar_NoRequest_Result) MarshalLogObject(enc zapcore.ObjectEncoder) (err error) {
	if v == nil {
		return nil
	}
	if v.Success != nil {
		err = multierr.Append(err, enc.AddObject("success", v.Success))
	}
	if v.BarException != nil {
		err = multierr.Append(err, enc.AddObject("barException", v.BarException))
	}
	return err
}

// GetSuccess returns the value of Success if it is set or its
// zero value if it is unset.
func (v *Bar_NoRequest_Result) GetSuccess() (o *BarResponse) {
	if v != nil && v.Success != nil {
		return v.Success
	}

	return
}

// IsSetSuccess returns true if Success is not nil.
func (v *Bar_NoRequest_Result) IsSetSuccess() bool {
	return v != nil && v.Success != nil
}

// GetBarException returns the value of BarException if it is set or its
// zero value if it is unset.
func (v *Bar_NoRequest_Result) GetBarException() (o *BarException) {
	if v != nil && v.BarException != nil {
		return v.BarException
	}

	return
}

// IsSetBarException returns true if BarException is not nil.
func (v *Bar_NoRequest_Result) IsSetBarException() bool {
	return v != nil && v.BarException != nil
}

// MethodName returns the name of the Thrift function as specified in
// the IDL, for which this struct represent the result.
//
// This will always be "noRequest" for this struct.
func (v *Bar_NoRequest_Result) MethodName() string {
	return "noRequest"
}

// EnvelopeType returns the kind of value inside this struct.
//
// This will always be Reply for this struct.
func (v *Bar_NoRequest_Result) EnvelopeType() wire.EnvelopeType {
	return wire.Reply
}

// Bar_Normal_Args represents the arguments for the Bar.normal function.
//
// The arguments for normal are sent and received over the wire as this struct.
type Bar_Normal_Args struct {
	Request *BarRequest `json:"request,required"`
}

// ToWire translates a Bar_Normal_Args struct into a Thrift-level intermediate
// representation. This intermediate representation may be serialized
// into bytes using a ThriftRW protocol implementation.
//
// An error is returned if the struct or any of its fields failed to
// validate.
//
//   x, err := v.ToWire()
//   if err != nil {
//     return err
//   }
//
//   if err := binaryProtocol.Encode(x, writer); err != nil {
//     return err
//   }
func (v *Bar_Normal_Args) ToWire() (wire.Value, error) {
	var (
		fields [1]wire.Field
		i      int = 0
		w      wire.Value
		err    error
	)

	if v.Request == nil {
		return w, errors.New("field Request of Bar_Normal_Args is required")
	}
	w, err = v.Request.ToWire()
	if err != nil {
		return w, err
	}
	fields[i] = wire.Field{ID: 1, Value: w}
	i++

	return wire.NewValueStruct(wire.Struct{Fields: fields[:i]}), nil
}

// FromWire deserializes a Bar_Normal_Args struct from its Thrift-level
// representation. The Thrift-level representation may be obtained
// from a ThriftRW protocol implementation.
//
// An error is returned if we were unable to build a Bar_Normal_Args struct
// from the provided intermediate representation.
//
//   x, err := binaryProtocol.Decode(reader, wire.TStruct)
//   if err != nil {
//     return nil, err
//   }
//
//   var v Bar_Normal_Args
//   if err := v.FromWire(x); err != nil {
//     return nil, err
//   }
//   return &v, nil
func (v *Bar_Normal_Args) FromWire(w wire.Value) error {
	var err error

	requestIsSet := false

	for _, field := range w.GetStruct().Fields {
		switch field.ID {
		case 1:
			if field.Value.Type() == wire.TStruct {
				v.Request, err = _BarRequest_Read(field.Value)
				if err != nil {
					return err
				}
				requestIsSet = true
			}
		}
	}

	if !requestIsSet {
		return errors.New("field Request of Bar_Normal_Args is required")
	}

	return nil
}

// String returns a readable string representation of a Bar_Normal_Args
// struct.
func (v *Bar_Normal_Args) String() string {
	if v == nil {
		return "<nil>"
	}

	var fields [1]string
	i := 0
	fields[i] = fmt.Sprintf("Request: %v", v.Request)
	i++

	return fmt.Sprintf("Bar_Normal_Args{%v}", strings.Join(fields[:i], ", "))
}

// Equals returns true if all the fields of this Bar_Normal_Args match the
// provided Bar_Normal_Args.
//
// This function performs a deep comparison.
func (v *Bar_Normal_Args) Equals(rhs *Bar_Normal_Args) bool {
	if v == nil {
		return rhs == nil
	} else if rhs == nil {
		return false
	}
	if !v.Request.Equals(rhs.Request) {
		return false
	}

	return true
}

// MarshalLogObject implements zapcore.ObjectMarshaler, enabling
// fast logging of Bar_Normal_Args.
func (v *Bar_Normal_Args) MarshalLogObject(enc zapcore.ObjectEncoder) (err error) {
	if v == nil {
		return nil
	}
	err = multierr.Append(err, enc.AddObject("request", v.Request))
	return err
}

// GetRequest returns the value of Request if it is set or its
// zero value if it is unset.
func (v *Bar_Normal_Args) GetRequest() (o *BarRequest) {
	if v != nil {
		o = v.Request
	}
	return
}

// IsSetRequest returns true if Request is not nil.
func (v *Bar_Normal_Args) IsSetRequest() bool {
	return v != nil && v.Request != nil
}

// MethodName returns the name of the Thrift function as specified in
// the IDL, for which this struct represent the arguments.
//
// This will always be "normal" for this struct.
func (v *Bar_Normal_Args) MethodName() string {
	return "normal"
}

// EnvelopeType returns the kind of value inside this struct.
//
// This will always be Call for this struct.
func (v *Bar_Normal_Args) EnvelopeType() wire.EnvelopeType {
	return wire.Call
}

// Bar_Normal_Helper provides functions that aid in handling the
// parameters and return values of the Bar.normal
// function.
var Bar_Normal_Helper = struct {
	// Args accepts the parameters of normal in-order and returns
	// the arguments struct for the function.
	Args func(
		request *BarRequest,
	) *Bar_Normal_Args

	// IsException returns true if the given error can be thrown
	// by normal.
	//
	// An error can be thrown by normal only if the
	// corresponding exception type was mentioned in the 'throws'
	// section for it in the Thrift file.
	IsException func(error) bool

	// WrapResponse returns the result struct for normal
	// given its return value and error.
	//
	// This allows mapping values and errors returned by
	// normal into a serializable result struct.
	// WrapResponse returns a non-nil error if the provided
	// error cannot be thrown by normal
	//
	//   value, err := normal(args)
	//   result, err := Bar_Normal_Helper.WrapResponse(value, err)
	//   if err != nil {
	//     return fmt.Errorf("unexpected error from normal: %v", err)
	//   }
	//   serialize(result)
	WrapResponse func(*BarResponse, error) (*Bar_Normal_Result, error)

	// UnwrapResponse takes the result struct for normal
	// and returns the value or error returned by it.
	//
	// The error is non-nil only if normal threw an
	// exception.
	//
	//   result := deserialize(bytes)
	//   value, err := Bar_Normal_Helper.UnwrapResponse(result)
	UnwrapResponse func(*Bar_Normal_Result) (*BarResponse, error)
}{}

func init() {
	Bar_Normal_Helper.Args = func(
		request *BarRequest,
	) *Bar_Normal_Args {
		return &Bar_Normal_Args{
			Request: request,
		}
	}

	Bar_Normal_Helper.IsException = func(err error) bool {
		switch err.(type) {
		case *BarException:
			return true
		default:
			return false
		}
	}

	Bar_Normal_Helper.WrapResponse = func(success *BarResponse, err error) (*Bar_Normal_Result, error) {
		if err == nil {
			return &Bar_Normal_Result{Success: success}, nil
		}

		switch e := err.(type) {
		case *BarException:
			if e == nil {
				return nil, errors.New("WrapResponse received non-nil error type with nil value for Bar_Normal_Result.BarException")
			}
			return &Bar_Normal_Result{BarException: e}, nil
		}

		return nil, err
	}
	Bar_Normal_Helper.UnwrapResponse = func(result *Bar_Normal_Result) (success *BarResponse, err error) {
		if result.BarException != nil {
			err = result.BarException
			return
		}

		if result.Success != nil {
			success = result.Success
			return
		}

		err = errors.New("expected a non-void result")
		return
	}

}

// Bar_Normal_Result represents the result of a Bar.normal function call.
//
// The result of a normal execution is sent and received over the wire as this struct.
//
// Success is set only if the function did not throw an exception.
type Bar_Normal_Result struct {
	// Value returned by normal after a successful execution.
	Success      *BarResponse  `json:"success,omitempty"`
	BarException *BarException `json:"barException,omitempty"`
}

// ToWire translates a Bar_Normal_Result struct into a Thrift-level intermediate
// representation. This intermediate representation may be serialized
// into bytes using a ThriftRW protocol implementation.
//
// An error is returned if the struct or any of its fields failed to
// validate.
//
//   x, err := v.ToWire()
//   if err != nil {
//     return err
//   }
//
//   if err := binaryProtocol.Encode(x, writer); err != nil {
//     return err
//   }
func (v *Bar_Normal_Result) ToWire() (wire.Value, error) {
	var (
		fields [2]wire.Field
		i      int = 0
		w      wire.Value
		err    error
	)

	if v.Success != nil {
		w, err = v.Success.ToWire()
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 0, Value: w}
		i++
	}
	if v.BarException != nil {
		w, err = v.BarException.ToWire()
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 1, Value: w}
		i++
	}

	if i != 1 {
		return wire.Value{}, fmt.Errorf("Bar_Normal_Result should have exactly one field: got %v fields", i)
	}

	return wire.NewValueStruct(wire.Struct{Fields: fields[:i]}), nil
}

// FromWire deserializes a Bar_Normal_Result struct from its Thrift-level
// representation. The Thrift-level representation may be obtained
// from a ThriftRW protocol implementation.
//
// An error is returned if we were unable to build a Bar_Normal_Result struct
// from the provided intermediate representation.
//
//   x, err := binaryProtocol.Decode(reader, wire.TStruct)
//   if err != nil {
//     return nil, err
//   }
//
//   var v Bar_Normal_Result
//   if err := v.FromWire(x); err != nil {
//     return nil, err
//   }
//   return &v, nil
func (v *Bar_Normal_Result) FromWire(w wire.Value) error {
	var err error

	for _, field := range w.GetStruct().Fields {
		switch field.ID {
		case 0:
			if field.Value.Type() == wire.TStruct {
				v.Success, err = _BarResponse_Read(field.Value)
				if err != nil {
					return err
				}

			}
		case 1:
			if field.Value.Type() == wire.TStruct {
				v.BarException, err = _BarException_Read(field.Value)
				if err != nil {
					return err
				}

			}
		}
	}

	count := 0
	if v.Success != nil {
		count++
	}
	if v.BarException != nil {
		count++
	}
	if count != 1 {
		return fmt.Errorf("Bar_Normal_Result should have exactly one field: got %v fields", count)
	}

	return nil
}

// String returns a readable string representation of a Bar_Normal_Result
// struct.
func (v *Bar_Normal_Result) String() string {
	if v == nil {
		return "<nil>"
	}

	var fields [2]string
	i := 0
	if v.Success != nil {
		fields[i] = fmt.Sprintf("Success: %v", v.Success)
		i++
	}
	if v.BarException != nil {
		fields[i] = fmt.Sprintf("BarException: %v", v.BarException)
		i++
	}

	return fmt.Sprintf("Bar_Normal_Result{%v}", strings.Join(fields[:i], ", "))
}

// Equals returns true if all the fields of this Bar_Normal_Result match the
// provided Bar_Normal_Result.
//
// This function performs a deep comparison.
func (v *Bar_Normal_Result) Equals(rhs *Bar_Normal_Result) bool {
	if v == nil {
		return rhs == nil
	} else if rhs == nil {
		return false
	}
	if !((v.Success == nil && rhs.Success == nil) || (v.Success != nil && rhs.Success != nil && v.Success.Equals(rhs.Success))) {
		return false
	}
	if !((v.BarException == nil && rhs.BarException == nil) || (v.BarException != nil && rhs.BarException != nil && v.BarException.Equals(rhs.BarException))) {
		return false
	}

	return true
}

// MarshalLogObject implements zapcore.ObjectMarshaler, enabling
// fast logging of Bar_Normal_Result.
func (v *Bar_Normal_Result) MarshalLogObject(enc zapcore.ObjectEncoder) (err error) {
	if v == nil {
		return nil
	}
	if v.Success != nil {
		err = multierr.Append(err, enc.AddObject("success", v.Success))
	}
	if v.BarException != nil {
		err = multierr.Append(err, enc.AddObject("barException", v.BarException))
	}
	return err
}

// GetSuccess returns the value of Success if it is set or its
// zero value if it is unset.
func (v *Bar_Normal_Result) GetSuccess() (o *BarResponse) {
	if v != nil && v.Success != nil {
		return v.Success
	}

	return
}

// IsSetSuccess returns true if Success is not nil.
func (v *Bar_Normal_Result) IsSetSuccess() bool {
	return v != nil && v.Success != nil
}

// GetBarException returns the value of BarException if it is set or its
// zero value if it is unset.
func (v *Bar_Normal_Result) GetBarException() (o *BarException) {
	if v != nil && v.BarException != nil {
		return v.BarException
	}

	return
}

// IsSetBarException returns true if BarException is not nil.
func (v *Bar_Normal_Result) IsSetBarException() bool {
	return v != nil && v.BarException != nil
}

// MethodName returns the name of the Thrift function as specified in
// the IDL, for which this struct represent the result.
//
// This will always be "normal" for this struct.
func (v *Bar_Normal_Result) MethodName() string {
	return "normal"
}

// EnvelopeType returns the kind of value inside this struct.
//
// This will always be Reply for this struct.
func (v *Bar_Normal_Result) EnvelopeType() wire.EnvelopeType {
	return wire.Reply
}

// Bar_NormalRecur_Args represents the arguments for the Bar.normalRecur function.
//
// The arguments for normalRecur are sent and received over the wire as this struct.
type Bar_NormalRecur_Args struct {
	Request *BarRequestRecur `json:"request,required"`
}

// ToWire translates a Bar_NormalRecur_Args struct into a Thrift-level intermediate
// representation. This intermediate representation may be serialized
// into bytes using a ThriftRW protocol implementation.
//
// An error is returned if the struct or any of its fields failed to
// validate.
//
//   x, err := v.ToWire()
//   if err != nil {
//     return err
//   }
//
//   if err := binaryProtocol.Encode(x, writer); err != nil {
//     return err
//   }
func (v *Bar_NormalRecur_Args) ToWire() (wire.Value, error) {
	var (
		fields [1]wire.Field
		i      int = 0
		w      wire.Value
		err    error
	)

	if v.Request == nil {
		return w, errors.New("field Request of Bar_NormalRecur_Args is required")
	}
	w, err = v.Request.ToWire()
	if err != nil {
		return w, err
	}
	fields[i] = wire.Field{ID: 1, Value: w}
	i++

	return wire.NewValueStruct(wire.Struct{Fields: fields[:i]}), nil
}

// FromWire deserializes a Bar_NormalRecur_Args struct from its Thrift-level
// representation. The Thrift-level representation may be obtained
// from a ThriftRW protocol implementation.
//
// An error is returned if we were unable to build a Bar_NormalRecur_Args struct
// from the provided intermediate representation.
//
//   x, err := binaryProtocol.Decode(reader, wire.TStruct)
//   if err != nil {
//     return nil, err
//   }
//
//   var v Bar_NormalRecur_Args
//   if err := v.FromWire(x); err != nil {
//     return nil, err
//   }
//   return &v, nil
func (v *Bar_NormalRecur_Args) FromWire(w wire.Value) error {
	var err error

	requestIsSet := false

	for _, field := range w.GetStruct().Fields {
		switch field.ID {
		case 1:
			if field.Value.Type() == wire.TStruct {
				v.Request, err = _BarRequestRecur_Read(field.Value)
				if err != nil {
					return err
				}
				requestIsSet = true
			}
		}
	}

	if !requestIsSet {
		return errors.New("field Request of Bar_NormalRecur_Args is required")
	}

	return nil
}

// String returns a readable string representation of a Bar_NormalRecur_Args
// struct.
func (v *Bar_NormalRecur_Args) String() string {
	if v == nil {
		return "<nil>"
	}

	var fields [1]string
	i := 0
	fields[i] = fmt.Sprintf("Request: %v", v.Request)
	i++

	return fmt.Sprintf("Bar_NormalRecur_Args{%v}", strings.Join(fields[:i], ", "))
}

// Equals returns true if all the fields of this Bar_NormalRecur_Args match the
// provided Bar_NormalRecur_Args.
//
// This function performs a deep comparison.
func (v *Bar_NormalRecur_Args) Equals(rhs *Bar_NormalRecur_Args) bool {
	if v == nil {
		return rhs == nil
	} else if rhs == nil {
		return false
	}
	if !v.Request.Equals(rhs.Request) {
		return false
	}

	return true
}

// MarshalLogObject implements zapcore.ObjectMarshaler, enabling
// fast logging of Bar_NormalRecur_Args.
func (v *Bar_NormalRecur_Args) MarshalLogObject(enc zapcore.ObjectEncoder) (err error) {
	if v == nil {
		return nil
	}
	err = multierr.Append(err, enc.AddObject("request", v.Request))
	return err
}

// GetRequest returns the value of Request if it is set or its
// zero value if it is unset.
func (v *Bar_NormalRecur_Args) GetRequest() (o *BarRequestRecur) {
	if v != nil {
		o = v.Request
	}
	return
}

// IsSetRequest returns true if Request is not nil.
func (v *Bar_NormalRecur_Args) IsSetRequest() bool {
	return v != nil && v.Request != nil
}

// MethodName returns the name of the Thrift function as specified in
// the IDL, for which this struct represent the arguments.
//
// This will always be "normalRecur" for this struct.
func (v *Bar_NormalRecur_Args) MethodName() string {
	return "normalRecur"
}

// EnvelopeType returns the kind of value inside this struct.
//
// This will always be Call for this struct.
func (v *Bar_NormalRecur_Args) EnvelopeType() wire.EnvelopeType {
	return wire.Call
}

// Bar_NormalRecur_Helper provides functions that aid in handling the
// parameters and return values of the Bar.normalRecur
// function.
var Bar_NormalRecur_Helper = struct {
	// Args accepts the parameters of normalRecur in-order and returns
	// the arguments struct for the function.
	Args func(
		request *BarRequestRecur,
	) *Bar_NormalRecur_Args

	// IsException returns true if the given error can be thrown
	// by normalRecur.
	//
	// An error can be thrown by normalRecur only if the
	// corresponding exception type was mentioned in the 'throws'
	// section for it in the Thrift file.
	IsException func(error) bool

	// WrapResponse returns the result struct for normalRecur
	// given its return value and error.
	//
	// This allows mapping values and errors returned by
	// normalRecur into a serializable result struct.
	// WrapResponse returns a non-nil error if the provided
	// error cannot be thrown by normalRecur
	//
	//   value, err := normalRecur(args)
	//   result, err := Bar_NormalRecur_Helper.WrapResponse(value, err)
	//   if err != nil {
	//     return fmt.Errorf("unexpected error from normalRecur: %v", err)
	//   }
	//   serialize(result)
	WrapResponse func(*BarResponseRecur, error) (*Bar_NormalRecur_Result, error)

	// UnwrapResponse takes the result struct for normalRecur
	// and returns the value or error returned by it.
	//
	// The error is non-nil only if normalRecur threw an
	// exception.
	//
	//   result := deserialize(bytes)
	//   value, err := Bar_NormalRecur_Helper.UnwrapResponse(result)
	UnwrapResponse func(*Bar_NormalRecur_Result) (*BarResponseRecur, error)
}{}

func init() {
	Bar_NormalRecur_Helper.Args = func(
		request *BarRequestRecur,
	) *Bar_NormalRecur_Args {
		return &Bar_NormalRecur_Args{
			Request: request,
		}
	}

	Bar_NormalRecur_Helper.IsException = func(err error) bool {
		switch err.(type) {
		case *BarException:
			return true
		default:
			return false
		}
	}

	Bar_NormalRecur_Helper.WrapResponse = func(success *BarResponseRecur, err error) (*Bar_NormalRecur_Result, error) {
		if err == nil {
			return &Bar_NormalRecur_Result{Success: success}, nil
		}

		switch e := err.(type) {
		case *BarException:
			if e == nil {
				return nil, errors.New("WrapResponse received non-nil error type with nil value for Bar_NormalRecur_Result.BarException")
			}
			return &Bar_NormalRecur_Result{BarException: e}, nil
		}

		return nil, err
	}
	Bar_NormalRecur_Helper.UnwrapResponse = func(result *Bar_NormalRecur_Result) (success *BarResponseRecur, err error) {
		if result.BarException != nil {
			err = result.BarException
			return
		}

		if result.Success != nil {
			success = result.Success
			return
		}

		err = errors.New("expected a non-void result")
		return
	}

}

// Bar_NormalRecur_Result represents the result of a Bar.normalRecur function call.
//
// The result of a normalRecur execution is sent and received over the wire as this struct.
//
// Success is set only if the function did not throw an exception.
type Bar_NormalRecur_Result struct {
	// Value returned by normalRecur after a successful execution.
	Success      *BarResponseRecur `json:"success,omitempty"`
	BarException *BarException     `json:"barException,omitempty"`
}

// ToWire translates a Bar_NormalRecur_Result struct into a Thrift-level intermediate
// representation. This intermediate representation may be serialized
// into bytes using a ThriftRW protocol implementation.
//
// An error is returned if the struct or any of its fields failed to
// validate.
//
//   x, err := v.ToWire()
//   if err != nil {
//     return err
//   }
//
//   if err := binaryProtocol.Encode(x, writer); err != nil {
//     return err
//   }
func (v *Bar_NormalRecur_Result) ToWire() (wire.Value, error) {
	var (
		fields [2]wire.Field
		i      int = 0
		w      wire.Value
		err    error
	)

	if v.Success != nil {
		w, err = v.Success.ToWire()
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 0, Value: w}
		i++
	}
	if v.BarException != nil {
		w, err = v.BarException.ToWire()
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 1, Value: w}
		i++
	}

	if i != 1 {
		return wire.Value{}, fmt.Errorf("Bar_NormalRecur_Result should have exactly one field: got %v fields", i)
	}

	return wire.NewValueStruct(wire.Struct{Fields: fields[:i]}), nil
}

func _BarResponseRecur_Read(w wire.Value) (*BarResponseRecur, error) {
	var v BarResponseRecur
	err := v.FromWire(w)
	return &v, err
}

// FromWire deserializes a Bar_NormalRecur_Result struct from its Thrift-level
// representation. The Thrift-level representation may be obtained
// from a ThriftRW protocol implementation.
//
// An error is returned if we were unable to build a Bar_NormalRecur_Result struct
// from the provided intermediate representation.
//
//   x, err := binaryProtocol.Decode(reader, wire.TStruct)
//   if err != nil {
//     return nil, err
//   }
//
//   var v Bar_NormalRecur_Result
//   if err := v.FromWire(x); err != nil {
//     return nil, err
//   }
//   return &v, nil
func (v *Bar_NormalRecur_Result) FromWire(w wire.Value) error {
	var err error

	for _, field := range w.GetStruct().Fields {
		switch field.ID {
		case 0:
			if field.Value.Type() == wire.TStruct {
				v.Success, err = _BarResponseRecur_Read(field.Value)
				if err != nil {
					return err
				}

			}
		case 1:
			if field.Value.Type() == wire.TStruct {
				v.BarException, err = _BarException_Read(field.Value)
				if err != nil {
					return err
				}

			}
		}
	}

	count := 0
	if v.Success != nil {
		count++
	}
	if v.BarException != nil {
		count++
	}
	if count != 1 {
		return fmt.Errorf("Bar_NormalRecur_Result should have exactly one field: got %v fields", count)
	}

	return nil
}

// String returns a readable string representation of a Bar_NormalRecur_Result
// struct.
func (v *Bar_NormalRecur_Result) String() string {
	if v == nil {
		return "<nil>"
	}

	var fields [2]string
	i := 0
	if v.Success != nil {
		fields[i] = fmt.Sprintf("Success: %v", v.Success)
		i++
	}
	if v.BarException != nil {
		fields[i] = fmt.Sprintf("BarException: %v", v.BarException)
		i++
	}

	return fmt.Sprintf("Bar_NormalRecur_Result{%v}", strings.Join(fields[:i], ", "))
}

// Equals returns true if all the fields of this Bar_NormalRecur_Result match the
// provided Bar_NormalRecur_Result.
//
// This function performs a deep comparison.
func (v *Bar_NormalRecur_Result) Equals(rhs *Bar_NormalRecur_Result) bool {
	if v == nil {
		return rhs == nil
	} else if rhs == nil {
		return false
	}
	if !((v.Success == nil && rhs.Success == nil) || (v.Success != nil && rhs.Success != nil && v.Success.Equals(rhs.Success))) {
		return false
	}
	if !((v.BarException == nil && rhs.BarException == nil) || (v.BarException != nil && rhs.BarException != nil && v.BarException.Equals(rhs.BarException))) {
		return false
	}

	return true
}

// MarshalLogObject implements zapcore.ObjectMarshaler, enabling
// fast logging of Bar_NormalRecur_Result.
func (v *Bar_NormalRecur_Result) MarshalLogObject(enc zapcore.ObjectEncoder) (err error) {
	if v == nil {
		return nil
	}
	if v.Success != nil {
		err = multierr.Append(err, enc.AddObject("success", v.Success))
	}
	if v.BarException != nil {
		err = multierr.Append(err, enc.AddObject("barException", v.BarException))
	}
	return err
}

// GetSuccess returns the value of Success if it is set or its
// zero value if it is unset.
func (v *Bar_NormalRecur_Result) GetSuccess() (o *BarResponseRecur) {
	if v != nil && v.Success != nil {
		return v.Success
	}

	return
}

// IsSetSuccess returns true if Success is not nil.
func (v *Bar_NormalRecur_Result) IsSetSuccess() bool {
	return v != nil && v.Success != nil
}

// GetBarException returns the value of BarException if it is set or its
// zero value if it is unset.
func (v *Bar_NormalRecur_Result) GetBarException() (o *BarException) {
	if v != nil && v.BarException != nil {
		return v.BarException
	}

	return
}

// IsSetBarException returns true if BarException is not nil.
func (v *Bar_NormalRecur_Result) IsSetBarException() bool {
	return v != nil && v.BarException != nil
}

// MethodName returns the name of the Thrift function as specified in
// the IDL, for which this struct represent the result.
//
// This will always be "normalRecur" for this struct.
func (v *Bar_NormalRecur_Result) MethodName() string {
	return "normalRecur"
}

// EnvelopeType returns the kind of value inside this struct.
//
// This will always be Reply for this struct.
func (v *Bar_NormalRecur_Result) EnvelopeType() wire.EnvelopeType {
	return wire.Reply
}

// Bar_TooManyArgs_Args represents the arguments for the Bar.tooManyArgs function.
//
// The arguments for tooManyArgs are sent and received over the wire as this struct.
type Bar_TooManyArgs_Args struct {
	Request *BarRequest    `json:"request,required"`
	Foo     *foo.FooStruct `json:"foo,omitempty"`
}

// ToWire translates a Bar_TooManyArgs_Args struct into a Thrift-level intermediate
// representation. This intermediate representation may be serialized
// into bytes using a ThriftRW protocol implementation.
//
// An error is returned if the struct or any of its fields failed to
// validate.
//
//   x, err := v.ToWire()
//   if err != nil {
//     return err
//   }
//
//   if err := binaryProtocol.Encode(x, writer); err != nil {
//     return err
//   }
func (v *Bar_TooManyArgs_Args) ToWire() (wire.Value, error) {
	var (
		fields [2]wire.Field
		i      int = 0
		w      wire.Value
		err    error
	)

	if v.Request == nil {
		return w, errors.New("field Request of Bar_TooManyArgs_Args is required")
	}
	w, err = v.Request.ToWire()
	if err != nil {
		return w, err
	}
	fields[i] = wire.Field{ID: 1, Value: w}
	i++
	if v.Foo != nil {
		w, err = v.Foo.ToWire()
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 2, Value: w}
		i++
	}

	return wire.NewValueStruct(wire.Struct{Fields: fields[:i]}), nil
}

func _FooStruct_Read(w wire.Value) (*foo.FooStruct, error) {
	var v foo.FooStruct
	err := v.FromWire(w)
	return &v, err
}

// FromWire deserializes a Bar_TooManyArgs_Args struct from its Thrift-level
// representation. The Thrift-level representation may be obtained
// from a ThriftRW protocol implementation.
//
// An error is returned if we were unable to build a Bar_TooManyArgs_Args struct
// from the provided intermediate representation.
//
//   x, err := binaryProtocol.Decode(reader, wire.TStruct)
//   if err != nil {
//     return nil, err
//   }
//
//   var v Bar_TooManyArgs_Args
//   if err := v.FromWire(x); err != nil {
//     return nil, err
//   }
//   return &v, nil
func (v *Bar_TooManyArgs_Args) FromWire(w wire.Value) error {
	var err error

	requestIsSet := false

	for _, field := range w.GetStruct().Fields {
		switch field.ID {
		case 1:
			if field.Value.Type() == wire.TStruct {
				v.Request, err = _BarRequest_Read(field.Value)
				if err != nil {
					return err
				}
				requestIsSet = true
			}
		case 2:
			if field.Value.Type() == wire.TStruct {
				v.Foo, err = _FooStruct_Read(field.Value)
				if err != nil {
					return err
				}

			}
		}
	}

	if !requestIsSet {
		return errors.New("field Request of Bar_TooManyArgs_Args is required")
	}

	return nil
}

// String returns a readable string representation of a Bar_TooManyArgs_Args
// struct.
func (v *Bar_TooManyArgs_Args) String() string {
	if v == nil {
		return "<nil>"
	}

	var fields [2]string
	i := 0
	fields[i] = fmt.Sprintf("Request: %v", v.Request)
	i++
	if v.Foo != nil {
		fields[i] = fmt.Sprintf("Foo: %v", v.Foo)
		i++
	}

	return fmt.Sprintf("Bar_TooManyArgs_Args{%v}", strings.Join(fields[:i], ", "))
}

// Equals returns true if all the fields of this Bar_TooManyArgs_Args match the
// provided Bar_TooManyArgs_Args.
//
// This function performs a deep comparison.
func (v *Bar_TooManyArgs_Args) Equals(rhs *Bar_TooManyArgs_Args) bool {
	if v == nil {
		return rhs == nil
	} else if rhs == nil {
		return false
	}
	if !v.Request.Equals(rhs.Request) {
		return false
	}
	if !((v.Foo == nil && rhs.Foo == nil) || (v.Foo != nil && rhs.Foo != nil && v.Foo.Equals(rhs.Foo))) {
		return false
	}

	return true
}

// MarshalLogObject implements zapcore.ObjectMarshaler, enabling
// fast logging of Bar_TooManyArgs_Args.
func (v *Bar_TooManyArgs_Args) MarshalLogObject(enc zapcore.ObjectEncoder) (err error) {
	if v == nil {
		return nil
	}
	err = multierr.Append(err, enc.AddObject("request", v.Request))
	if v.Foo != nil {
		err = multierr.Append(err, enc.AddObject("foo", v.Foo))
	}
	return err
}

// GetRequest returns the value of Request if it is set or its
// zero value if it is unset.
func (v *Bar_TooManyArgs_Args) GetRequest() (o *BarRequest) {
	if v != nil {
		o = v.Request
	}
	return
}

// IsSetRequest returns true if Request is not nil.
func (v *Bar_TooManyArgs_Args) IsSetRequest() bool {
	return v != nil && v.Request != nil
}

// GetFoo returns the value of Foo if it is set or its
// zero value if it is unset.
func (v *Bar_TooManyArgs_Args) GetFoo() (o *foo.FooStruct) {
	if v != nil && v.Foo != nil {
		return v.Foo
	}

	return
}

// IsSetFoo returns true if Foo is not nil.
func (v *Bar_TooManyArgs_Args) IsSetFoo() bool {
	return v != nil && v.Foo != nil
}

// MethodName returns the name of the Thrift function as specified in
// the IDL, for which this struct represent the arguments.
//
// This will always be "tooManyArgs" for this struct.
func (v *Bar_TooManyArgs_Args) MethodName() string {
	return "tooManyArgs"
}

// EnvelopeType returns the kind of value inside this struct.
//
// This will always be Call for this struct.
func (v *Bar_TooManyArgs_Args) EnvelopeType() wire.EnvelopeType {
	return wire.Call
}

// Bar_TooManyArgs_Helper provides functions that aid in handling the
// parameters and return values of the Bar.tooManyArgs
// function.
var Bar_TooManyArgs_Helper = struct {
	// Args accepts the parameters of tooManyArgs in-order and returns
	// the arguments struct for the function.
	Args func(
		request *BarRequest,
		foo *foo.FooStruct,
	) *Bar_TooManyArgs_Args

	// IsException returns true if the given error can be thrown
	// by tooManyArgs.
	//
	// An error can be thrown by tooManyArgs only if the
	// corresponding exception type was mentioned in the 'throws'
	// section for it in the Thrift file.
	IsException func(error) bool

	// WrapResponse returns the result struct for tooManyArgs
	// given its return value and error.
	//
	// This allows mapping values and errors returned by
	// tooManyArgs into a serializable result struct.
	// WrapResponse returns a non-nil error if the provided
	// error cannot be thrown by tooManyArgs
	//
	//   value, err := tooManyArgs(args)
	//   result, err := Bar_TooManyArgs_Helper.WrapResponse(value, err)
	//   if err != nil {
	//     return fmt.Errorf("unexpected error from tooManyArgs: %v", err)
	//   }
	//   serialize(result)
	WrapResponse func(*BarResponse, error) (*Bar_TooManyArgs_Result, error)

	// UnwrapResponse takes the result struct for tooManyArgs
	// and returns the value or error returned by it.
	//
	// The error is non-nil only if tooManyArgs threw an
	// exception.
	//
	//   result := deserialize(bytes)
	//   value, err := Bar_TooManyArgs_Helper.UnwrapResponse(result)
	UnwrapResponse func(*Bar_TooManyArgs_Result) (*BarResponse, error)
}{}

func init() {
	Bar_TooManyArgs_Helper.Args = func(
		request *BarRequest,
		foo *foo.FooStruct,
	) *Bar_TooManyArgs_Args {
		return &Bar_TooManyArgs_Args{
			Request: request,
			Foo:     foo,
		}
	}

	Bar_TooManyArgs_Helper.IsException = func(err error) bool {
		switch err.(type) {
		case *BarException:
			return true
		case *foo.FooException:
			return true
		default:
			return false
		}
	}

	Bar_TooManyArgs_Helper.WrapResponse = func(success *BarResponse, err error) (*Bar_TooManyArgs_Result, error) {
		if err == nil {
			return &Bar_TooManyArgs_Result{Success: success}, nil
		}

		switch e := err.(type) {
		case *BarException:
			if e == nil {
				return nil, errors.New("WrapResponse received non-nil error type with nil value for Bar_TooManyArgs_Result.BarException")
			}
			return &Bar_TooManyArgs_Result{BarException: e}, nil
		case *foo.FooException:
			if e == nil {
				return nil, errors.New("WrapResponse received non-nil error type with nil value for Bar_TooManyArgs_Result.FooException")
			}
			return &Bar_TooManyArgs_Result{FooException: e}, nil
		}

		return nil, err
	}
	Bar_TooManyArgs_Helper.UnwrapResponse = func(result *Bar_TooManyArgs_Result) (success *BarResponse, err error) {
		if result.BarException != nil {
			err = result.BarException
			return
		}
		if result.FooException != nil {
			err = result.FooException
			return
		}

		if result.Success != nil {
			success = result.Success
			return
		}

		err = errors.New("expected a non-void result")
		return
	}

}

// Bar_TooManyArgs_Result represents the result of a Bar.tooManyArgs function call.
//
// The result of a tooManyArgs execution is sent and received over the wire as this struct.
//
// Success is set only if the function did not throw an exception.
type Bar_TooManyArgs_Result struct {
	// Value returned by tooManyArgs after a successful execution.
	Success      *BarResponse      `json:"success,omitempty"`
	BarException *BarException     `json:"barException,omitempty"`
	FooException *foo.FooException `json:"fooException,omitempty"`
}

// ToWire translates a Bar_TooManyArgs_Result struct into a Thrift-level intermediate
// representation. This intermediate representation may be serialized
// into bytes using a ThriftRW protocol implementation.
//
// An error is returned if the struct or any of its fields failed to
// validate.
//
//   x, err := v.ToWire()
//   if err != nil {
//     return err
//   }
//
//   if err := binaryProtocol.Encode(x, writer); err != nil {
//     return err
//   }
func (v *Bar_TooManyArgs_Result) ToWire() (wire.Value, error) {
	var (
		fields [3]wire.Field
		i      int = 0
		w      wire.Value
		err    error
	)

	if v.Success != nil {
		w, err = v.Success.ToWire()
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 0, Value: w}
		i++
	}
	if v.BarException != nil {
		w, err = v.BarException.ToWire()
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 1, Value: w}
		i++
	}
	if v.FooException != nil {
		w, err = v.FooException.ToWire()
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 2, Value: w}
		i++
	}

	if i != 1 {
		return wire.Value{}, fmt.Errorf("Bar_TooManyArgs_Result should have exactly one field: got %v fields", i)
	}

	return wire.NewValueStruct(wire.Struct{Fields: fields[:i]}), nil
}

func _FooException_Read(w wire.Value) (*foo.FooException, error) {
	var v foo.FooException
	err := v.FromWire(w)
	return &v, err
}

// FromWire deserializes a Bar_TooManyArgs_Result struct from its Thrift-level
// representation. The Thrift-level representation may be obtained
// from a ThriftRW protocol implementation.
//
// An error is returned if we were unable to build a Bar_TooManyArgs_Result struct
// from the provided intermediate representation.
//
//   x, err := binaryProtocol.Decode(reader, wire.TStruct)
//   if err != nil {
//     return nil, err
//   }
//
//   var v Bar_TooManyArgs_Result
//   if err := v.FromWire(x); err != nil {
//     return nil, err
//   }
//   return &v, nil
func (v *Bar_TooManyArgs_Result) FromWire(w wire.Value) error {
	var err error

	for _, field := range w.GetStruct().Fields {
		switch field.ID {
		case 0:
			if field.Value.Type() == wire.TStruct {
				v.Success, err = _BarResponse_Read(field.Value)
				if err != nil {
					return err
				}

			}
		case 1:
			if field.Value.Type() == wire.TStruct {
				v.BarException, err = _BarException_Read(field.Value)
				if err != nil {
					return err
				}

			}
		case 2:
			if field.Value.Type() == wire.TStruct {
				v.FooException, err = _FooException_Read(field.Value)
				if err != nil {
					return err
				}

			}
		}
	}

	count := 0
	if v.Success != nil {
		count++
	}
	if v.BarException != nil {
		count++
	}
	if v.FooException != nil {
		count++
	}
	if count != 1 {
		return fmt.Errorf("Bar_TooManyArgs_Result should have exactly one field: got %v fields", count)
	}

	return nil
}

// String returns a readable string representation of a Bar_TooManyArgs_Result
// struct.
func (v *Bar_TooManyArgs_Result) String() string {
	if v == nil {
		return "<nil>"
	}

	var fields [3]string
	i := 0
	if v.Success != nil {
		fields[i] = fmt.Sprintf("Success: %v", v.Success)
		i++
	}
	if v.BarException != nil {
		fields[i] = fmt.Sprintf("BarException: %v", v.BarException)
		i++
	}
	if v.FooException != nil {
		fields[i] = fmt.Sprintf("FooException: %v", v.FooException)
		i++
	}

	return fmt.Sprintf("Bar_TooManyArgs_Result{%v}", strings.Join(fields[:i], ", "))
}

// Equals returns true if all the fields of this Bar_TooManyArgs_Result match the
// provided Bar_TooManyArgs_Result.
//
// This function performs a deep comparison.
func (v *Bar_TooManyArgs_Result) Equals(rhs *Bar_TooManyArgs_Result) bool {
	if v == nil {
		return rhs == nil
	} else if rhs == nil {
		return false
	}
	if !((v.Success == nil && rhs.Success == nil) || (v.Success != nil && rhs.Success != nil && v.Success.Equals(rhs.Success))) {
		return false
	}
	if !((v.BarException == nil && rhs.BarException == nil) || (v.BarException != nil && rhs.BarException != nil && v.BarException.Equals(rhs.BarException))) {
		return false
	}
	if !((v.FooException == nil && rhs.FooException == nil) || (v.FooException != nil && rhs.FooException != nil && v.FooException.Equals(rhs.FooException))) {
		return false
	}

	return true
}

// MarshalLogObject implements zapcore.ObjectMarshaler, enabling
// fast logging of Bar_TooManyArgs_Result.
func (v *Bar_TooManyArgs_Result) MarshalLogObject(enc zapcore.ObjectEncoder) (err error) {
	if v == nil {
		return nil
	}
	if v.Success != nil {
		err = multierr.Append(err, enc.AddObject("success", v.Success))
	}
	if v.BarException != nil {
		err = multierr.Append(err, enc.AddObject("barException", v.BarException))
	}
	if v.FooException != nil {
		err = multierr.Append(err, enc.AddObject("fooException", v.FooException))
	}
	return err
}

// GetSuccess returns the value of Success if it is set or its
// zero value if it is unset.
func (v *Bar_TooManyArgs_Result) GetSuccess() (o *BarResponse) {
	if v != nil && v.Success != nil {
		return v.Success
	}

	return
}

// IsSetSuccess returns true if Success is not nil.
func (v *Bar_TooManyArgs_Result) IsSetSuccess() bool {
	return v != nil && v.Success != nil
}

// GetBarException returns the value of BarException if it is set or its
// zero value if it is unset.
func (v *Bar_TooManyArgs_Result) GetBarException() (o *BarException) {
	if v != nil && v.BarException != nil {
		return v.BarException
	}

	return
}

// IsSetBarException returns true if BarException is not nil.
func (v *Bar_TooManyArgs_Result) IsSetBarException() bool {
	return v != nil && v.BarException != nil
}

// GetFooException returns the value of FooException if it is set or its
// zero value if it is unset.
func (v *Bar_TooManyArgs_Result) GetFooException() (o *foo.FooException) {
	if v != nil && v.FooException != nil {
		return v.FooException
	}

	return
}

// IsSetFooException returns true if FooException is not nil.
func (v *Bar_TooManyArgs_Result) IsSetFooException() bool {
	return v != nil && v.FooException != nil
}

// MethodName returns the name of the Thrift function as specified in
// the IDL, for which this struct represent the result.
//
// This will always be "tooManyArgs" for this struct.
func (v *Bar_TooManyArgs_Result) MethodName() string {
	return "tooManyArgs"
}

// EnvelopeType returns the kind of value inside this struct.
//
// This will always be Reply for this struct.
func (v *Bar_TooManyArgs_Result) EnvelopeType() wire.EnvelopeType {
	return wire.Reply
}

// Echo_EchoBinary_Args represents the arguments for the Echo.echoBinary function.
//
// The arguments for echoBinary are sent and received over the wire as this struct.
type Echo_EchoBinary_Args struct {
	Arg []byte `json:"arg,required"`
}

// ToWire translates a Echo_EchoBinary_Args struct into a Thrift-level intermediate
// representation. This intermediate representation may be serialized
// into bytes using a ThriftRW protocol implementation.
//
// An error is returned if the struct or any of its fields failed to
// validate.
//
//   x, err := v.ToWire()
//   if err != nil {
//     return err
//   }
//
//   if err := binaryProtocol.Encode(x, writer); err != nil {
//     return err
//   }
func (v *Echo_EchoBinary_Args) ToWire() (wire.Value, error) {
	var (
		fields [1]wire.Field
		i      int = 0
		w      wire.Value
		err    error
	)

	if v.Arg == nil {
		return w, errors.New("field Arg of Echo_EchoBinary_Args is required")
	}
	w, err = wire.NewValueBinary(v.Arg), error(nil)
	if err != nil {
		return w, err
	}
	fields[i] = wire.Field{ID: 1, Value: w}
	i++

	return wire.NewValueStruct(wire.Struct{Fields: fields[:i]}), nil
}

// FromWire deserializes a Echo_EchoBinary_Args struct from its Thrift-level
// representation. The Thrift-level representation may be obtained
// from a ThriftRW protocol implementation.
//
// An error is returned if we were unable to build a Echo_EchoBinary_Args struct
// from the provided intermediate representation.
//
//   x, err := binaryProtocol.Decode(reader, wire.TStruct)
//   if err != nil {
//     return nil, err
//   }
//
//   var v Echo_EchoBinary_Args
//   if err := v.FromWire(x); err != nil {
//     return nil, err
//   }
//   return &v, nil
func (v *Echo_EchoBinary_Args) FromWire(w wire.Value) error {
	var err error

	argIsSet := false

	for _, field := range w.GetStruct().Fields {
		switch field.ID {
		case 1:
			if field.Value.Type() == wire.TBinary {
				v.Arg, err = field.Value.GetBinary(), error(nil)
				if err != nil {
					return err
				}
				argIsSet = true
			}
		}
	}

	if !argIsSet {
		return errors.New("field Arg of Echo_EchoBinary_Args is required")
	}

	return nil
}

// String returns a readable string representation of a Echo_EchoBinary_Args
// struct.
func (v *Echo_EchoBinary_Args) String() string {
	if v == nil {
		return "<nil>"
	}

	var fields [1]string
	i := 0
	fields[i] = fmt.Sprintf("Arg: %v", v.Arg)
	i++

	return fmt.Sprintf("Echo_EchoBinary_Args{%v}", strings.Join(fields[:i], ", "))
}

// Equals returns true if all the fields of this Echo_EchoBinary_Args match the
// provided Echo_EchoBinary_Args.
//
// This function performs a deep comparison.
func (v *Echo_EchoBinary_Args) Equals(rhs *Echo_EchoBinary_Args) bool {
	if v == nil {
		return rhs == nil
	} else if rhs == nil {
		return false
	}
	if !bytes.Equal(v.Arg, rhs.Arg) {
		return false
	}

	return true
}

// MarshalLogObject implements zapcore.ObjectMarshaler, enabling
// fast logging of Echo_EchoBinary_Args.
func (v *Echo_EchoBinary_Args) MarshalLogObject(enc zapcore.ObjectEncoder) (err error) {
	if v == nil {
		return nil
	}
	enc.AddString("arg", base64.StdEncoding.EncodeToString(v.Arg))
	return err
}

// GetArg returns the value of Arg if it is set or its
// zero value if it is unset.
func (v *Echo_EchoBinary_Args) GetArg() (o []byte) {
	if v != nil {
		o = v.Arg
	}
	return
}

// IsSetArg returns true if Arg is not nil.
func (v *Echo_EchoBinary_Args) IsSetArg() bool {
	return v != nil && v.Arg != nil
}

// MethodName returns the name of the Thrift function as specified in
// the IDL, for which this struct represent the arguments.
//
// This will always be "echoBinary" for this struct.
func (v *Echo_EchoBinary_Args) MethodName() string {
	return "echoBinary"
}

// EnvelopeType returns the kind of value inside this struct.
//
// This will always be Call for this struct.
func (v *Echo_EchoBinary_Args) EnvelopeType() wire.EnvelopeType {
	return wire.Call
}

// Echo_EchoBinary_Helper provides functions that aid in handling the
// parameters and return values of the Echo.echoBinary
// function.
var Echo_EchoBinary_Helper = struct {
	// Args accepts the parameters of echoBinary in-order and returns
	// the arguments struct for the function.
	Args func(
		arg []byte,
	) *Echo_EchoBinary_Args

	// IsException returns true if the given error can be thrown
	// by echoBinary.
	//
	// An error can be thrown by echoBinary only if the
	// corresponding exception type was mentioned in the 'throws'
	// section for it in the Thrift file.
	IsException func(error) bool

	// WrapResponse returns the result struct for echoBinary
	// given its return value and error.
	//
	// This allows mapping values and errors returned by
	// echoBinary into a serializable result struct.
	// WrapResponse returns a non-nil error if the provided
	// error cannot be thrown by echoBinary
	//
	//   value, err := echoBinary(args)
	//   result, err := Echo_EchoBinary_Helper.WrapResponse(value, err)
	//   if err != nil {
	//     return fmt.Errorf("unexpected error from echoBinary: %v", err)
	//   }
	//   serialize(result)
	WrapResponse func([]byte, error) (*Echo_EchoBinary_Result, error)

	// UnwrapResponse takes the result struct for echoBinary
	// and returns the value or error returned by it.
	//
	// The error is non-nil only if echoBinary threw an
	// exception.
	//
	//   result := deserialize(bytes)
	//   value, err := Echo_EchoBinary_Helper.UnwrapResponse(result)
	UnwrapResponse func(*Echo_EchoBinary_Result) ([]byte, error)
}{}

func init() {
	Echo_EchoBinary_Helper.Args = func(
		arg []byte,
	) *Echo_EchoBinary_Args {
		return &Echo_EchoBinary_Args{
			Arg: arg,
		}
	}

	Echo_EchoBinary_Helper.IsException = func(err error) bool {
		switch err.(type) {
		default:
			return false
		}
	}

	Echo_EchoBinary_Helper.WrapResponse = func(success []byte, err error) (*Echo_EchoBinary_Result, error) {
		if err == nil {
			return &Echo_EchoBinary_Result{Success: success}, nil
		}

		return nil, err
	}
	Echo_EchoBinary_Helper.UnwrapResponse = func(result *Echo_EchoBinary_Result) (success []byte, err error) {

		if result.Success != nil {
			success = result.Success
			return
		}

		err = errors.New("expected a non-void result")
		return
	}

}

// Echo_EchoBinary_Result represents the result of a Echo.echoBinary function call.
//
// The result of a echoBinary execution is sent and received over the wire as this struct.
//
// Success is set only if the function did not throw an exception.
type Echo_EchoBinary_Result struct {
	// Value returned by echoBinary after a successful execution.
	Success []byte `json:"success,omitempty"`
}

// ToWire translates a Echo_EchoBinary_Result struct into a Thrift-level intermediate
// representation. This intermediate representation may be serialized
// into bytes using a ThriftRW protocol implementation.
//
// An error is returned if the struct or any of its fields failed to
// validate.
//
//   x, err := v.ToWire()
//   if err != nil {
//     return err
//   }
//
//   if err := binaryProtocol.Encode(x, writer); err != nil {
//     return err
//   }
func (v *Echo_EchoBinary_Result) ToWire() (wire.Value, error) {
	var (
		fields [1]wire.Field
		i      int = 0
		w      wire.Value
		err    error
	)

	if v.Success != nil {
		w, err = wire.NewValueBinary(v.Success), error(nil)
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 0, Value: w}
		i++
	}

	if i != 1 {
		return wire.Value{}, fmt.Errorf("Echo_EchoBinary_Result should have exactly one field: got %v fields", i)
	}

	return wire.NewValueStruct(wire.Struct{Fields: fields[:i]}), nil
}

// FromWire deserializes a Echo_EchoBinary_Result struct from its Thrift-level
// representation. The Thrift-level representation may be obtained
// from a ThriftRW protocol implementation.
//
// An error is returned if we were unable to build a Echo_EchoBinary_Result struct
// from the provided intermediate representation.
//
//   x, err := binaryProtocol.Decode(reader, wire.TStruct)
//   if err != nil {
//     return nil, err
//   }
//
//   var v Echo_EchoBinary_Result
//   if err := v.FromWire(x); err != nil {
//     return nil, err
//   }
//   return &v, nil
func (v *Echo_EchoBinary_Result) FromWire(w wire.Value) error {
	var err error

	for _, field := range w.GetStruct().Fields {
		switch field.ID {
		case 0:
			if field.Value.Type() == wire.TBinary {
				v.Success, err = field.Value.GetBinary(), error(nil)
				if err != nil {
					return err
				}

			}
		}
	}

	count := 0
	if v.Success != nil {
		count++
	}
	if count != 1 {
		return fmt.Errorf("Echo_EchoBinary_Result should have exactly one field: got %v fields", count)
	}

	return nil
}

// String returns a readable string representation of a Echo_EchoBinary_Result
// struct.
func (v *Echo_EchoBinary_Result) String() string {
	if v == nil {
		return "<nil>"
	}

	var fields [1]string
	i := 0
	if v.Success != nil {
		fields[i] = fmt.Sprintf("Success: %v", v.Success)
		i++
	}

	return fmt.Sprintf("Echo_EchoBinary_Result{%v}", strings.Join(fields[:i], ", "))
}

// Equals returns true if all the fields of this Echo_EchoBinary_Result match the
// provided Echo_EchoBinary_Result.
//
// This function performs a deep comparison.
func (v *Echo_EchoBinary_Result) Equals(rhs *Echo_EchoBinary_Result) bool {
	if v == nil {
		return rhs == nil
	} else if rhs == nil {
		return false
	}
	if !((v.Success == nil && rhs.Success == nil) || (v.Success != nil && rhs.Success != nil && bytes.Equal(v.Success, rhs.Success))) {
		return false
	}

	return true
}

// MarshalLogObject implements zapcore.ObjectMarshaler, enabling
// fast logging of Echo_EchoBinary_Result.
func (v *Echo_EchoBinary_Result) MarshalLogObject(enc zapcore.ObjectEncoder) (err error) {
	if v == nil {
		return nil
	}
	if v.Success != nil {
		enc.AddString("success", base64.StdEncoding.EncodeToString(v.Success))
	}
	return err
}

// GetSuccess returns the value of Success if it is set or its
// zero value if it is unset.
func (v *Echo_EchoBinary_Result) GetSuccess() (o []byte) {
	if v != nil && v.Success != nil {
		return v.Success
	}

	return
}

// IsSetSuccess returns true if Success is not nil.
func (v *Echo_EchoBinary_Result) IsSetSuccess() bool {
	return v != nil && v.Success != nil
}

// MethodName returns the name of the Thrift function as specified in
// the IDL, for which this struct represent the result.
//
// This will always be "echoBinary" for this struct.
func (v *Echo_EchoBinary_Result) MethodName() string {
	return "echoBinary"
}

// EnvelopeType returns the kind of value inside this struct.
//
// This will always be Reply for this struct.
func (v *Echo_EchoBinary_Result) EnvelopeType() wire.EnvelopeType {
	return wire.Reply
}

// Echo_EchoBool_Args represents the arguments for the Echo.echoBool function.
//
// The arguments for echoBool are sent and received over the wire as this struct.
type Echo_EchoBool_Args struct {
	Arg bool `json:"arg,required"`
}

// ToWire translates a Echo_EchoBool_Args struct into a Thrift-level intermediate
// representation. This intermediate representation may be serialized
// into bytes using a ThriftRW protocol implementation.
//
// An error is returned if the struct or any of its fields failed to
// validate.
//
//   x, err := v.ToWire()
//   if err != nil {
//     return err
//   }
//
//   if err := binaryProtocol.Encode(x, writer); err != nil {
//     return err
//   }
func (v *Echo_EchoBool_Args) ToWire() (wire.Value, error) {
	var (
		fields [1]wire.Field
		i      int = 0
		w      wire.Value
		err    error
	)

	w, err = wire.NewValueBool(v.Arg), error(nil)
	if err != nil {
		return w, err
	}
	fields[i] = wire.Field{ID: 1, Value: w}
	i++

	return wire.NewValueStruct(wire.Struct{Fields: fields[:i]}), nil
}

// FromWire deserializes a Echo_EchoBool_Args struct from its Thrift-level
// representation. The Thrift-level representation may be obtained
// from a ThriftRW protocol implementation.
//
// An error is returned if we were unable to build a Echo_EchoBool_Args struct
// from the provided intermediate representation.
//
//   x, err := binaryProtocol.Decode(reader, wire.TStruct)
//   if err != nil {
//     return nil, err
//   }
//
//   var v Echo_EchoBool_Args
//   if err := v.FromWire(x); err != nil {
//     return nil, err
//   }
//   return &v, nil
func (v *Echo_EchoBool_Args) FromWire(w wire.Value) error {
	var err error

	argIsSet := false

	for _, field := range w.GetStruct().Fields {
		switch field.ID {
		case 1:
			if field.Value.Type() == wire.TBool {
				v.Arg, err = field.Value.GetBool(), error(nil)
				if err != nil {
					return err
				}
				argIsSet = true
			}
		}
	}

	if !argIsSet {
		return errors.New("field Arg of Echo_EchoBool_Args is required")
	}

	return nil
}

// String returns a readable string representation of a Echo_EchoBool_Args
// struct.
func (v *Echo_EchoBool_Args) String() string {
	if v == nil {
		return "<nil>"
	}

	var fields [1]string
	i := 0
	fields[i] = fmt.Sprintf("Arg: %v", v.Arg)
	i++

	return fmt.Sprintf("Echo_EchoBool_Args{%v}", strings.Join(fields[:i], ", "))
}

// Equals returns true if all the fields of this Echo_EchoBool_Args match the
// provided Echo_EchoBool_Args.
//
// This function performs a deep comparison.
func (v *Echo_EchoBool_Args) Equals(rhs *Echo_EchoBool_Args) bool {
	if v == nil {
		return rhs == nil
	} else if rhs == nil {
		return false
	}
	if !(v.Arg == rhs.Arg) {
		return false
	}

	return true
}

// MarshalLogObject implements zapcore.ObjectMarshaler, enabling
// fast logging of Echo_EchoBool_Args.
func (v *Echo_EchoBool_Args) MarshalLogObject(enc zapcore.ObjectEncoder) (err error) {
	if v == nil {
		return nil
	}
	enc.AddBool("arg", v.Arg)
	return err
}

// GetArg returns the value of Arg if it is set or its
// zero value if it is unset.
func (v *Echo_EchoBool_Args) GetArg() (o bool) {
	if v != nil {
		o = v.Arg
	}
	return
}

// MethodName returns the name of the Thrift function as specified in
// the IDL, for which this struct represent the arguments.
//
// This will always be "echoBool" for this struct.
func (v *Echo_EchoBool_Args) MethodName() string {
	return "echoBool"
}

// EnvelopeType returns the kind of value inside this struct.
//
// This will always be Call for this struct.
func (v *Echo_EchoBool_Args) EnvelopeType() wire.EnvelopeType {
	return wire.Call
}

// Echo_EchoBool_Helper provides functions that aid in handling the
// parameters and return values of the Echo.echoBool
// function.
var Echo_EchoBool_Helper = struct {
	// Args accepts the parameters of echoBool in-order and returns
	// the arguments struct for the function.
	Args func(
		arg bool,
	) *Echo_EchoBool_Args

	// IsException returns true if the given error can be thrown
	// by echoBool.
	//
	// An error can be thrown by echoBool only if the
	// corresponding exception type was mentioned in the 'throws'
	// section for it in the Thrift file.
	IsException func(error) bool

	// WrapResponse returns the result struct for echoBool
	// given its return value and error.
	//
	// This allows mapping values and errors returned by
	// echoBool into a serializable result struct.
	// WrapResponse returns a non-nil error if the provided
	// error cannot be thrown by echoBool
	//
	//   value, err := echoBool(args)
	//   result, err := Echo_EchoBool_Helper.WrapResponse(value, err)
	//   if err != nil {
	//     return fmt.Errorf("unexpected error from echoBool: %v", err)
	//   }
	//   serialize(result)
	WrapResponse func(bool, error) (*Echo_EchoBool_Result, error)

	// UnwrapResponse takes the result struct for echoBool
	// and returns the value or error returned by it.
	//
	// The error is non-nil only if echoBool threw an
	// exception.
	//
	//   result := deserialize(bytes)
	//   value, err := Echo_EchoBool_Helper.UnwrapResponse(result)
	UnwrapResponse func(*Echo_EchoBool_Result) (bool, error)
}{}

func init() {
	Echo_EchoBool_Helper.Args = func(
		arg bool,
	) *Echo_EchoBool_Args {
		return &Echo_EchoBool_Args{
			Arg: arg,
		}
	}

	Echo_EchoBool_Helper.IsException = func(err error) bool {
		switch err.(type) {
		default:
			return false
		}
	}

	Echo_EchoBool_Helper.WrapResponse = func(success bool, err error) (*Echo_EchoBool_Result, error) {
		if err == nil {
			return &Echo_EchoBool_Result{Success: &success}, nil
		}

		return nil, err
	}
	Echo_EchoBool_Helper.UnwrapResponse = func(result *Echo_EchoBool_Result) (success bool, err error) {

		if result.Success != nil {
			success = *result.Success
			return
		}

		err = errors.New("expected a non-void result")
		return
	}

}

// Echo_EchoBool_Result represents the result of a Echo.echoBool function call.
//
// The result of a echoBool execution is sent and received over the wire as this struct.
//
// Success is set only if the function did not throw an exception.
type Echo_EchoBool_Result struct {
	// Value returned by echoBool after a successful execution.
	Success *bool `json:"success,omitempty"`
}

// ToWire translates a Echo_EchoBool_Result struct into a Thrift-level intermediate
// representation. This intermediate representation may be serialized
// into bytes using a ThriftRW protocol implementation.
//
// An error is returned if the struct or any of its fields failed to
// validate.
//
//   x, err := v.ToWire()
//   if err != nil {
//     return err
//   }
//
//   if err := binaryProtocol.Encode(x, writer); err != nil {
//     return err
//   }
func (v *Echo_EchoBool_Result) ToWire() (wire.Value, error) {
	var (
		fields [1]wire.Field
		i      int = 0
		w      wire.Value
		err    error
	)

	if v.Success != nil {
		w, err = wire.NewValueBool(*(v.Success)), error(nil)
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 0, Value: w}
		i++
	}

	if i != 1 {
		return wire.Value{}, fmt.Errorf("Echo_EchoBool_Result should have exactly one field: got %v fields", i)
	}

	return wire.NewValueStruct(wire.Struct{Fields: fields[:i]}), nil
}

// FromWire deserializes a Echo_EchoBool_Result struct from its Thrift-level
// representation. The Thrift-level representation may be obtained
// from a ThriftRW protocol implementation.
//
// An error is returned if we were unable to build a Echo_EchoBool_Result struct
// from the provided intermediate representation.
//
//   x, err := binaryProtocol.Decode(reader, wire.TStruct)
//   if err != nil {
//     return nil, err
//   }
//
//   var v Echo_EchoBool_Result
//   if err := v.FromWire(x); err != nil {
//     return nil, err
//   }
//   return &v, nil
func (v *Echo_EchoBool_Result) FromWire(w wire.Value) error {
	var err error

	for _, field := range w.GetStruct().Fields {
		switch field.ID {
		case 0:
			if field.Value.Type() == wire.TBool {
				var x bool
				x, err = field.Value.GetBool(), error(nil)
				v.Success = &x
				if err != nil {
					return err
				}

			}
		}
	}

	count := 0
	if v.Success != nil {
		count++
	}
	if count != 1 {
		return fmt.Errorf("Echo_EchoBool_Result should have exactly one field: got %v fields", count)
	}

	return nil
}

// String returns a readable string representation of a Echo_EchoBool_Result
// struct.
func (v *Echo_EchoBool_Result) String() string {
	if v == nil {
		return "<nil>"
	}

	var fields [1]string
	i := 0
	if v.Success != nil {
		fields[i] = fmt.Sprintf("Success: %v", *(v.Success))
		i++
	}

	return fmt.Sprintf("Echo_EchoBool_Result{%v}", strings.Join(fields[:i], ", "))
}

// Equals returns true if all the fields of this Echo_EchoBool_Result match the
// provided Echo_EchoBool_Result.
//
// This function performs a deep comparison.
func (v *Echo_EchoBool_Result) Equals(rhs *Echo_EchoBool_Result) bool {
	if v == nil {
		return rhs == nil
	} else if rhs == nil {
		return false
	}
	if !_Bool_EqualsPtr(v.Success, rhs.Success) {
		return false
	}

	return true
}

// MarshalLogObject implements zapcore.ObjectMarshaler, enabling
// fast logging of Echo_EchoBool_Result.
func (v *Echo_EchoBool_Result) MarshalLogObject(enc zapcore.ObjectEncoder) (err error) {
	if v == nil {
		return nil
	}
	if v.Success != nil {
		enc.AddBool("success", *v.Success)
	}
	return err
}

// GetSuccess returns the value of Success if it is set or its
// zero value if it is unset.
func (v *Echo_EchoBool_Result) GetSuccess() (o bool) {
	if v != nil && v.Success != nil {
		return *v.Success
	}

	return
}

// IsSetSuccess returns true if Success is not nil.
func (v *Echo_EchoBool_Result) IsSetSuccess() bool {
	return v != nil && v.Success != nil
}

// MethodName returns the name of the Thrift function as specified in
// the IDL, for which this struct represent the result.
//
// This will always be "echoBool" for this struct.
func (v *Echo_EchoBool_Result) MethodName() string {
	return "echoBool"
}

// EnvelopeType returns the kind of value inside this struct.
//
// This will always be Reply for this struct.
func (v *Echo_EchoBool_Result) EnvelopeType() wire.EnvelopeType {
	return wire.Reply
}

// Echo_EchoDouble_Args represents the arguments for the Echo.echoDouble function.
//
// The arguments for echoDouble are sent and received over the wire as this struct.
type Echo_EchoDouble_Args struct {
	Arg float64 `json:"arg,required"`
}

// ToWire translates a Echo_EchoDouble_Args struct into a Thrift-level intermediate
// representation. This intermediate representation may be serialized
// into bytes using a ThriftRW protocol implementation.
//
// An error is returned if the struct or any of its fields failed to
// validate.
//
//   x, err := v.ToWire()
//   if err != nil {
//     return err
//   }
//
//   if err := binaryProtocol.Encode(x, writer); err != nil {
//     return err
//   }
func (v *Echo_EchoDouble_Args) ToWire() (wire.Value, error) {
	var (
		fields [1]wire.Field
		i      int = 0
		w      wire.Value
		err    error
	)

	w, err = wire.NewValueDouble(v.Arg), error(nil)
	if err != nil {
		return w, err
	}
	fields[i] = wire.Field{ID: 1, Value: w}
	i++

	return wire.NewValueStruct(wire.Struct{Fields: fields[:i]}), nil
}

// FromWire deserializes a Echo_EchoDouble_Args struct from its Thrift-level
// representation. The Thrift-level representation may be obtained
// from a ThriftRW protocol implementation.
//
// An error is returned if we were unable to build a Echo_EchoDouble_Args struct
// from the provided intermediate representation.
//
//   x, err := binaryProtocol.Decode(reader, wire.TStruct)
//   if err != nil {
//     return nil, err
//   }
//
//   var v Echo_EchoDouble_Args
//   if err := v.FromWire(x); err != nil {
//     return nil, err
//   }
//   return &v, nil
func (v *Echo_EchoDouble_Args) FromWire(w wire.Value) error {
	var err error

	argIsSet := false

	for _, field := range w.GetStruct().Fields {
		switch field.ID {
		case 1:
			if field.Value.Type() == wire.TDouble {
				v.Arg, err = field.Value.GetDouble(), error(nil)
				if err != nil {
					return err
				}
				argIsSet = true
			}
		}
	}

	if !argIsSet {
		return errors.New("field Arg of Echo_EchoDouble_Args is required")
	}

	return nil
}

// String returns a readable string representation of a Echo_EchoDouble_Args
// struct.
func (v *Echo_EchoDouble_Args) String() string {
	if v == nil {
		return "<nil>"
	}

	var fields [1]string
	i := 0
	fields[i] = fmt.Sprintf("Arg: %v", v.Arg)
	i++

	return fmt.Sprintf("Echo_EchoDouble_Args{%v}", strings.Join(fields[:i], ", "))
}

// Equals returns true if all the fields of this Echo_EchoDouble_Args match the
// provided Echo_EchoDouble_Args.
//
// This function performs a deep comparison.
func (v *Echo_EchoDouble_Args) Equals(rhs *Echo_EchoDouble_Args) bool {
	if v == nil {
		return rhs == nil
	} else if rhs == nil {
		return false
	}
	if !(v.Arg == rhs.Arg) {
		return false
	}

	return true
}

// MarshalLogObject implements zapcore.ObjectMarshaler, enabling
// fast logging of Echo_EchoDouble_Args.
func (v *Echo_EchoDouble_Args) MarshalLogObject(enc zapcore.ObjectEncoder) (err error) {
	if v == nil {
		return nil
	}
	enc.AddFloat64("arg", v.Arg)
	return err
}

// GetArg returns the value of Arg if it is set or its
// zero value if it is unset.
func (v *Echo_EchoDouble_Args) GetArg() (o float64) {
	if v != nil {
		o = v.Arg
	}
	return
}

// MethodName returns the name of the Thrift function as specified in
// the IDL, for which this struct represent the arguments.
//
// This will always be "echoDouble" for this struct.
func (v *Echo_EchoDouble_Args) MethodName() string {
	return "echoDouble"
}

// EnvelopeType returns the kind of value inside this struct.
//
// This will always be Call for this struct.
func (v *Echo_EchoDouble_Args) EnvelopeType() wire.EnvelopeType {
	return wire.Call
}

// Echo_EchoDouble_Helper provides functions that aid in handling the
// parameters and return values of the Echo.echoDouble
// function.
var Echo_EchoDouble_Helper = struct {
	// Args accepts the parameters of echoDouble in-order and returns
	// the arguments struct for the function.
	Args func(
		arg float64,
	) *Echo_EchoDouble_Args

	// IsException returns true if the given error can be thrown
	// by echoDouble.
	//
	// An error can be thrown by echoDouble only if the
	// corresponding exception type was mentioned in the 'throws'
	// section for it in the Thrift file.
	IsException func(error) bool

	// WrapResponse returns the result struct for echoDouble
	// given its return value and error.
	//
	// This allows mapping values and errors returned by
	// echoDouble into a serializable result struct.
	// WrapResponse returns a non-nil error if the provided
	// error cannot be thrown by echoDouble
	//
	//   value, err := echoDouble(args)
	//   result, err := Echo_EchoDouble_Helper.WrapResponse(value, err)
	//   if err != nil {
	//     return fmt.Errorf("unexpected error from echoDouble: %v", err)
	//   }
	//   serialize(result)
	WrapResponse func(float64, error) (*Echo_EchoDouble_Result, error)

	// UnwrapResponse takes the result struct for echoDouble
	// and returns the value or error returned by it.
	//
	// The error is non-nil only if echoDouble threw an
	// exception.
	//
	//   result := deserialize(bytes)
	//   value, err := Echo_EchoDouble_Helper.UnwrapResponse(result)
	UnwrapResponse func(*Echo_EchoDouble_Result) (float64, error)
}{}

func init() {
	Echo_EchoDouble_Helper.Args = func(
		arg float64,
	) *Echo_EchoDouble_Args {
		return &Echo_EchoDouble_Args{
			Arg: arg,
		}
	}

	Echo_EchoDouble_Helper.IsException = func(err error) bool {
		switch err.(type) {
		default:
			return false
		}
	}

	Echo_EchoDouble_Helper.WrapResponse = func(success float64, err error) (*Echo_EchoDouble_Result, error) {
		if err == nil {
			return &Echo_EchoDouble_Result{Success: &success}, nil
		}

		return nil, err
	}
	Echo_EchoDouble_Helper.UnwrapResponse = func(result *Echo_EchoDouble_Result) (success float64, err error) {

		if result.Success != nil {
			success = *result.Success
			return
		}

		err = errors.New("expected a non-void result")
		return
	}

}

// Echo_EchoDouble_Result represents the result of a Echo.echoDouble function call.
//
// The result of a echoDouble execution is sent and received over the wire as this struct.
//
// Success is set only if the function did not throw an exception.
type Echo_EchoDouble_Result struct {
	// Value returned by echoDouble after a successful execution.
	Success *float64 `json:"success,omitempty"`
}

// ToWire translates a Echo_EchoDouble_Result struct into a Thrift-level intermediate
// representation. This intermediate representation may be serialized
// into bytes using a ThriftRW protocol implementation.
//
// An error is returned if the struct or any of its fields failed to
// validate.
//
//   x, err := v.ToWire()
//   if err != nil {
//     return err
//   }
//
//   if err := binaryProtocol.Encode(x, writer); err != nil {
//     return err
//   }
func (v *Echo_EchoDouble_Result) ToWire() (wire.Value, error) {
	var (
		fields [1]wire.Field
		i      int = 0
		w      wire.Value
		err    error
	)

	if v.Success != nil {
		w, err = wire.NewValueDouble(*(v.Success)), error(nil)
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 0, Value: w}
		i++
	}

	if i != 1 {
		return wire.Value{}, fmt.Errorf("Echo_EchoDouble_Result should have exactly one field: got %v fields", i)
	}

	return wire.NewValueStruct(wire.Struct{Fields: fields[:i]}), nil
}

// FromWire deserializes a Echo_EchoDouble_Result struct from its Thrift-level
// representation. The Thrift-level representation may be obtained
// from a ThriftRW protocol implementation.
//
// An error is returned if we were unable to build a Echo_EchoDouble_Result struct
// from the provided intermediate representation.
//
//   x, err := binaryProtocol.Decode(reader, wire.TStruct)
//   if err != nil {
//     return nil, err
//   }
//
//   var v Echo_EchoDouble_Result
//   if err := v.FromWire(x); err != nil {
//     return nil, err
//   }
//   return &v, nil
func (v *Echo_EchoDouble_Result) FromWire(w wire.Value) error {
	var err error

	for _, field := range w.GetStruct().Fields {
		switch field.ID {
		case 0:
			if field.Value.Type() == wire.TDouble {
				var x float64
				x, err = field.Value.GetDouble(), error(nil)
				v.Success = &x
				if err != nil {
					return err
				}

			}
		}
	}

	count := 0
	if v.Success != nil {
		count++
	}
	if count != 1 {
		return fmt.Errorf("Echo_EchoDouble_Result should have exactly one field: got %v fields", count)
	}

	return nil
}

// String returns a readable string representation of a Echo_EchoDouble_Result
// struct.
func (v *Echo_EchoDouble_Result) String() string {
	if v == nil {
		return "<nil>"
	}

	var fields [1]string
	i := 0
	if v.Success != nil {
		fields[i] = fmt.Sprintf("Success: %v", *(v.Success))
		i++
	}

	return fmt.Sprintf("Echo_EchoDouble_Result{%v}", strings.Join(fields[:i], ", "))
}

// Equals returns true if all the fields of this Echo_EchoDouble_Result match the
// provided Echo_EchoDouble_Result.
//
// This function performs a deep comparison.
func (v *Echo_EchoDouble_Result) Equals(rhs *Echo_EchoDouble_Result) bool {
	if v == nil {
		return rhs == nil
	} else if rhs == nil {
		return false
	}
	if !_Double_EqualsPtr(v.Success, rhs.Success) {
		return false
	}

	return true
}

// MarshalLogObject implements zapcore.ObjectMarshaler, enabling
// fast logging of Echo_EchoDouble_Result.
func (v *Echo_EchoDouble_Result) MarshalLogObject(enc zapcore.ObjectEncoder) (err error) {
	if v == nil {
		return nil
	}
	if v.Success != nil {
		enc.AddFloat64("success", *v.Success)
	}
	return err
}

// GetSuccess returns the value of Success if it is set or its
// zero value if it is unset.
func (v *Echo_EchoDouble_Result) GetSuccess() (o float64) {
	if v != nil && v.Success != nil {
		return *v.Success
	}

	return
}

// IsSetSuccess returns true if Success is not nil.
func (v *Echo_EchoDouble_Result) IsSetSuccess() bool {
	return v != nil && v.Success != nil
}

// MethodName returns the name of the Thrift function as specified in
// the IDL, for which this struct represent the result.
//
// This will always be "echoDouble" for this struct.
func (v *Echo_EchoDouble_Result) MethodName() string {
	return "echoDouble"
}

// EnvelopeType returns the kind of value inside this struct.
//
// This will always be Reply for this struct.
func (v *Echo_EchoDouble_Result) EnvelopeType() wire.EnvelopeType {
	return wire.Reply
}

// Echo_EchoEnum_Args represents the arguments for the Echo.echoEnum function.
//
// The arguments for echoEnum are sent and received over the wire as this struct.
type Echo_EchoEnum_Args struct {
	Arg *Fruit `json:"arg,omitempty"`
}

func _Fruit_ptr(v Fruit) *Fruit {
	return &v
}

// ToWire translates a Echo_EchoEnum_Args struct into a Thrift-level intermediate
// representation. This intermediate representation may be serialized
// into bytes using a ThriftRW protocol implementation.
//
// An error is returned if the struct or any of its fields failed to
// validate.
//
//   x, err := v.ToWire()
//   if err != nil {
//     return err
//   }
//
//   if err := binaryProtocol.Encode(x, writer); err != nil {
//     return err
//   }
func (v *Echo_EchoEnum_Args) ToWire() (wire.Value, error) {
	var (
		fields [1]wire.Field
		i      int = 0
		w      wire.Value
		err    error
	)

	if v.Arg == nil {
		v.Arg = _Fruit_ptr(FruitApple)
	}
	{
		w, err = v.Arg.ToWire()
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 1, Value: w}
		i++
	}

	return wire.NewValueStruct(wire.Struct{Fields: fields[:i]}), nil
}

// FromWire deserializes a Echo_EchoEnum_Args struct from its Thrift-level
// representation. The Thrift-level representation may be obtained
// from a ThriftRW protocol implementation.
//
// An error is returned if we were unable to build a Echo_EchoEnum_Args struct
// from the provided intermediate representation.
//
//   x, err := binaryProtocol.Decode(reader, wire.TStruct)
//   if err != nil {
//     return nil, err
//   }
//
//   var v Echo_EchoEnum_Args
//   if err := v.FromWire(x); err != nil {
//     return nil, err
//   }
//   return &v, nil
func (v *Echo_EchoEnum_Args) FromWire(w wire.Value) error {
	var err error

	for _, field := range w.GetStruct().Fields {
		switch field.ID {
		case 1:
			if field.Value.Type() == wire.TI32 {
				var x Fruit
				x, err = _Fruit_Read(field.Value)
				v.Arg = &x
				if err != nil {
					return err
				}

			}
		}
	}

	if v.Arg == nil {
		v.Arg = _Fruit_ptr(FruitApple)
	}

	return nil
}

// String returns a readable string representation of a Echo_EchoEnum_Args
// struct.
func (v *Echo_EchoEnum_Args) String() string {
	if v == nil {
		return "<nil>"
	}

	var fields [1]string
	i := 0
	if v.Arg != nil {
		fields[i] = fmt.Sprintf("Arg: %v", *(v.Arg))
		i++
	}

	return fmt.Sprintf("Echo_EchoEnum_Args{%v}", strings.Join(fields[:i], ", "))
}

// Equals returns true if all the fields of this Echo_EchoEnum_Args match the
// provided Echo_EchoEnum_Args.
//
// This function performs a deep comparison.
func (v *Echo_EchoEnum_Args) Equals(rhs *Echo_EchoEnum_Args) bool {
	if v == nil {
		return rhs == nil
	} else if rhs == nil {
		return false
	}
	if !_Fruit_EqualsPtr(v.Arg, rhs.Arg) {
		return false
	}

	return true
}

// MarshalLogObject implements zapcore.ObjectMarshaler, enabling
// fast logging of Echo_EchoEnum_Args.
func (v *Echo_EchoEnum_Args) MarshalLogObject(enc zapcore.ObjectEncoder) (err error) {
	if v == nil {
		return nil
	}
	if v.Arg != nil {
		err = multierr.Append(err, enc.AddObject("arg", *v.Arg))
	}
	return err
}

// GetArg returns the value of Arg if it is set or its
// default value if it is unset.
func (v *Echo_EchoEnum_Args) GetArg() (o Fruit) {
	if v != nil && v.Arg != nil {
		return *v.Arg
	}
	o = FruitApple
	return
}

// IsSetArg returns true if Arg is not nil.
func (v *Echo_EchoEnum_Args) IsSetArg() bool {
	return v != nil && v.Arg != nil
}

// MethodName returns the name of the Thrift function as specified in
// the IDL, for which this struct represent the arguments.
//
// This will always be "echoEnum" for this struct.
func (v *Echo_EchoEnum_Args) MethodName() string {
	return "echoEnum"
}

// EnvelopeType returns the kind of value inside this struct.
//
// This will always be Call for this struct.
func (v *Echo_EchoEnum_Args) EnvelopeType() wire.EnvelopeType {
	return wire.Call
}

// Echo_EchoEnum_Helper provides functions that aid in handling the
// parameters and return values of the Echo.echoEnum
// function.
var Echo_EchoEnum_Helper = struct {
	// Args accepts the parameters of echoEnum in-order and returns
	// the arguments struct for the function.
	Args func(
		arg *Fruit,
	) *Echo_EchoEnum_Args

	// IsException returns true if the given error can be thrown
	// by echoEnum.
	//
	// An error can be thrown by echoEnum only if the
	// corresponding exception type was mentioned in the 'throws'
	// section for it in the Thrift file.
	IsException func(error) bool

	// WrapResponse returns the result struct for echoEnum
	// given its return value and error.
	//
	// This allows mapping values and errors returned by
	// echoEnum into a serializable result struct.
	// WrapResponse returns a non-nil error if the provided
	// error cannot be thrown by echoEnum
	//
	//   value, err := echoEnum(args)
	//   result, err := Echo_EchoEnum_Helper.WrapResponse(value, err)
	//   if err != nil {
	//     return fmt.Errorf("unexpected error from echoEnum: %v", err)
	//   }
	//   serialize(result)
	WrapResponse func(Fruit, error) (*Echo_EchoEnum_Result, error)

	// UnwrapResponse takes the result struct for echoEnum
	// and returns the value or error returned by it.
	//
	// The error is non-nil only if echoEnum threw an
	// exception.
	//
	//   result := deserialize(bytes)
	//   value, err := Echo_EchoEnum_Helper.UnwrapResponse(result)
	UnwrapResponse func(*Echo_EchoEnum_Result) (Fruit, error)
}{}

func init() {
	Echo_EchoEnum_Helper.Args = func(
		arg *Fruit,
	) *Echo_EchoEnum_Args {
		return &Echo_EchoEnum_Args{
			Arg: arg,
		}
	}

	Echo_EchoEnum_Helper.IsException = func(err error) bool {
		switch err.(type) {
		default:
			return false
		}
	}

	Echo_EchoEnum_Helper.WrapResponse = func(success Fruit, err error) (*Echo_EchoEnum_Result, error) {
		if err == nil {
			return &Echo_EchoEnum_Result{Success: &success}, nil
		}

		return nil, err
	}
	Echo_EchoEnum_Helper.UnwrapResponse = func(result *Echo_EchoEnum_Result) (success Fruit, err error) {

		if result.Success != nil {
			success = *result.Success
			return
		}

		err = errors.New("expected a non-void result")
		return
	}

}

// Echo_EchoEnum_Result represents the result of a Echo.echoEnum function call.
//
// The result of a echoEnum execution is sent and received over the wire as this struct.
//
// Success is set only if the function did not throw an exception.
type Echo_EchoEnum_Result struct {
	// Value returned by echoEnum after a successful execution.
	Success *Fruit `json:"success,omitempty"`
}

// ToWire translates a Echo_EchoEnum_Result struct into a Thrift-level intermediate
// representation. This intermediate representation may be serialized
// into bytes using a ThriftRW protocol implementation.
//
// An error is returned if the struct or any of its fields failed to
// validate.
//
//   x, err := v.ToWire()
//   if err != nil {
//     return err
//   }
//
//   if err := binaryProtocol.Encode(x, writer); err != nil {
//     return err
//   }
func (v *Echo_EchoEnum_Result) ToWire() (wire.Value, error) {
	var (
		fields [1]wire.Field
		i      int = 0
		w      wire.Value
		err    error
	)

	if v.Success != nil {
		w, err = v.Success.ToWire()
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 0, Value: w}
		i++
	}

	if i != 1 {
		return wire.Value{}, fmt.Errorf("Echo_EchoEnum_Result should have exactly one field: got %v fields", i)
	}

	return wire.NewValueStruct(wire.Struct{Fields: fields[:i]}), nil
}

// FromWire deserializes a Echo_EchoEnum_Result struct from its Thrift-level
// representation. The Thrift-level representation may be obtained
// from a ThriftRW protocol implementation.
//
// An error is returned if we were unable to build a Echo_EchoEnum_Result struct
// from the provided intermediate representation.
//
//   x, err := binaryProtocol.Decode(reader, wire.TStruct)
//   if err != nil {
//     return nil, err
//   }
//
//   var v Echo_EchoEnum_Result
//   if err := v.FromWire(x); err != nil {
//     return nil, err
//   }
//   return &v, nil
func (v *Echo_EchoEnum_Result) FromWire(w wire.Value) error {
	var err error

	for _, field := range w.GetStruct().Fields {
		switch field.ID {
		case 0:
			if field.Value.Type() == wire.TI32 {
				var x Fruit
				x, err = _Fruit_Read(field.Value)
				v.Success = &x
				if err != nil {
					return err
				}

			}
		}
	}

	count := 0
	if v.Success != nil {
		count++
	}
	if count != 1 {
		return fmt.Errorf("Echo_EchoEnum_Result should have exactly one field: got %v fields", count)
	}

	return nil
}

// String returns a readable string representation of a Echo_EchoEnum_Result
// struct.
func (v *Echo_EchoEnum_Result) String() string {
	if v == nil {
		return "<nil>"
	}

	var fields [1]string
	i := 0
	if v.Success != nil {
		fields[i] = fmt.Sprintf("Success: %v", *(v.Success))
		i++
	}

	return fmt.Sprintf("Echo_EchoEnum_Result{%v}", strings.Join(fields[:i], ", "))
}

// Equals returns true if all the fields of this Echo_EchoEnum_Result match the
// provided Echo_EchoEnum_Result.
//
// This function performs a deep comparison.
func (v *Echo_EchoEnum_Result) Equals(rhs *Echo_EchoEnum_Result) bool {
	if v == nil {
		return rhs == nil
	} else if rhs == nil {
		return false
	}
	if !_Fruit_EqualsPtr(v.Success, rhs.Success) {
		return false
	}

	return true
}

// MarshalLogObject implements zapcore.ObjectMarshaler, enabling
// fast logging of Echo_EchoEnum_Result.
func (v *Echo_EchoEnum_Result) MarshalLogObject(enc zapcore.ObjectEncoder) (err error) {
	if v == nil {
		return nil
	}
	if v.Success != nil {
		err = multierr.Append(err, enc.AddObject("success", *v.Success))
	}
	return err
}

// GetSuccess returns the value of Success if it is set or its
// zero value if it is unset.
func (v *Echo_EchoEnum_Result) GetSuccess() (o Fruit) {
	if v != nil && v.Success != nil {
		return *v.Success
	}

	return
}

// IsSetSuccess returns true if Success is not nil.
func (v *Echo_EchoEnum_Result) IsSetSuccess() bool {
	return v != nil && v.Success != nil
}

// MethodName returns the name of the Thrift function as specified in
// the IDL, for which this struct represent the result.
//
// This will always be "echoEnum" for this struct.
func (v *Echo_EchoEnum_Result) MethodName() string {
	return "echoEnum"
}

// EnvelopeType returns the kind of value inside this struct.
//
// This will always be Reply for this struct.
func (v *Echo_EchoEnum_Result) EnvelopeType() wire.EnvelopeType {
	return wire.Reply
}

// Echo_EchoI16_Args represents the arguments for the Echo.echoI16 function.
//
// The arguments for echoI16 are sent and received over the wire as this struct.
type Echo_EchoI16_Args struct {
	Arg int16 `json:"arg,required"`
}

// ToWire translates a Echo_EchoI16_Args struct into a Thrift-level intermediate
// representation. This intermediate representation may be serialized
// into bytes using a ThriftRW protocol implementation.
//
// An error is returned if the struct or any of its fields failed to
// validate.
//
//   x, err := v.ToWire()
//   if err != nil {
//     return err
//   }
//
//   if err := binaryProtocol.Encode(x, writer); err != nil {
//     return err
//   }
func (v *Echo_EchoI16_Args) ToWire() (wire.Value, error) {
	var (
		fields [1]wire.Field
		i      int = 0
		w      wire.Value
		err    error
	)

	w, err = wire.NewValueI16(v.Arg), error(nil)
	if err != nil {
		return w, err
	}
	fields[i] = wire.Field{ID: 1, Value: w}
	i++

	return wire.NewValueStruct(wire.Struct{Fields: fields[:i]}), nil
}

// FromWire deserializes a Echo_EchoI16_Args struct from its Thrift-level
// representation. The Thrift-level representation may be obtained
// from a ThriftRW protocol implementation.
//
// An error is returned if we were unable to build a Echo_EchoI16_Args struct
// from the provided intermediate representation.
//
//   x, err := binaryProtocol.Decode(reader, wire.TStruct)
//   if err != nil {
//     return nil, err
//   }
//
//   var v Echo_EchoI16_Args
//   if err := v.FromWire(x); err != nil {
//     return nil, err
//   }
//   return &v, nil
func (v *Echo_EchoI16_Args) FromWire(w wire.Value) error {
	var err error

	argIsSet := false

	for _, field := range w.GetStruct().Fields {
		switch field.ID {
		case 1:
			if field.Value.Type() == wire.TI16 {
				v.Arg, err = field.Value.GetI16(), error(nil)
				if err != nil {
					return err
				}
				argIsSet = true
			}
		}
	}

	if !argIsSet {
		return errors.New("field Arg of Echo_EchoI16_Args is required")
	}

	return nil
}

// String returns a readable string representation of a Echo_EchoI16_Args
// struct.
func (v *Echo_EchoI16_Args) String() string {
	if v == nil {
		return "<nil>"
	}

	var fields [1]string
	i := 0
	fields[i] = fmt.Sprintf("Arg: %v", v.Arg)
	i++

	return fmt.Sprintf("Echo_EchoI16_Args{%v}", strings.Join(fields[:i], ", "))
}

// Equals returns true if all the fields of this Echo_EchoI16_Args match the
// provided Echo_EchoI16_Args.
//
// This function performs a deep comparison.
func (v *Echo_EchoI16_Args) Equals(rhs *Echo_EchoI16_Args) bool {
	if v == nil {
		return rhs == nil
	} else if rhs == nil {
		return false
	}
	if !(v.Arg == rhs.Arg) {
		return false
	}

	return true
}

// MarshalLogObject implements zapcore.ObjectMarshaler, enabling
// fast logging of Echo_EchoI16_Args.
func (v *Echo_EchoI16_Args) MarshalLogObject(enc zapcore.ObjectEncoder) (err error) {
	if v == nil {
		return nil
	}
	enc.AddInt16("arg", v.Arg)
	return err
}

// GetArg returns the value of Arg if it is set or its
// zero value if it is unset.
func (v *Echo_EchoI16_Args) GetArg() (o int16) {
	if v != nil {
		o = v.Arg
	}
	return
}

// MethodName returns the name of the Thrift function as specified in
// the IDL, for which this struct represent the arguments.
//
// This will always be "echoI16" for this struct.
func (v *Echo_EchoI16_Args) MethodName() string {
	return "echoI16"
}

// EnvelopeType returns the kind of value inside this struct.
//
// This will always be Call for this struct.
func (v *Echo_EchoI16_Args) EnvelopeType() wire.EnvelopeType {
	return wire.Call
}

// Echo_EchoI16_Helper provides functions that aid in handling the
// parameters and return values of the Echo.echoI16
// function.
var Echo_EchoI16_Helper = struct {
	// Args accepts the parameters of echoI16 in-order and returns
	// the arguments struct for the function.
	Args func(
		arg int16,
	) *Echo_EchoI16_Args

	// IsException returns true if the given error can be thrown
	// by echoI16.
	//
	// An error can be thrown by echoI16 only if the
	// corresponding exception type was mentioned in the 'throws'
	// section for it in the Thrift file.
	IsException func(error) bool

	// WrapResponse returns the result struct for echoI16
	// given its return value and error.
	//
	// This allows mapping values and errors returned by
	// echoI16 into a serializable result struct.
	// WrapResponse returns a non-nil error if the provided
	// error cannot be thrown by echoI16
	//
	//   value, err := echoI16(args)
	//   result, err := Echo_EchoI16_Helper.WrapResponse(value, err)
	//   if err != nil {
	//     return fmt.Errorf("unexpected error from echoI16: %v", err)
	//   }
	//   serialize(result)
	WrapResponse func(int16, error) (*Echo_EchoI16_Result, error)

	// UnwrapResponse takes the result struct for echoI16
	// and returns the value or error returned by it.
	//
	// The error is non-nil only if echoI16 threw an
	// exception.
	//
	//   result := deserialize(bytes)
	//   value, err := Echo_EchoI16_Helper.UnwrapResponse(result)
	UnwrapResponse func(*Echo_EchoI16_Result) (int16, error)
}{}

func init() {
	Echo_EchoI16_Helper.Args = func(
		arg int16,
	) *Echo_EchoI16_Args {
		return &Echo_EchoI16_Args{
			Arg: arg,
		}
	}

	Echo_EchoI16_Helper.IsException = func(err error) bool {
		switch err.(type) {
		default:
			return false
		}
	}

	Echo_EchoI16_Helper.WrapResponse = func(success int16, err error) (*Echo_EchoI16_Result, error) {
		if err == nil {
			return &Echo_EchoI16_Result{Success: &success}, nil
		}

		return nil, err
	}
	Echo_EchoI16_Helper.UnwrapResponse = func(result *Echo_EchoI16_Result) (success int16, err error) {

		if result.Success != nil {
			success = *result.Success
			return
		}

		err = errors.New("expected a non-void result")
		return
	}

}

// Echo_EchoI16_Result represents the result of a Echo.echoI16 function call.
//
// The result of a echoI16 execution is sent and received over the wire as this struct.
//
// Success is set only if the function did not throw an exception.
type Echo_EchoI16_Result struct {
	// Value returned by echoI16 after a successful execution.
	Success *int16 `json:"success,omitempty"`
}

// ToWire translates a Echo_EchoI16_Result struct into a Thrift-level intermediate
// representation. This intermediate representation may be serialized
// into bytes using a ThriftRW protocol implementation.
//
// An error is returned if the struct or any of its fields failed to
// validate.
//
//   x, err := v.ToWire()
//   if err != nil {
//     return err
//   }
//
//   if err := binaryProtocol.Encode(x, writer); err != nil {
//     return err
//   }
func (v *Echo_EchoI16_Result) ToWire() (wire.Value, error) {
	var (
		fields [1]wire.Field
		i      int = 0
		w      wire.Value
		err    error
	)

	if v.Success != nil {
		w, err = wire.NewValueI16(*(v.Success)), error(nil)
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 0, Value: w}
		i++
	}

	if i != 1 {
		return wire.Value{}, fmt.Errorf("Echo_EchoI16_Result should have exactly one field: got %v fields", i)
	}

	return wire.NewValueStruct(wire.Struct{Fields: fields[:i]}), nil
}

// FromWire deserializes a Echo_EchoI16_Result struct from its Thrift-level
// representation. The Thrift-level representation may be obtained
// from a ThriftRW protocol implementation.
//
// An error is returned if we were unable to build a Echo_EchoI16_Result struct
// from the provided intermediate representation.
//
//   x, err := binaryProtocol.Decode(reader, wire.TStruct)
//   if err != nil {
//     return nil, err
//   }
//
//   var v Echo_EchoI16_Result
//   if err := v.FromWire(x); err != nil {
//     return nil, err
//   }
//   return &v, nil
func (v *Echo_EchoI16_Result) FromWire(w wire.Value) error {
	var err error

	for _, field := range w.GetStruct().Fields {
		switch field.ID {
		case 0:
			if field.Value.Type() == wire.TI16 {
				var x int16
				x, err = field.Value.GetI16(), error(nil)
				v.Success = &x
				if err != nil {
					return err
				}

			}
		}
	}

	count := 0
	if v.Success != nil {
		count++
	}
	if count != 1 {
		return fmt.Errorf("Echo_EchoI16_Result should have exactly one field: got %v fields", count)
	}

	return nil
}

// String returns a readable string representation of a Echo_EchoI16_Result
// struct.
func (v *Echo_EchoI16_Result) String() string {
	if v == nil {
		return "<nil>"
	}

	var fields [1]string
	i := 0
	if v.Success != nil {
		fields[i] = fmt.Sprintf("Success: %v", *(v.Success))
		i++
	}

	return fmt.Sprintf("Echo_EchoI16_Result{%v}", strings.Join(fields[:i], ", "))
}

// Equals returns true if all the fields of this Echo_EchoI16_Result match the
// provided Echo_EchoI16_Result.
//
// This function performs a deep comparison.
func (v *Echo_EchoI16_Result) Equals(rhs *Echo_EchoI16_Result) bool {
	if v == nil {
		return rhs == nil
	} else if rhs == nil {
		return false
	}
	if !_I16_EqualsPtr(v.Success, rhs.Success) {
		return false
	}

	return true
}

// MarshalLogObject implements zapcore.ObjectMarshaler, enabling
// fast logging of Echo_EchoI16_Result.
func (v *Echo_EchoI16_Result) MarshalLogObject(enc zapcore.ObjectEncoder) (err error) {
	if v == nil {
		return nil
	}
	if v.Success != nil {
		enc.AddInt16("success", *v.Success)
	}
	return err
}

// GetSuccess returns the value of Success if it is set or its
// zero value if it is unset.
func (v *Echo_EchoI16_Result) GetSuccess() (o int16) {
	if v != nil && v.Success != nil {
		return *v.Success
	}

	return
}

// IsSetSuccess returns true if Success is not nil.
func (v *Echo_EchoI16_Result) IsSetSuccess() bool {
	return v != nil && v.Success != nil
}

// MethodName returns the name of the Thrift function as specified in
// the IDL, for which this struct represent the result.
//
// This will always be "echoI16" for this struct.
func (v *Echo_EchoI16_Result) MethodName() string {
	return "echoI16"
}

// EnvelopeType returns the kind of value inside this struct.
//
// This will always be Reply for this struct.
func (v *Echo_EchoI16_Result) EnvelopeType() wire.EnvelopeType {
	return wire.Reply
}

// Echo_EchoI32_Args represents the arguments for the Echo.echoI32 function.
//
// The arguments for echoI32 are sent and received over the wire as this struct.
type Echo_EchoI32_Args struct {
	Arg int32 `json:"arg,required"`
}

// ToWire translates a Echo_EchoI32_Args struct into a Thrift-level intermediate
// representation. This intermediate representation may be serialized
// into bytes using a ThriftRW protocol implementation.
//
// An error is returned if the struct or any of its fields failed to
// validate.
//
//   x, err := v.ToWire()
//   if err != nil {
//     return err
//   }
//
//   if err := binaryProtocol.Encode(x, writer); err != nil {
//     return err
//   }
func (v *Echo_EchoI32_Args) ToWire() (wire.Value, error) {
	var (
		fields [1]wire.Field
		i      int = 0
		w      wire.Value
		err    error
	)

	w, err = wire.NewValueI32(v.Arg), error(nil)
	if err != nil {
		return w, err
	}
	fields[i] = wire.Field{ID: 1, Value: w}
	i++

	return wire.NewValueStruct(wire.Struct{Fields: fields[:i]}), nil
}

// FromWire deserializes a Echo_EchoI32_Args struct from its Thrift-level
// representation. The Thrift-level representation may be obtained
// from a ThriftRW protocol implementation.
//
// An error is returned if we were unable to build a Echo_EchoI32_Args struct
// from the provided intermediate representation.
//
//   x, err := binaryProtocol.Decode(reader, wire.TStruct)
//   if err != nil {
//     return nil, err
//   }
//
//   var v Echo_EchoI32_Args
//   if err := v.FromWire(x); err != nil {
//     return nil, err
//   }
//   return &v, nil
func (v *Echo_EchoI32_Args) FromWire(w wire.Value) error {
	var err error

	argIsSet := false

	for _, field := range w.GetStruct().Fields {
		switch field.ID {
		case 1:
			if field.Value.Type() == wire.TI32 {
				v.Arg, err = field.Value.GetI32(), error(nil)
				if err != nil {
					return err
				}
				argIsSet = true
			}
		}
	}

	if !argIsSet {
		return errors.New("field Arg of Echo_EchoI32_Args is required")
	}

	return nil
}

// String returns a readable string representation of a Echo_EchoI32_Args
// struct.
func (v *Echo_EchoI32_Args) String() string {
	if v == nil {
		return "<nil>"
	}

	var fields [1]string
	i := 0
	fields[i] = fmt.Sprintf("Arg: %v", v.Arg)
	i++

	return fmt.Sprintf("Echo_EchoI32_Args{%v}", strings.Join(fields[:i], ", "))
}

// Equals returns true if all the fields of this Echo_EchoI32_Args match the
// provided Echo_EchoI32_Args.
//
// This function performs a deep comparison.
func (v *Echo_EchoI32_Args) Equals(rhs *Echo_EchoI32_Args) bool {
	if v == nil {
		return rhs == nil
	} else if rhs == nil {
		return false
	}
	if !(v.Arg == rhs.Arg) {
		return false
	}

	return true
}

// MarshalLogObject implements zapcore.ObjectMarshaler, enabling
// fast logging of Echo_EchoI32_Args.
func (v *Echo_EchoI32_Args) MarshalLogObject(enc zapcore.ObjectEncoder) (err error) {
	if v == nil {
		return nil
	}
	enc.AddInt32("arg", v.Arg)
	return err
}

// GetArg returns the value of Arg if it is set or its
// zero value if it is unset.
func (v *Echo_EchoI32_Args) GetArg() (o int32) {
	if v != nil {
		o = v.Arg
	}
	return
}

// MethodName returns the name of the Thrift function as specified in
// the IDL, for which this struct represent the arguments.
//
// This will always be "echoI32" for this struct.
func (v *Echo_EchoI32_Args) MethodName() string {
	return "echoI32"
}

// EnvelopeType returns the kind of value inside this struct.
//
// This will always be Call for this struct.
func (v *Echo_EchoI32_Args) EnvelopeType() wire.EnvelopeType {
	return wire.Call
}

// Echo_EchoI32_Helper provides functions that aid in handling the
// parameters and return values of the Echo.echoI32
// function.
var Echo_EchoI32_Helper = struct {
	// Args accepts the parameters of echoI32 in-order and returns
	// the arguments struct for the function.
	Args func(
		arg int32,
	) *Echo_EchoI32_Args

	// IsException returns true if the given error can be thrown
	// by echoI32.
	//
	// An error can be thrown by echoI32 only if the
	// corresponding exception type was mentioned in the 'throws'
	// section for it in the Thrift file.
	IsException func(error) bool

	// WrapResponse returns the result struct for echoI32
	// given its return value and error.
	//
	// This allows mapping values and errors returned by
	// echoI32 into a serializable result struct.
	// WrapResponse returns a non-nil error if the provided
	// error cannot be thrown by echoI32
	//
	//   value, err := echoI32(args)
	//   result, err := Echo_EchoI32_Helper.WrapResponse(value, err)
	//   if err != nil {
	//     return fmt.Errorf("unexpected error from echoI32: %v", err)
	//   }
	//   serialize(result)
	WrapResponse func(int32, error) (*Echo_EchoI32_Result, error)

	// UnwrapResponse takes the result struct for echoI32
	// and returns the value or error returned by it.
	//
	// The error is non-nil only if echoI32 threw an
	// exception.
	//
	//   result := deserialize(bytes)
	//   value, err := Echo_EchoI32_Helper.UnwrapResponse(result)
	UnwrapResponse func(*Echo_EchoI32_Result) (int32, error)
}{}

func init() {
	Echo_EchoI32_Helper.Args = func(
		arg int32,
	) *Echo_EchoI32_Args {
		return &Echo_EchoI32_Args{
			Arg: arg,
		}
	}

	Echo_EchoI32_Helper.IsException = func(err error) bool {
		switch err.(type) {
		default:
			return false
		}
	}

	Echo_EchoI32_Helper.WrapResponse = func(success int32, err error) (*Echo_EchoI32_Result, error) {
		if err == nil {
			return &Echo_EchoI32_Result{Success: &success}, nil
		}

		return nil, err
	}
	Echo_EchoI32_Helper.UnwrapResponse = func(result *Echo_EchoI32_Result) (success int32, err error) {

		if result.Success != nil {
			success = *result.Success
			return
		}

		err = errors.New("expected a non-void result")
		return
	}

}

// Echo_EchoI32_Result represents the result of a Echo.echoI32 function call.
//
// The result of a echoI32 execution is sent and received over the wire as this struct.
//
// Success is set only if the function did not throw an exception.
type Echo_EchoI32_Result struct {
	// Value returned by echoI32 after a successful execution.
	Success *int32 `json:"success,omitempty"`
}

// ToWire translates a Echo_EchoI32_Result struct into a Thrift-level intermediate
// representation. This intermediate representation may be serialized
// into bytes using a ThriftRW protocol implementation.
//
// An error is returned if the struct or any of its fields failed to
// validate.
//
//   x, err := v.ToWire()
//   if err != nil {
//     return err
//   }
//
//   if err := binaryProtocol.Encode(x, writer); err != nil {
//     return err
//   }
func (v *Echo_EchoI32_Result) ToWire() (wire.Value, error) {
	var (
		fields [1]wire.Field
		i      int = 0
		w      wire.Value
		err    error
	)

	if v.Success != nil {
		w, err = wire.NewValueI32(*(v.Success)), error(nil)
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 0, Value: w}
		i++
	}

	if i != 1 {
		return wire.Value{}, fmt.Errorf("Echo_EchoI32_Result should have exactly one field: got %v fields", i)
	}

	return wire.NewValueStruct(wire.Struct{Fields: fields[:i]}), nil
}

// FromWire deserializes a Echo_EchoI32_Result struct from its Thrift-level
// representation. The Thrift-level representation may be obtained
// from a ThriftRW protocol implementation.
//
// An error is returned if we were unable to build a Echo_EchoI32_Result struct
// from the provided intermediate representation.
//
//   x, err := binaryProtocol.Decode(reader, wire.TStruct)
//   if err != nil {
//     return nil, err
//   }
//
//   var v Echo_EchoI32_Result
//   if err := v.FromWire(x); err != nil {
//     return nil, err
//   }
//   return &v, nil
func (v *Echo_EchoI32_Result) FromWire(w wire.Value) error {
	var err error

	for _, field := range w.GetStruct().Fields {
		switch field.ID {
		case 0:
			if field.Value.Type() == wire.TI32 {
				var x int32
				x, err = field.Value.GetI32(), error(nil)
				v.Success = &x
				if err != nil {
					return err
				}

			}
		}
	}

	count := 0
	if v.Success != nil {
		count++
	}
	if count != 1 {
		return fmt.Errorf("Echo_EchoI32_Result should have exactly one field: got %v fields", count)
	}

	return nil
}

// String returns a readable string representation of a Echo_EchoI32_Result
// struct.
func (v *Echo_EchoI32_Result) String() string {
	if v == nil {
		return "<nil>"
	}

	var fields [1]string
	i := 0
	if v.Success != nil {
		fields[i] = fmt.Sprintf("Success: %v", *(v.Success))
		i++
	}

	return fmt.Sprintf("Echo_EchoI32_Result{%v}", strings.Join(fields[:i], ", "))
}

// Equals returns true if all the fields of this Echo_EchoI32_Result match the
// provided Echo_EchoI32_Result.
//
// This function performs a deep comparison.
func (v *Echo_EchoI32_Result) Equals(rhs *Echo_EchoI32_Result) bool {
	if v == nil {
		return rhs == nil
	} else if rhs == nil {
		return false
	}
	if !_I32_EqualsPtr(v.Success, rhs.Success) {
		return false
	}

	return true
}

// MarshalLogObject implements zapcore.ObjectMarshaler, enabling
// fast logging of Echo_EchoI32_Result.
func (v *Echo_EchoI32_Result) MarshalLogObject(enc zapcore.ObjectEncoder) (err error) {
	if v == nil {
		return nil
	}
	if v.Success != nil {
		enc.AddInt32("success", *v.Success)
	}
	return err
}

// GetSuccess returns the value of Success if it is set or its
// zero value if it is unset.
func (v *Echo_EchoI32_Result) GetSuccess() (o int32) {
	if v != nil && v.Success != nil {
		return *v.Success
	}

	return
}

// IsSetSuccess returns true if Success is not nil.
func (v *Echo_EchoI32_Result) IsSetSuccess() bool {
	return v != nil && v.Success != nil
}

// MethodName returns the name of the Thrift function as specified in
// the IDL, for which this struct represent the result.
//
// This will always be "echoI32" for this struct.
func (v *Echo_EchoI32_Result) MethodName() string {
	return "echoI32"
}

// EnvelopeType returns the kind of value inside this struct.
//
// This will always be Reply for this struct.
func (v *Echo_EchoI32_Result) EnvelopeType() wire.EnvelopeType {
	return wire.Reply
}

// Echo_EchoI32Map_Args represents the arguments for the Echo.echoI32Map function.
//
// The arguments for echoI32Map are sent and received over the wire as this struct.
type Echo_EchoI32Map_Args struct {
	Arg map[int32]*BarResponse `json:"arg,required"`
}

type _Map_I32_BarResponse_MapItemList map[int32]*BarResponse

func (m _Map_I32_BarResponse_MapItemList) ForEach(f func(wire.MapItem) error) error {
	for k, v := range m {
		if v == nil {
			return fmt.Errorf("invalid [%v]: value is nil", k)
		}
		kw, err := wire.NewValueI32(k), error(nil)
		if err != nil {
			return err
		}

		vw, err := v.ToWire()
		if err != nil {
			return err
		}
		err = f(wire.MapItem{Key: kw, Value: vw})
		if err != nil {
			return err
		}
	}
	return nil
}

func (m _Map_I32_BarResponse_MapItemList) Size() int {
	return len(m)
}

func (_Map_I32_BarResponse_MapItemList) KeyType() wire.Type {
	return wire.TI32
}

func (_Map_I32_BarResponse_MapItemList) ValueType() wire.Type {
	return wire.TStruct
}

func (_Map_I32_BarResponse_MapItemList) Close() {}

// ToWire translates a Echo_EchoI32Map_Args struct into a Thrift-level intermediate
// representation. This intermediate representation may be serialized
// into bytes using a ThriftRW protocol implementation.
//
// An error is returned if the struct or any of its fields failed to
// validate.
//
//   x, err := v.ToWire()
//   if err != nil {
//     return err
//   }
//
//   if err := binaryProtocol.Encode(x, writer); err != nil {
//     return err
//   }
func (v *Echo_EchoI32Map_Args) ToWire() (wire.Value, error) {
	var (
		fields [1]wire.Field
		i      int = 0
		w      wire.Value
		err    error
	)

	if v.Arg == nil {
		return w, errors.New("field Arg of Echo_EchoI32Map_Args is required")
	}
	w, err = wire.NewValueMap(_Map_I32_BarResponse_MapItemList(v.Arg)), error(nil)
	if err != nil {
		return w, err
	}
	fields[i] = wire.Field{ID: 1, Value: w}
	i++

	return wire.NewValueStruct(wire.Struct{Fields: fields[:i]}), nil
}

func _Map_I32_BarResponse_Read(m wire.MapItemList) (map[int32]*BarResponse, error) {
	if m.KeyType() != wire.TI32 {
		return nil, nil
	}

	if m.ValueType() != wire.TStruct {
		return nil, nil
	}

	o := make(map[int32]*BarResponse, m.Size())
	err := m.ForEach(func(x wire.MapItem) error {
		k, err := x.Key.GetI32(), error(nil)
		if err != nil {
			return err
		}

		v, err := _BarResponse_Read(x.Value)
		if err != nil {
			return err
		}

		o[k] = v
		return nil
	})
	m.Close()
	return o, err
}

// FromWire deserializes a Echo_EchoI32Map_Args struct from its Thrift-level
// representation. The Thrift-level representation may be obtained
// from a ThriftRW protocol implementation.
//
// An error is returned if we were unable to build a Echo_EchoI32Map_Args struct
// from the provided intermediate representation.
//
//   x, err := binaryProtocol.Decode(reader, wire.TStruct)
//   if err != nil {
//     return nil, err
//   }
//
//   var v Echo_EchoI32Map_Args
//   if err := v.FromWire(x); err != nil {
//     return nil, err
//   }
//   return &v, nil
func (v *Echo_EchoI32Map_Args) FromWire(w wire.Value) error {
	var err error

	argIsSet := false

	for _, field := range w.GetStruct().Fields {
		switch field.ID {
		case 1:
			if field.Value.Type() == wire.TMap {
				v.Arg, err = _Map_I32_BarResponse_Read(field.Value.GetMap())
				if err != nil {
					return err
				}
				argIsSet = true
			}
		}
	}

	if !argIsSet {
		return errors.New("field Arg of Echo_EchoI32Map_Args is required")
	}

	return nil
}

// String returns a readable string representation of a Echo_EchoI32Map_Args
// struct.
func (v *Echo_EchoI32Map_Args) String() string {
	if v == nil {
		return "<nil>"
	}

	var fields [1]string
	i := 0
	fields[i] = fmt.Sprintf("Arg: %v", v.Arg)
	i++

	return fmt.Sprintf("Echo_EchoI32Map_Args{%v}", strings.Join(fields[:i], ", "))
}

func _Map_I32_BarResponse_Equals(lhs, rhs map[int32]*BarResponse) bool {
	if len(lhs) != len(rhs) {
		return false
	}

	for lk, lv := range lhs {
		rv, ok := rhs[lk]
		if !ok {
			return false
		}
		if !lv.Equals(rv) {
			return false
		}
	}
	return true
}

// Equals returns true if all the fields of this Echo_EchoI32Map_Args match the
// provided Echo_EchoI32Map_Args.
//
// This function performs a deep comparison.
func (v *Echo_EchoI32Map_Args) Equals(rhs *Echo_EchoI32Map_Args) bool {
	if v == nil {
		return rhs == nil
	} else if rhs == nil {
		return false
	}
	if !_Map_I32_BarResponse_Equals(v.Arg, rhs.Arg) {
		return false
	}

	return true
}

type _Map_I32_BarResponse_Item_Zapper struct {
	Key   int32
	Value *BarResponse
}

// MarshalLogArray implements zapcore.ArrayMarshaler, enabling
// fast logging of _Map_I32_BarResponse_Item_Zapper.
func (v _Map_I32_BarResponse_Item_Zapper) MarshalLogObject(enc zapcore.ObjectEncoder) (err error) {
	enc.AddInt32("key", v.Key)
	err = multierr.Append(err, enc.AddObject("value", v.Value))
	return err
}

type _Map_I32_BarResponse_Zapper map[int32]*BarResponse

// MarshalLogArray implements zapcore.ArrayMarshaler, enabling
// fast logging of _Map_I32_BarResponse_Zapper.
func (m _Map_I32_BarResponse_Zapper) MarshalLogArray(enc zapcore.ArrayEncoder) (err error) {
	for k, v := range m {
		err = multierr.Append(err, enc.AppendObject(_Map_I32_BarResponse_Item_Zapper{Key: k, Value: v}))
	}
	return err
}

// MarshalLogObject implements zapcore.ObjectMarshaler, enabling
// fast logging of Echo_EchoI32Map_Args.
func (v *Echo_EchoI32Map_Args) MarshalLogObject(enc zapcore.ObjectEncoder) (err error) {
	if v == nil {
		return nil
	}
	err = multierr.Append(err, enc.AddArray("arg", (_Map_I32_BarResponse_Zapper)(v.Arg)))
	return err
}

// GetArg returns the value of Arg if it is set or its
// zero value if it is unset.
func (v *Echo_EchoI32Map_Args) GetArg() (o map[int32]*BarResponse) {
	if v != nil {
		o = v.Arg
	}
	return
}

// IsSetArg returns true if Arg is not nil.
func (v *Echo_EchoI32Map_Args) IsSetArg() bool {
	return v != nil && v.Arg != nil
}

// MethodName returns the name of the Thrift function as specified in
// the IDL, for which this struct represent the arguments.
//
// This will always be "echoI32Map" for this struct.
func (v *Echo_EchoI32Map_Args) MethodName() string {
	return "echoI32Map"
}

// EnvelopeType returns the kind of value inside this struct.
//
// This will always be Call for this struct.
func (v *Echo_EchoI32Map_Args) EnvelopeType() wire.EnvelopeType {
	return wire.Call
}

// Echo_EchoI32Map_Helper provides functions that aid in handling the
// parameters and return values of the Echo.echoI32Map
// function.
var Echo_EchoI32Map_Helper = struct {
	// Args accepts the parameters of echoI32Map in-order and returns
	// the arguments struct for the function.
	Args func(
		arg map[int32]*BarResponse,
	) *Echo_EchoI32Map_Args

	// IsException returns true if the given error can be thrown
	// by echoI32Map.
	//
	// An error can be thrown by echoI32Map only if the
	// corresponding exception type was mentioned in the 'throws'
	// section for it in the Thrift file.
	IsException func(error) bool

	// WrapResponse returns the result struct for echoI32Map
	// given its return value and error.
	//
	// This allows mapping values and errors returned by
	// echoI32Map into a serializable result struct.
	// WrapResponse returns a non-nil error if the provided
	// error cannot be thrown by echoI32Map
	//
	//   value, err := echoI32Map(args)
	//   result, err := Echo_EchoI32Map_Helper.WrapResponse(value, err)
	//   if err != nil {
	//     return fmt.Errorf("unexpected error from echoI32Map: %v", err)
	//   }
	//   serialize(result)
	WrapResponse func(map[int32]*BarResponse, error) (*Echo_EchoI32Map_Result, error)

	// UnwrapResponse takes the result struct for echoI32Map
	// and returns the value or error returned by it.
	//
	// The error is non-nil only if echoI32Map threw an
	// exception.
	//
	//   result := deserialize(bytes)
	//   value, err := Echo_EchoI32Map_Helper.UnwrapResponse(result)
	UnwrapResponse func(*Echo_EchoI32Map_Result) (map[int32]*BarResponse, error)
}{}

func init() {
	Echo_EchoI32Map_Helper.Args = func(
		arg map[int32]*BarResponse,
	) *Echo_EchoI32Map_Args {
		return &Echo_EchoI32Map_Args{
			Arg: arg,
		}
	}

	Echo_EchoI32Map_Helper.IsException = func(err error) bool {
		switch err.(type) {
		default:
			return false
		}
	}

	Echo_EchoI32Map_Helper.WrapResponse = func(success map[int32]*BarResponse, err error) (*Echo_EchoI32Map_Result, error) {
		if err == nil {
			return &Echo_EchoI32Map_Result{Success: success}, nil
		}

		return nil, err
	}
	Echo_EchoI32Map_Helper.UnwrapResponse = func(result *Echo_EchoI32Map_Result) (success map[int32]*BarResponse, err error) {

		if result.Success != nil {
			success = result.Success
			return
		}

		err = errors.New("expected a non-void result")
		return
	}

}

// Echo_EchoI32Map_Result represents the result of a Echo.echoI32Map function call.
//
// The result of a echoI32Map execution is sent and received over the wire as this struct.
//
// Success is set only if the function did not throw an exception.
type Echo_EchoI32Map_Result struct {
	// Value returned by echoI32Map after a successful execution.
	Success map[int32]*BarResponse `json:"success,omitempty"`
}

// ToWire translates a Echo_EchoI32Map_Result struct into a Thrift-level intermediate
// representation. This intermediate representation may be serialized
// into bytes using a ThriftRW protocol implementation.
//
// An error is returned if the struct or any of its fields failed to
// validate.
//
//   x, err := v.ToWire()
//   if err != nil {
//     return err
//   }
//
//   if err := binaryProtocol.Encode(x, writer); err != nil {
//     return err
//   }
func (v *Echo_EchoI32Map_Result) ToWire() (wire.Value, error) {
	var (
		fields [1]wire.Field
		i      int = 0
		w      wire.Value
		err    error
	)

	if v.Success != nil {
		w, err = wire.NewValueMap(_Map_I32_BarResponse_MapItemList(v.Success)), error(nil)
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 0, Value: w}
		i++
	}

	if i != 1 {
		return wire.Value{}, fmt.Errorf("Echo_EchoI32Map_Result should have exactly one field: got %v fields", i)
	}

	return wire.NewValueStruct(wire.Struct{Fields: fields[:i]}), nil
}

// FromWire deserializes a Echo_EchoI32Map_Result struct from its Thrift-level
// representation. The Thrift-level representation may be obtained
// from a ThriftRW protocol implementation.
//
// An error is returned if we were unable to build a Echo_EchoI32Map_Result struct
// from the provided intermediate representation.
//
//   x, err := binaryProtocol.Decode(reader, wire.TStruct)
//   if err != nil {
//     return nil, err
//   }
//
//   var v Echo_EchoI32Map_Result
//   if err := v.FromWire(x); err != nil {
//     return nil, err
//   }
//   return &v, nil
func (v *Echo_EchoI32Map_Result) FromWire(w wire.Value) error {
	var err error

	for _, field := range w.GetStruct().Fields {
		switch field.ID {
		case 0:
			if field.Value.Type() == wire.TMap {
				v.Success, err = _Map_I32_BarResponse_Read(field.Value.GetMap())
				if err != nil {
					return err
				}

			}
		}
	}

	count := 0
	if v.Success != nil {
		count++
	}
	if count != 1 {
		return fmt.Errorf("Echo_EchoI32Map_Result should have exactly one field: got %v fields", count)
	}

	return nil
}

// String returns a readable string representation of a Echo_EchoI32Map_Result
// struct.
func (v *Echo_EchoI32Map_Result) String() string {
	if v == nil {
		return "<nil>"
	}

	var fields [1]string
	i := 0
	if v.Success != nil {
		fields[i] = fmt.Sprintf("Success: %v", v.Success)
		i++
	}

	return fmt.Sprintf("Echo_EchoI32Map_Result{%v}", strings.Join(fields[:i], ", "))
}

// Equals returns true if all the fields of this Echo_EchoI32Map_Result match the
// provided Echo_EchoI32Map_Result.
//
// This function performs a deep comparison.
func (v *Echo_EchoI32Map_Result) Equals(rhs *Echo_EchoI32Map_Result) bool {
	if v == nil {
		return rhs == nil
	} else if rhs == nil {
		return false
	}
	if !((v.Success == nil && rhs.Success == nil) || (v.Success != nil && rhs.Success != nil && _Map_I32_BarResponse_Equals(v.Success, rhs.Success))) {
		return false
	}

	return true
}

// MarshalLogObject implements zapcore.ObjectMarshaler, enabling
// fast logging of Echo_EchoI32Map_Result.
func (v *Echo_EchoI32Map_Result) MarshalLogObject(enc zapcore.ObjectEncoder) (err error) {
	if v == nil {
		return nil
	}
	if v.Success != nil {
		err = multierr.Append(err, enc.AddArray("success", (_Map_I32_BarResponse_Zapper)(v.Success)))
	}
	return err
}

// GetSuccess returns the value of Success if it is set or its
// zero value if it is unset.
func (v *Echo_EchoI32Map_Result) GetSuccess() (o map[int32]*BarResponse) {
	if v != nil && v.Success != nil {
		return v.Success
	}

	return
}

// IsSetSuccess returns true if Success is not nil.
func (v *Echo_EchoI32Map_Result) IsSetSuccess() bool {
	return v != nil && v.Success != nil
}

// MethodName returns the name of the Thrift function as specified in
// the IDL, for which this struct represent the result.
//
// This will always be "echoI32Map" for this struct.
func (v *Echo_EchoI32Map_Result) MethodName() string {
	return "echoI32Map"
}

// EnvelopeType returns the kind of value inside this struct.
//
// This will always be Reply for this struct.
func (v *Echo_EchoI32Map_Result) EnvelopeType() wire.EnvelopeType {
	return wire.Reply
}

// Echo_EchoI64_Args represents the arguments for the Echo.echoI64 function.
//
// The arguments for echoI64 are sent and received over the wire as this struct.
type Echo_EchoI64_Args struct {
	Arg int64 `json:"arg,required"`
}

// ToWire translates a Echo_EchoI64_Args struct into a Thrift-level intermediate
// representation. This intermediate representation may be serialized
// into bytes using a ThriftRW protocol implementation.
//
// An error is returned if the struct or any of its fields failed to
// validate.
//
//   x, err := v.ToWire()
//   if err != nil {
//     return err
//   }
//
//   if err := binaryProtocol.Encode(x, writer); err != nil {
//     return err
//   }
func (v *Echo_EchoI64_Args) ToWire() (wire.Value, error) {
	var (
		fields [1]wire.Field
		i      int = 0
		w      wire.Value
		err    error
	)

	w, err = wire.NewValueI64(v.Arg), error(nil)
	if err != nil {
		return w, err
	}
	fields[i] = wire.Field{ID: 1, Value: w}
	i++

	return wire.NewValueStruct(wire.Struct{Fields: fields[:i]}), nil
}

// FromWire deserializes a Echo_EchoI64_Args struct from its Thrift-level
// representation. The Thrift-level representation may be obtained
// from a ThriftRW protocol implementation.
//
// An error is returned if we were unable to build a Echo_EchoI64_Args struct
// from the provided intermediate representation.
//
//   x, err := binaryProtocol.Decode(reader, wire.TStruct)
//   if err != nil {
//     return nil, err
//   }
//
//   var v Echo_EchoI64_Args
//   if err := v.FromWire(x); err != nil {
//     return nil, err
//   }
//   return &v, nil
func (v *Echo_EchoI64_Args) FromWire(w wire.Value) error {
	var err error

	argIsSet := false

	for _, field := range w.GetStruct().Fields {
		switch field.ID {
		case 1:
			if field.Value.Type() == wire.TI64 {
				v.Arg, err = field.Value.GetI64(), error(nil)
				if err != nil {
					return err
				}
				argIsSet = true
			}
		}
	}

	if !argIsSet {
		return errors.New("field Arg of Echo_EchoI64_Args is required")
	}

	return nil
}

// String returns a readable string representation of a Echo_EchoI64_Args
// struct.
func (v *Echo_EchoI64_Args) String() string {
	if v == nil {
		return "<nil>"
	}

	var fields [1]string
	i := 0
	fields[i] = fmt.Sprintf("Arg: %v", v.Arg)
	i++

	return fmt.Sprintf("Echo_EchoI64_Args{%v}", strings.Join(fields[:i], ", "))
}

// Equals returns true if all the fields of this Echo_EchoI64_Args match the
// provided Echo_EchoI64_Args.
//
// This function performs a deep comparison.
func (v *Echo_EchoI64_Args) Equals(rhs *Echo_EchoI64_Args) bool {
	if v == nil {
		return rhs == nil
	} else if rhs == nil {
		return false
	}
	if !(v.Arg == rhs.Arg) {
		return false
	}

	return true
}

// MarshalLogObject implements zapcore.ObjectMarshaler, enabling
// fast logging of Echo_EchoI64_Args.
func (v *Echo_EchoI64_Args) MarshalLogObject(enc zapcore.ObjectEncoder) (err error) {
	if v == nil {
		return nil
	}
	enc.AddInt64("arg", v.Arg)
	return err
}

// GetArg returns the value of Arg if it is set or its
// zero value if it is unset.
func (v *Echo_EchoI64_Args) GetArg() (o int64) {
	if v != nil {
		o = v.Arg
	}
	return
}

// MethodName returns the name of the Thrift function as specified in
// the IDL, for which this struct represent the arguments.
//
// This will always be "echoI64" for this struct.
func (v *Echo_EchoI64_Args) MethodName() string {
	return "echoI64"
}

// EnvelopeType returns the kind of value inside this struct.
//
// This will always be Call for this struct.
func (v *Echo_EchoI64_Args) EnvelopeType() wire.EnvelopeType {
	return wire.Call
}

// Echo_EchoI64_Helper provides functions that aid in handling the
// parameters and return values of the Echo.echoI64
// function.
var Echo_EchoI64_Helper = struct {
	// Args accepts the parameters of echoI64 in-order and returns
	// the arguments struct for the function.
	Args func(
		arg int64,
	) *Echo_EchoI64_Args

	// IsException returns true if the given error can be thrown
	// by echoI64.
	//
	// An error can be thrown by echoI64 only if the
	// corresponding exception type was mentioned in the 'throws'
	// section for it in the Thrift file.
	IsException func(error) bool

	// WrapResponse returns the result struct for echoI64
	// given its return value and error.
	//
	// This allows mapping values and errors returned by
	// echoI64 into a serializable result struct.
	// WrapResponse returns a non-nil error if the provided
	// error cannot be thrown by echoI64
	//
	//   value, err := echoI64(args)
	//   result, err := Echo_EchoI64_Helper.WrapResponse(value, err)
	//   if err != nil {
	//     return fmt.Errorf("unexpected error from echoI64: %v", err)
	//   }
	//   serialize(result)
	WrapResponse func(int64, error) (*Echo_EchoI64_Result, error)

	// UnwrapResponse takes the result struct for echoI64
	// and returns the value or error returned by it.
	//
	// The error is non-nil only if echoI64 threw an
	// exception.
	//
	//   result := deserialize(bytes)
	//   value, err := Echo_EchoI64_Helper.UnwrapResponse(result)
	UnwrapResponse func(*Echo_EchoI64_Result) (int64, error)
}{}

func init() {
	Echo_EchoI64_Helper.Args = func(
		arg int64,
	) *Echo_EchoI64_Args {
		return &Echo_EchoI64_Args{
			Arg: arg,
		}
	}

	Echo_EchoI64_Helper.IsException = func(err error) bool {
		switch err.(type) {
		default:
			return false
		}
	}

	Echo_EchoI64_Helper.WrapResponse = func(success int64, err error) (*Echo_EchoI64_Result, error) {
		if err == nil {
			return &Echo_EchoI64_Result{Success: &success}, nil
		}

		return nil, err
	}
	Echo_EchoI64_Helper.UnwrapResponse = func(result *Echo_EchoI64_Result) (success int64, err error) {

		if result.Success != nil {
			success = *result.Success
			return
		}

		err = errors.New("expected a non-void result")
		return
	}

}

// Echo_EchoI64_Result represents the result of a Echo.echoI64 function call.
//
// The result of a echoI64 execution is sent and received over the wire as this struct.
//
// Success is set only if the function did not throw an exception.
type Echo_EchoI64_Result struct {
	// Value returned by echoI64 after a successful execution.
	Success *int64 `json:"success,omitempty"`
}

// ToWire translates a Echo_EchoI64_Result struct into a Thrift-level intermediate
// representation. This intermediate representation may be serialized
// into bytes using a ThriftRW protocol implementation.
//
// An error is returned if the struct or any of its fields failed to
// validate.
//
//   x, err := v.ToWire()
//   if err != nil {
//     return err
//   }
//
//   if err := binaryProtocol.Encode(x, writer); err != nil {
//     return err
//   }
func (v *Echo_EchoI64_Result) ToWire() (wire.Value, error) {
	var (
		fields [1]wire.Field
		i      int = 0
		w      wire.Value
		err    error
	)

	if v.Success != nil {
		w, err = wire.NewValueI64(*(v.Success)), error(nil)
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 0, Value: w}
		i++
	}

	if i != 1 {
		return wire.Value{}, fmt.Errorf("Echo_EchoI64_Result should have exactly one field: got %v fields", i)
	}

	return wire.NewValueStruct(wire.Struct{Fields: fields[:i]}), nil
}

// FromWire deserializes a Echo_EchoI64_Result struct from its Thrift-level
// representation. The Thrift-level representation may be obtained
// from a ThriftRW protocol implementation.
//
// An error is returned if we were unable to build a Echo_EchoI64_Result struct
// from the provided intermediate representation.
//
//   x, err := binaryProtocol.Decode(reader, wire.TStruct)
//   if err != nil {
//     return nil, err
//   }
//
//   var v Echo_EchoI64_Result
//   if err := v.FromWire(x); err != nil {
//     return nil, err
//   }
//   return &v, nil
func (v *Echo_EchoI64_Result) FromWire(w wire.Value) error {
	var err error

	for _, field := range w.GetStruct().Fields {
		switch field.ID {
		case 0:
			if field.Value.Type() == wire.TI64 {
				var x int64
				x, err = field.Value.GetI64(), error(nil)
				v.Success = &x
				if err != nil {
					return err
				}

			}
		}
	}

	count := 0
	if v.Success != nil {
		count++
	}
	if count != 1 {
		return fmt.Errorf("Echo_EchoI64_Result should have exactly one field: got %v fields", count)
	}

	return nil
}

// String returns a readable string representation of a Echo_EchoI64_Result
// struct.
func (v *Echo_EchoI64_Result) String() string {
	if v == nil {
		return "<nil>"
	}

	var fields [1]string
	i := 0
	if v.Success != nil {
		fields[i] = fmt.Sprintf("Success: %v", *(v.Success))
		i++
	}

	return fmt.Sprintf("Echo_EchoI64_Result{%v}", strings.Join(fields[:i], ", "))
}

// Equals returns true if all the fields of this Echo_EchoI64_Result match the
// provided Echo_EchoI64_Result.
//
// This function performs a deep comparison.
func (v *Echo_EchoI64_Result) Equals(rhs *Echo_EchoI64_Result) bool {
	if v == nil {
		return rhs == nil
	} else if rhs == nil {
		return false
	}
	if !_I64_EqualsPtr(v.Success, rhs.Success) {
		return false
	}

	return true
}

// MarshalLogObject implements zapcore.ObjectMarshaler, enabling
// fast logging of Echo_EchoI64_Result.
func (v *Echo_EchoI64_Result) MarshalLogObject(enc zapcore.ObjectEncoder) (err error) {
	if v == nil {
		return nil
	}
	if v.Success != nil {
		enc.AddInt64("success", *v.Success)
	}
	return err
}

// GetSuccess returns the value of Success if it is set or its
// zero value if it is unset.
func (v *Echo_EchoI64_Result) GetSuccess() (o int64) {
	if v != nil && v.Success != nil {
		return *v.Success
	}

	return
}

// IsSetSuccess returns true if Success is not nil.
func (v *Echo_EchoI64_Result) IsSetSuccess() bool {
	return v != nil && v.Success != nil
}

// MethodName returns the name of the Thrift function as specified in
// the IDL, for which this struct represent the result.
//
// This will always be "echoI64" for this struct.
func (v *Echo_EchoI64_Result) MethodName() string {
	return "echoI64"
}

// EnvelopeType returns the kind of value inside this struct.
//
// This will always be Reply for this struct.
func (v *Echo_EchoI64_Result) EnvelopeType() wire.EnvelopeType {
	return wire.Reply
}

// Echo_EchoI8_Args represents the arguments for the Echo.echoI8 function.
//
// The arguments for echoI8 are sent and received over the wire as this struct.
type Echo_EchoI8_Args struct {
	Arg int8 `json:"arg,required"`
}

// ToWire translates a Echo_EchoI8_Args struct into a Thrift-level intermediate
// representation. This intermediate representation may be serialized
// into bytes using a ThriftRW protocol implementation.
//
// An error is returned if the struct or any of its fields failed to
// validate.
//
//   x, err := v.ToWire()
//   if err != nil {
//     return err
//   }
//
//   if err := binaryProtocol.Encode(x, writer); err != nil {
//     return err
//   }
func (v *Echo_EchoI8_Args) ToWire() (wire.Value, error) {
	var (
		fields [1]wire.Field
		i      int = 0
		w      wire.Value
		err    error
	)

	w, err = wire.NewValueI8(v.Arg), error(nil)
	if err != nil {
		return w, err
	}
	fields[i] = wire.Field{ID: 1, Value: w}
	i++

	return wire.NewValueStruct(wire.Struct{Fields: fields[:i]}), nil
}

// FromWire deserializes a Echo_EchoI8_Args struct from its Thrift-level
// representation. The Thrift-level representation may be obtained
// from a ThriftRW protocol implementation.
//
// An error is returned if we were unable to build a Echo_EchoI8_Args struct
// from the provided intermediate representation.
//
//   x, err := binaryProtocol.Decode(reader, wire.TStruct)
//   if err != nil {
//     return nil, err
//   }
//
//   var v Echo_EchoI8_Args
//   if err := v.FromWire(x); err != nil {
//     return nil, err
//   }
//   return &v, nil
func (v *Echo_EchoI8_Args) FromWire(w wire.Value) error {
	var err error

	argIsSet := false

	for _, field := range w.GetStruct().Fields {
		switch field.ID {
		case 1:
			if field.Value.Type() == wire.TI8 {
				v.Arg, err = field.Value.GetI8(), error(nil)
				if err != nil {
					return err
				}
				argIsSet = true
			}
		}
	}

	if !argIsSet {
		return errors.New("field Arg of Echo_EchoI8_Args is required")
	}

	return nil
}

// String returns a readable string representation of a Echo_EchoI8_Args
// struct.
func (v *Echo_EchoI8_Args) String() string {
	if v == nil {
		return "<nil>"
	}

	var fields [1]string
	i := 0
	fields[i] = fmt.Sprintf("Arg: %v", v.Arg)
	i++

	return fmt.Sprintf("Echo_EchoI8_Args{%v}", strings.Join(fields[:i], ", "))
}

// Equals returns true if all the fields of this Echo_EchoI8_Args match the
// provided Echo_EchoI8_Args.
//
// This function performs a deep comparison.
func (v *Echo_EchoI8_Args) Equals(rhs *Echo_EchoI8_Args) bool {
	if v == nil {
		return rhs == nil
	} else if rhs == nil {
		return false
	}
	if !(v.Arg == rhs.Arg) {
		return false
	}

	return true
}

// MarshalLogObject implements zapcore.ObjectMarshaler, enabling
// fast logging of Echo_EchoI8_Args.
func (v *Echo_EchoI8_Args) MarshalLogObject(enc zapcore.ObjectEncoder) (err error) {
	if v == nil {
		return nil
	}
	enc.AddInt8("arg", v.Arg)
	return err
}

// GetArg returns the value of Arg if it is set or its
// zero value if it is unset.
func (v *Echo_EchoI8_Args) GetArg() (o int8) {
	if v != nil {
		o = v.Arg
	}
	return
}

// MethodName returns the name of the Thrift function as specified in
// the IDL, for which this struct represent the arguments.
//
// This will always be "echoI8" for this struct.
func (v *Echo_EchoI8_Args) MethodName() string {
	return "echoI8"
}

// EnvelopeType returns the kind of value inside this struct.
//
// This will always be Call for this struct.
func (v *Echo_EchoI8_Args) EnvelopeType() wire.EnvelopeType {
	return wire.Call
}

// Echo_EchoI8_Helper provides functions that aid in handling the
// parameters and return values of the Echo.echoI8
// function.
var Echo_EchoI8_Helper = struct {
	// Args accepts the parameters of echoI8 in-order and returns
	// the arguments struct for the function.
	Args func(
		arg int8,
	) *Echo_EchoI8_Args

	// IsException returns true if the given error can be thrown
	// by echoI8.
	//
	// An error can be thrown by echoI8 only if the
	// corresponding exception type was mentioned in the 'throws'
	// section for it in the Thrift file.
	IsException func(error) bool

	// WrapResponse returns the result struct for echoI8
	// given its return value and error.
	//
	// This allows mapping values and errors returned by
	// echoI8 into a serializable result struct.
	// WrapResponse returns a non-nil error if the provided
	// error cannot be thrown by echoI8
	//
	//   value, err := echoI8(args)
	//   result, err := Echo_EchoI8_Helper.WrapResponse(value, err)
	//   if err != nil {
	//     return fmt.Errorf("unexpected error from echoI8: %v", err)
	//   }
	//   serialize(result)
	WrapResponse func(int8, error) (*Echo_EchoI8_Result, error)

	// UnwrapResponse takes the result struct for echoI8
	// and returns the value or error returned by it.
	//
	// The error is non-nil only if echoI8 threw an
	// exception.
	//
	//   result := deserialize(bytes)
	//   value, err := Echo_EchoI8_Helper.UnwrapResponse(result)
	UnwrapResponse func(*Echo_EchoI8_Result) (int8, error)
}{}

func init() {
	Echo_EchoI8_Helper.Args = func(
		arg int8,
	) *Echo_EchoI8_Args {
		return &Echo_EchoI8_Args{
			Arg: arg,
		}
	}

	Echo_EchoI8_Helper.IsException = func(err error) bool {
		switch err.(type) {
		default:
			return false
		}
	}

	Echo_EchoI8_Helper.WrapResponse = func(success int8, err error) (*Echo_EchoI8_Result, error) {
		if err == nil {
			return &Echo_EchoI8_Result{Success: &success}, nil
		}

		return nil, err
	}
	Echo_EchoI8_Helper.UnwrapResponse = func(result *Echo_EchoI8_Result) (success int8, err error) {

		if result.Success != nil {
			success = *result.Success
			return
		}

		err = errors.New("expected a non-void result")
		return
	}

}

// Echo_EchoI8_Result represents the result of a Echo.echoI8 function call.
//
// The result of a echoI8 execution is sent and received over the wire as this struct.
//
// Success is set only if the function did not throw an exception.
type Echo_EchoI8_Result struct {
	// Value returned by echoI8 after a successful execution.
	Success *int8 `json:"success,omitempty"`
}

// ToWire translates a Echo_EchoI8_Result struct into a Thrift-level intermediate
// representation. This intermediate representation may be serialized
// into bytes using a ThriftRW protocol implementation.
//
// An error is returned if the struct or any of its fields failed to
// validate.
//
//   x, err := v.ToWire()
//   if err != nil {
//     return err
//   }
//
//   if err := binaryProtocol.Encode(x, writer); err != nil {
//     return err
//   }
func (v *Echo_EchoI8_Result) ToWire() (wire.Value, error) {
	var (
		fields [1]wire.Field
		i      int = 0
		w      wire.Value
		err    error
	)

	if v.Success != nil {
		w, err = wire.NewValueI8(*(v.Success)), error(nil)
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 0, Value: w}
		i++
	}

	if i != 1 {
		return wire.Value{}, fmt.Errorf("Echo_EchoI8_Result should have exactly one field: got %v fields", i)
	}

	return wire.NewValueStruct(wire.Struct{Fields: fields[:i]}), nil
}

// FromWire deserializes a Echo_EchoI8_Result struct from its Thrift-level
// representation. The Thrift-level representation may be obtained
// from a ThriftRW protocol implementation.
//
// An error is returned if we were unable to build a Echo_EchoI8_Result struct
// from the provided intermediate representation.
//
//   x, err := binaryProtocol.Decode(reader, wire.TStruct)
//   if err != nil {
//     return nil, err
//   }
//
//   var v Echo_EchoI8_Result
//   if err := v.FromWire(x); err != nil {
//     return nil, err
//   }
//   return &v, nil
func (v *Echo_EchoI8_Result) FromWire(w wire.Value) error {
	var err error

	for _, field := range w.GetStruct().Fields {
		switch field.ID {
		case 0:
			if field.Value.Type() == wire.TI8 {
				var x int8
				x, err = field.Value.GetI8(), error(nil)
				v.Success = &x
				if err != nil {
					return err
				}

			}
		}
	}

	count := 0
	if v.Success != nil {
		count++
	}
	if count != 1 {
		return fmt.Errorf("Echo_EchoI8_Result should have exactly one field: got %v fields", count)
	}

	return nil
}

// String returns a readable string representation of a Echo_EchoI8_Result
// struct.
func (v *Echo_EchoI8_Result) String() string {
	if v == nil {
		return "<nil>"
	}

	var fields [1]string
	i := 0
	if v.Success != nil {
		fields[i] = fmt.Sprintf("Success: %v", *(v.Success))
		i++
	}

	return fmt.Sprintf("Echo_EchoI8_Result{%v}", strings.Join(fields[:i], ", "))
}

// Equals returns true if all the fields of this Echo_EchoI8_Result match the
// provided Echo_EchoI8_Result.
//
// This function performs a deep comparison.
func (v *Echo_EchoI8_Result) Equals(rhs *Echo_EchoI8_Result) bool {
	if v == nil {
		return rhs == nil
	} else if rhs == nil {
		return false
	}
	if !_Byte_EqualsPtr(v.Success, rhs.Success) {
		return false
	}

	return true
}

// MarshalLogObject implements zapcore.ObjectMarshaler, enabling
// fast logging of Echo_EchoI8_Result.
func (v *Echo_EchoI8_Result) MarshalLogObject(enc zapcore.ObjectEncoder) (err error) {
	if v == nil {
		return nil
	}
	if v.Success != nil {
		enc.AddInt8("success", *v.Success)
	}
	return err
}

// GetSuccess returns the value of Success if it is set or its
// zero value if it is unset.
func (v *Echo_EchoI8_Result) GetSuccess() (o int8) {
	if v != nil && v.Success != nil {
		return *v.Success
	}

	return
}

// IsSetSuccess returns true if Success is not nil.
func (v *Echo_EchoI8_Result) IsSetSuccess() bool {
	return v != nil && v.Success != nil
}

// MethodName returns the name of the Thrift function as specified in
// the IDL, for which this struct represent the result.
//
// This will always be "echoI8" for this struct.
func (v *Echo_EchoI8_Result) MethodName() string {
	return "echoI8"
}

// EnvelopeType returns the kind of value inside this struct.
//
// This will always be Reply for this struct.
func (v *Echo_EchoI8_Result) EnvelopeType() wire.EnvelopeType {
	return wire.Reply
}

// Echo_EchoString_Args represents the arguments for the Echo.echoString function.
//
// The arguments for echoString are sent and received over the wire as this struct.
type Echo_EchoString_Args struct {
	Arg string `json:"arg,required"`
}

// ToWire translates a Echo_EchoString_Args struct into a Thrift-level intermediate
// representation. This intermediate representation may be serialized
// into bytes using a ThriftRW protocol implementation.
//
// An error is returned if the struct or any of its fields failed to
// validate.
//
//   x, err := v.ToWire()
//   if err != nil {
//     return err
//   }
//
//   if err := binaryProtocol.Encode(x, writer); err != nil {
//     return err
//   }
func (v *Echo_EchoString_Args) ToWire() (wire.Value, error) {
	var (
		fields [1]wire.Field
		i      int = 0
		w      wire.Value
		err    error
	)

	w, err = wire.NewValueString(v.Arg), error(nil)
	if err != nil {
		return w, err
	}
	fields[i] = wire.Field{ID: 1, Value: w}
	i++

	return wire.NewValueStruct(wire.Struct{Fields: fields[:i]}), nil
}

// FromWire deserializes a Echo_EchoString_Args struct from its Thrift-level
// representation. The Thrift-level representation may be obtained
// from a ThriftRW protocol implementation.
//
// An error is returned if we were unable to build a Echo_EchoString_Args struct
// from the provided intermediate representation.
//
//   x, err := binaryProtocol.Decode(reader, wire.TStruct)
//   if err != nil {
//     return nil, err
//   }
//
//   var v Echo_EchoString_Args
//   if err := v.FromWire(x); err != nil {
//     return nil, err
//   }
//   return &v, nil
func (v *Echo_EchoString_Args) FromWire(w wire.Value) error {
	var err error

	argIsSet := false

	for _, field := range w.GetStruct().Fields {
		switch field.ID {
		case 1:
			if field.Value.Type() == wire.TBinary {
				v.Arg, err = field.Value.GetString(), error(nil)
				if err != nil {
					return err
				}
				argIsSet = true
			}
		}
	}

	if !argIsSet {
		return errors.New("field Arg of Echo_EchoString_Args is required")
	}

	return nil
}

// String returns a readable string representation of a Echo_EchoString_Args
// struct.
func (v *Echo_EchoString_Args) String() string {
	if v == nil {
		return "<nil>"
	}

	var fields [1]string
	i := 0
	fields[i] = fmt.Sprintf("Arg: %v", v.Arg)
	i++

	return fmt.Sprintf("Echo_EchoString_Args{%v}", strings.Join(fields[:i], ", "))
}

// Equals returns true if all the fields of this Echo_EchoString_Args match the
// provided Echo_EchoString_Args.
//
// This function performs a deep comparison.
func (v *Echo_EchoString_Args) Equals(rhs *Echo_EchoString_Args) bool {
	if v == nil {
		return rhs == nil
	} else if rhs == nil {
		return false
	}
	if !(v.Arg == rhs.Arg) {
		return false
	}

	return true
}

// MarshalLogObject implements zapcore.ObjectMarshaler, enabling
// fast logging of Echo_EchoString_Args.
func (v *Echo_EchoString_Args) MarshalLogObject(enc zapcore.ObjectEncoder) (err error) {
	if v == nil {
		return nil
	}
	enc.AddString("arg", v.Arg)
	return err
}

// GetArg returns the value of Arg if it is set or its
// zero value if it is unset.
func (v *Echo_EchoString_Args) GetArg() (o string) {
	if v != nil {
		o = v.Arg
	}
	return
}

// MethodName returns the name of the Thrift function as specified in
// the IDL, for which this struct represent the arguments.
//
// This will always be "echoString" for this struct.
func (v *Echo_EchoString_Args) MethodName() string {
	return "echoString"
}

// EnvelopeType returns the kind of value inside this struct.
//
// This will always be Call for this struct.
func (v *Echo_EchoString_Args) EnvelopeType() wire.EnvelopeType {
	return wire.Call
}

// Echo_EchoString_Helper provides functions that aid in handling the
// parameters and return values of the Echo.echoString
// function.
var Echo_EchoString_Helper = struct {
	// Args accepts the parameters of echoString in-order and returns
	// the arguments struct for the function.
	Args func(
		arg string,
	) *Echo_EchoString_Args

	// IsException returns true if the given error can be thrown
	// by echoString.
	//
	// An error can be thrown by echoString only if the
	// corresponding exception type was mentioned in the 'throws'
	// section for it in the Thrift file.
	IsException func(error) bool

	// WrapResponse returns the result struct for echoString
	// given its return value and error.
	//
	// This allows mapping values and errors returned by
	// echoString into a serializable result struct.
	// WrapResponse returns a non-nil error if the provided
	// error cannot be thrown by echoString
	//
	//   value, err := echoString(args)
	//   result, err := Echo_EchoString_Helper.WrapResponse(value, err)
	//   if err != nil {
	//     return fmt.Errorf("unexpected error from echoString: %v", err)
	//   }
	//   serialize(result)
	WrapResponse func(string, error) (*Echo_EchoString_Result, error)

	// UnwrapResponse takes the result struct for echoString
	// and returns the value or error returned by it.
	//
	// The error is non-nil only if echoString threw an
	// exception.
	//
	//   result := deserialize(bytes)
	//   value, err := Echo_EchoString_Helper.UnwrapResponse(result)
	UnwrapResponse func(*Echo_EchoString_Result) (string, error)
}{}

func init() {
	Echo_EchoString_Helper.Args = func(
		arg string,
	) *Echo_EchoString_Args {
		return &Echo_EchoString_Args{
			Arg: arg,
		}
	}

	Echo_EchoString_Helper.IsException = func(err error) bool {
		switch err.(type) {
		default:
			return false
		}
	}

	Echo_EchoString_Helper.WrapResponse = func(success string, err error) (*Echo_EchoString_Result, error) {
		if err == nil {
			return &Echo_EchoString_Result{Success: &success}, nil
		}

		return nil, err
	}
	Echo_EchoString_Helper.UnwrapResponse = func(result *Echo_EchoString_Result) (success string, err error) {

		if result.Success != nil {
			success = *result.Success
			return
		}

		err = errors.New("expected a non-void result")
		return
	}

}

// Echo_EchoString_Result represents the result of a Echo.echoString function call.
//
// The result of a echoString execution is sent and received over the wire as this struct.
//
// Success is set only if the function did not throw an exception.
type Echo_EchoString_Result struct {
	// Value returned by echoString after a successful execution.
	Success *string `json:"success,omitempty"`
}

// ToWire translates a Echo_EchoString_Result struct into a Thrift-level intermediate
// representation. This intermediate representation may be serialized
// into bytes using a ThriftRW protocol implementation.
//
// An error is returned if the struct or any of its fields failed to
// validate.
//
//   x, err := v.ToWire()
//   if err != nil {
//     return err
//   }
//
//   if err := binaryProtocol.Encode(x, writer); err != nil {
//     return err
//   }
func (v *Echo_EchoString_Result) ToWire() (wire.Value, error) {
	var (
		fields [1]wire.Field
		i      int = 0
		w      wire.Value
		err    error
	)

	if v.Success != nil {
		w, err = wire.NewValueString(*(v.Success)), error(nil)
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 0, Value: w}
		i++
	}

	if i != 1 {
		return wire.Value{}, fmt.Errorf("Echo_EchoString_Result should have exactly one field: got %v fields", i)
	}

	return wire.NewValueStruct(wire.Struct{Fields: fields[:i]}), nil
}

// FromWire deserializes a Echo_EchoString_Result struct from its Thrift-level
// representation. The Thrift-level representation may be obtained
// from a ThriftRW protocol implementation.
//
// An error is returned if we were unable to build a Echo_EchoString_Result struct
// from the provided intermediate representation.
//
//   x, err := binaryProtocol.Decode(reader, wire.TStruct)
//   if err != nil {
//     return nil, err
//   }
//
//   var v Echo_EchoString_Result
//   if err := v.FromWire(x); err != nil {
//     return nil, err
//   }
//   return &v, nil
func (v *Echo_EchoString_Result) FromWire(w wire.Value) error {
	var err error

	for _, field := range w.GetStruct().Fields {
		switch field.ID {
		case 0:
			if field.Value.Type() == wire.TBinary {
				var x string
				x, err = field.Value.GetString(), error(nil)
				v.Success = &x
				if err != nil {
					return err
				}

			}
		}
	}

	count := 0
	if v.Success != nil {
		count++
	}
	if count != 1 {
		return fmt.Errorf("Echo_EchoString_Result should have exactly one field: got %v fields", count)
	}

	return nil
}

// String returns a readable string representation of a Echo_EchoString_Result
// struct.
func (v *Echo_EchoString_Result) String() string {
	if v == nil {
		return "<nil>"
	}

	var fields [1]string
	i := 0
	if v.Success != nil {
		fields[i] = fmt.Sprintf("Success: %v", *(v.Success))
		i++
	}

	return fmt.Sprintf("Echo_EchoString_Result{%v}", strings.Join(fields[:i], ", "))
}

// Equals returns true if all the fields of this Echo_EchoString_Result match the
// provided Echo_EchoString_Result.
//
// This function performs a deep comparison.
func (v *Echo_EchoString_Result) Equals(rhs *Echo_EchoString_Result) bool {
	if v == nil {
		return rhs == nil
	} else if rhs == nil {
		return false
	}
	if !_String_EqualsPtr(v.Success, rhs.Success) {
		return false
	}

	return true
}

// MarshalLogObject implements zapcore.ObjectMarshaler, enabling
// fast logging of Echo_EchoString_Result.
func (v *Echo_EchoString_Result) MarshalLogObject(enc zapcore.ObjectEncoder) (err error) {
	if v == nil {
		return nil
	}
	if v.Success != nil {
		enc.AddString("success", *v.Success)
	}
	return err
}

// GetSuccess returns the value of Success if it is set or its
// zero value if it is unset.
func (v *Echo_EchoString_Result) GetSuccess() (o string) {
	if v != nil && v.Success != nil {
		return *v.Success
	}

	return
}

// IsSetSuccess returns true if Success is not nil.
func (v *Echo_EchoString_Result) IsSetSuccess() bool {
	return v != nil && v.Success != nil
}

// MethodName returns the name of the Thrift function as specified in
// the IDL, for which this struct represent the result.
//
// This will always be "echoString" for this struct.
func (v *Echo_EchoString_Result) MethodName() string {
	return "echoString"
}

// EnvelopeType returns the kind of value inside this struct.
//
// This will always be Reply for this struct.
func (v *Echo_EchoString_Result) EnvelopeType() wire.EnvelopeType {
	return wire.Reply
}

// Echo_EchoStringList_Args represents the arguments for the Echo.echoStringList function.
//
// The arguments for echoStringList are sent and received over the wire as this struct.
type Echo_EchoStringList_Args struct {
	Arg []string `json:"arg,required"`
}

// ToWire translates a Echo_EchoStringList_Args struct into a Thrift-level intermediate
// representation. This intermediate representation may be serialized
// into bytes using a ThriftRW protocol implementation.
//
// An error is returned if the struct or any of its fields failed to
// validate.
//
//   x, err := v.ToWire()
//   if err != nil {
//     return err
//   }
//
//   if err := binaryProtocol.Encode(x, writer); err != nil {
//     return err
//   }
func (v *Echo_EchoStringList_Args) ToWire() (wire.Value, error) {
	var (
		fields [1]wire.Field
		i      int = 0
		w      wire.Value
		err    error
	)

	w, err = wire.NewValueList(_List_String_ValueList(v.Arg)), error(nil)
	if err != nil {
		return w, err
	}
	fields[i] = wire.Field{ID: 1, Value: w}
	i++

	return wire.NewValueStruct(wire.Struct{Fields: fields[:i]}), nil
}

// FromWire deserializes a Echo_EchoStringList_Args struct from its Thrift-level
// representation. The Thrift-level representation may be obtained
// from a ThriftRW protocol implementation.
//
// An error is returned if we were unable to build a Echo_EchoStringList_Args struct
// from the provided intermediate representation.
//
//   x, err := binaryProtocol.Decode(reader, wire.TStruct)
//   if err != nil {
//     return nil, err
//   }
//
//   var v Echo_EchoStringList_Args
//   if err := v.FromWire(x); err != nil {
//     return nil, err
//   }
//   return &v, nil
func (v *Echo_EchoStringList_Args) FromWire(w wire.Value) error {
	var err error

	argIsSet := false

	for _, field := range w.GetStruct().Fields {
		switch field.ID {
		case 1:
			if field.Value.Type() == wire.TList {
				v.Arg, err = _List_String_Read(field.Value.GetList())
				if err != nil {
					return err
				}
				argIsSet = true
			}
		}
	}

	if !argIsSet {
		return errors.New("field Arg of Echo_EchoStringList_Args is required")
	}

	return nil
}

// String returns a readable string representation of a Echo_EchoStringList_Args
// struct.
func (v *Echo_EchoStringList_Args) String() string {
	if v == nil {
		return "<nil>"
	}

	var fields [1]string
	i := 0
	fields[i] = fmt.Sprintf("Arg: %v", v.Arg)
	i++

	return fmt.Sprintf("Echo_EchoStringList_Args{%v}", strings.Join(fields[:i], ", "))
}

// Equals returns true if all the fields of this Echo_EchoStringList_Args match the
// provided Echo_EchoStringList_Args.
//
// This function performs a deep comparison.
func (v *Echo_EchoStringList_Args) Equals(rhs *Echo_EchoStringList_Args) bool {
	if v == nil {
		return rhs == nil
	} else if rhs == nil {
		return false
	}
	if !_List_String_Equals(v.Arg, rhs.Arg) {
		return false
	}

	return true
}

// MarshalLogObject implements zapcore.ObjectMarshaler, enabling
// fast logging of Echo_EchoStringList_Args.
func (v *Echo_EchoStringList_Args) MarshalLogObject(enc zapcore.ObjectEncoder) (err error) {
	if v == nil {
		return nil
	}
	err = multierr.Append(err, enc.AddArray("arg", (_List_String_Zapper)(v.Arg)))
	return err
}

// GetArg returns the value of Arg if it is set or its
// zero value if it is unset.
func (v *Echo_EchoStringList_Args) GetArg() (o []string) {
	if v != nil {
		o = v.Arg
	}
	return
}

// IsSetArg returns true if Arg is not nil.
func (v *Echo_EchoStringList_Args) IsSetArg() bool {
	return v != nil && v.Arg != nil
}

// MethodName returns the name of the Thrift function as specified in
// the IDL, for which this struct represent the arguments.
//
// This will always be "echoStringList" for this struct.
func (v *Echo_EchoStringList_Args) MethodName() string {
	return "echoStringList"
}

// EnvelopeType returns the kind of value inside this struct.
//
// This will always be Call for this struct.
func (v *Echo_EchoStringList_Args) EnvelopeType() wire.EnvelopeType {
	return wire.Call
}

// Echo_EchoStringList_Helper provides functions that aid in handling the
// parameters and return values of the Echo.echoStringList
// function.
var Echo_EchoStringList_Helper = struct {
	// Args accepts the parameters of echoStringList in-order and returns
	// the arguments struct for the function.
	Args func(
		arg []string,
	) *Echo_EchoStringList_Args

	// IsException returns true if the given error can be thrown
	// by echoStringList.
	//
	// An error can be thrown by echoStringList only if the
	// corresponding exception type was mentioned in the 'throws'
	// section for it in the Thrift file.
	IsException func(error) bool

	// WrapResponse returns the result struct for echoStringList
	// given its return value and error.
	//
	// This allows mapping values and errors returned by
	// echoStringList into a serializable result struct.
	// WrapResponse returns a non-nil error if the provided
	// error cannot be thrown by echoStringList
	//
	//   value, err := echoStringList(args)
	//   result, err := Echo_EchoStringList_Helper.WrapResponse(value, err)
	//   if err != nil {
	//     return fmt.Errorf("unexpected error from echoStringList: %v", err)
	//   }
	//   serialize(result)
	WrapResponse func([]string, error) (*Echo_EchoStringList_Result, error)

	// UnwrapResponse takes the result struct for echoStringList
	// and returns the value or error returned by it.
	//
	// The error is non-nil only if echoStringList threw an
	// exception.
	//
	//   result := deserialize(bytes)
	//   value, err := Echo_EchoStringList_Helper.UnwrapResponse(result)
	UnwrapResponse func(*Echo_EchoStringList_Result) ([]string, error)
}{}

func init() {
	Echo_EchoStringList_Helper.Args = func(
		arg []string,
	) *Echo_EchoStringList_Args {
		return &Echo_EchoStringList_Args{
			Arg: arg,
		}
	}

	Echo_EchoStringList_Helper.IsException = func(err error) bool {
		switch err.(type) {
		default:
			return false
		}
	}

	Echo_EchoStringList_Helper.WrapResponse = func(success []string, err error) (*Echo_EchoStringList_Result, error) {
		if err == nil {
			return &Echo_EchoStringList_Result{Success: success}, nil
		}

		return nil, err
	}
	Echo_EchoStringList_Helper.UnwrapResponse = func(result *Echo_EchoStringList_Result) (success []string, err error) {

		if result.Success != nil {
			success = result.Success
			return
		}

		err = errors.New("expected a non-void result")
		return
	}

}

// Echo_EchoStringList_Result represents the result of a Echo.echoStringList function call.
//
// The result of a echoStringList execution is sent and received over the wire as this struct.
//
// Success is set only if the function did not throw an exception.
type Echo_EchoStringList_Result struct {
	// Value returned by echoStringList after a successful execution.
	Success []string `json:"success,omitempty"`
}

// ToWire translates a Echo_EchoStringList_Result struct into a Thrift-level intermediate
// representation. This intermediate representation may be serialized
// into bytes using a ThriftRW protocol implementation.
//
// An error is returned if the struct or any of its fields failed to
// validate.
//
//   x, err := v.ToWire()
//   if err != nil {
//     return err
//   }
//
//   if err := binaryProtocol.Encode(x, writer); err != nil {
//     return err
//   }
func (v *Echo_EchoStringList_Result) ToWire() (wire.Value, error) {
	var (
		fields [1]wire.Field
		i      int = 0
		w      wire.Value
		err    error
	)

	if v.Success != nil {
		w, err = wire.NewValueList(_List_String_ValueList(v.Success)), error(nil)
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 0, Value: w}
		i++
	}

	if i != 1 {
		return wire.Value{}, fmt.Errorf("Echo_EchoStringList_Result should have exactly one field: got %v fields", i)
	}

	return wire.NewValueStruct(wire.Struct{Fields: fields[:i]}), nil
}

// FromWire deserializes a Echo_EchoStringList_Result struct from its Thrift-level
// representation. The Thrift-level representation may be obtained
// from a ThriftRW protocol implementation.
//
// An error is returned if we were unable to build a Echo_EchoStringList_Result struct
// from the provided intermediate representation.
//
//   x, err := binaryProtocol.Decode(reader, wire.TStruct)
//   if err != nil {
//     return nil, err
//   }
//
//   var v Echo_EchoStringList_Result
//   if err := v.FromWire(x); err != nil {
//     return nil, err
//   }
//   return &v, nil
func (v *Echo_EchoStringList_Result) FromWire(w wire.Value) error {
	var err error

	for _, field := range w.GetStruct().Fields {
		switch field.ID {
		case 0:
			if field.Value.Type() == wire.TList {
				v.Success, err = _List_String_Read(field.Value.GetList())
				if err != nil {
					return err
				}

			}
		}
	}

	count := 0
	if v.Success != nil {
		count++
	}
	if count != 1 {
		return fmt.Errorf("Echo_EchoStringList_Result should have exactly one field: got %v fields", count)
	}

	return nil
}

// String returns a readable string representation of a Echo_EchoStringList_Result
// struct.
func (v *Echo_EchoStringList_Result) String() string {
	if v == nil {
		return "<nil>"
	}

	var fields [1]string
	i := 0
	if v.Success != nil {
		fields[i] = fmt.Sprintf("Success: %v", v.Success)
		i++
	}

	return fmt.Sprintf("Echo_EchoStringList_Result{%v}", strings.Join(fields[:i], ", "))
}

// Equals returns true if all the fields of this Echo_EchoStringList_Result match the
// provided Echo_EchoStringList_Result.
//
// This function performs a deep comparison.
func (v *Echo_EchoStringList_Result) Equals(rhs *Echo_EchoStringList_Result) bool {
	if v == nil {
		return rhs == nil
	} else if rhs == nil {
		return false
	}
	if !((v.Success == nil && rhs.Success == nil) || (v.Success != nil && rhs.Success != nil && _List_String_Equals(v.Success, rhs.Success))) {
		return false
	}

	return true
}

// MarshalLogObject implements zapcore.ObjectMarshaler, enabling
// fast logging of Echo_EchoStringList_Result.
func (v *Echo_EchoStringList_Result) MarshalLogObject(enc zapcore.ObjectEncoder) (err error) {
	if v == nil {
		return nil
	}
	if v.Success != nil {
		err = multierr.Append(err, enc.AddArray("success", (_List_String_Zapper)(v.Success)))
	}
	return err
}

// GetSuccess returns the value of Success if it is set or its
// zero value if it is unset.
func (v *Echo_EchoStringList_Result) GetSuccess() (o []string) {
	if v != nil && v.Success != nil {
		return v.Success
	}

	return
}

// IsSetSuccess returns true if Success is not nil.
func (v *Echo_EchoStringList_Result) IsSetSuccess() bool {
	return v != nil && v.Success != nil
}

// MethodName returns the name of the Thrift function as specified in
// the IDL, for which this struct represent the result.
//
// This will always be "echoStringList" for this struct.
func (v *Echo_EchoStringList_Result) MethodName() string {
	return "echoStringList"
}

// EnvelopeType returns the kind of value inside this struct.
//
// This will always be Reply for this struct.
func (v *Echo_EchoStringList_Result) EnvelopeType() wire.EnvelopeType {
	return wire.Reply
}

// Echo_EchoStringMap_Args represents the arguments for the Echo.echoStringMap function.
//
// The arguments for echoStringMap are sent and received over the wire as this struct.
type Echo_EchoStringMap_Args struct {
	Arg map[string]*BarResponse `json:"arg,required"`
}

type _Map_String_BarResponse_MapItemList map[string]*BarResponse

func (m _Map_String_BarResponse_MapItemList) ForEach(f func(wire.MapItem) error) error {
	for k, v := range m {
		if v == nil {
			return fmt.Errorf("invalid [%v]: value is nil", k)
		}
		kw, err := wire.NewValueString(k), error(nil)
		if err != nil {
			return err
		}

		vw, err := v.ToWire()
		if err != nil {
			return err
		}
		err = f(wire.MapItem{Key: kw, Value: vw})
		if err != nil {
			return err
		}
	}
	return nil
}

func (m _Map_String_BarResponse_MapItemList) Size() int {
	return len(m)
}

func (_Map_String_BarResponse_MapItemList) KeyType() wire.Type {
	return wire.TBinary
}

func (_Map_String_BarResponse_MapItemList) ValueType() wire.Type {
	return wire.TStruct
}

func (_Map_String_BarResponse_MapItemList) Close() {}

// ToWire translates a Echo_EchoStringMap_Args struct into a Thrift-level intermediate
// representation. This intermediate representation may be serialized
// into bytes using a ThriftRW protocol implementation.
//
// An error is returned if the struct or any of its fields failed to
// validate.
//
//   x, err := v.ToWire()
//   if err != nil {
//     return err
//   }
//
//   if err := binaryProtocol.Encode(x, writer); err != nil {
//     return err
//   }
func (v *Echo_EchoStringMap_Args) ToWire() (wire.Value, error) {
	var (
		fields [1]wire.Field
		i      int = 0
		w      wire.Value
		err    error
	)

	if v.Arg == nil {
		return w, errors.New("field Arg of Echo_EchoStringMap_Args is required")
	}
	w, err = wire.NewValueMap(_Map_String_BarResponse_MapItemList(v.Arg)), error(nil)
	if err != nil {
		return w, err
	}
	fields[i] = wire.Field{ID: 1, Value: w}
	i++

	return wire.NewValueStruct(wire.Struct{Fields: fields[:i]}), nil
}

func _Map_String_BarResponse_Read(m wire.MapItemList) (map[string]*BarResponse, error) {
	if m.KeyType() != wire.TBinary {
		return nil, nil
	}

	if m.ValueType() != wire.TStruct {
		return nil, nil
	}

	o := make(map[string]*BarResponse, m.Size())
	err := m.ForEach(func(x wire.MapItem) error {
		k, err := x.Key.GetString(), error(nil)
		if err != nil {
			return err
		}

		v, err := _BarResponse_Read(x.Value)
		if err != nil {
			return err
		}

		o[k] = v
		return nil
	})
	m.Close()
	return o, err
}

// FromWire deserializes a Echo_EchoStringMap_Args struct from its Thrift-level
// representation. The Thrift-level representation may be obtained
// from a ThriftRW protocol implementation.
//
// An error is returned if we were unable to build a Echo_EchoStringMap_Args struct
// from the provided intermediate representation.
//
//   x, err := binaryProtocol.Decode(reader, wire.TStruct)
//   if err != nil {
//     return nil, err
//   }
//
//   var v Echo_EchoStringMap_Args
//   if err := v.FromWire(x); err != nil {
//     return nil, err
//   }
//   return &v, nil
func (v *Echo_EchoStringMap_Args) FromWire(w wire.Value) error {
	var err error

	argIsSet := false

	for _, field := range w.GetStruct().Fields {
		switch field.ID {
		case 1:
			if field.Value.Type() == wire.TMap {
				v.Arg, err = _Map_String_BarResponse_Read(field.Value.GetMap())
				if err != nil {
					return err
				}
				argIsSet = true
			}
		}
	}

	if !argIsSet {
		return errors.New("field Arg of Echo_EchoStringMap_Args is required")
	}

	return nil
}

// String returns a readable string representation of a Echo_EchoStringMap_Args
// struct.
func (v *Echo_EchoStringMap_Args) String() string {
	if v == nil {
		return "<nil>"
	}

	var fields [1]string
	i := 0
	fields[i] = fmt.Sprintf("Arg: %v", v.Arg)
	i++

	return fmt.Sprintf("Echo_EchoStringMap_Args{%v}", strings.Join(fields[:i], ", "))
}

func _Map_String_BarResponse_Equals(lhs, rhs map[string]*BarResponse) bool {
	if len(lhs) != len(rhs) {
		return false
	}

	for lk, lv := range lhs {
		rv, ok := rhs[lk]
		if !ok {
			return false
		}
		if !lv.Equals(rv) {
			return false
		}
	}
	return true
}

// Equals returns true if all the fields of this Echo_EchoStringMap_Args match the
// provided Echo_EchoStringMap_Args.
//
// This function performs a deep comparison.
func (v *Echo_EchoStringMap_Args) Equals(rhs *Echo_EchoStringMap_Args) bool {
	if v == nil {
		return rhs == nil
	} else if rhs == nil {
		return false
	}
	if !_Map_String_BarResponse_Equals(v.Arg, rhs.Arg) {
		return false
	}

	return true
}

type _Map_String_BarResponse_Zapper map[string]*BarResponse

// MarshalLogObject implements zapcore.ObjectMarshaler, enabling
// fast logging of _Map_String_BarResponse_Zapper.
func (m _Map_String_BarResponse_Zapper) MarshalLogObject(enc zapcore.ObjectEncoder) (err error) {
	for k, v := range m {
		err = multierr.Append(err, enc.AddObject((string)(k), v))
	}
	return err
}

// MarshalLogObject implements zapcore.ObjectMarshaler, enabling
// fast logging of Echo_EchoStringMap_Args.
func (v *Echo_EchoStringMap_Args) MarshalLogObject(enc zapcore.ObjectEncoder) (err error) {
	if v == nil {
		return nil
	}
	err = multierr.Append(err, enc.AddObject("arg", (_Map_String_BarResponse_Zapper)(v.Arg)))
	return err
}

// GetArg returns the value of Arg if it is set or its
// zero value if it is unset.
func (v *Echo_EchoStringMap_Args) GetArg() (o map[string]*BarResponse) {
	if v != nil {
		o = v.Arg
	}
	return
}

// IsSetArg returns true if Arg is not nil.
func (v *Echo_EchoStringMap_Args) IsSetArg() bool {
	return v != nil && v.Arg != nil
}

// MethodName returns the name of the Thrift function as specified in
// the IDL, for which this struct represent the arguments.
//
// This will always be "echoStringMap" for this struct.
func (v *Echo_EchoStringMap_Args) MethodName() string {
	return "echoStringMap"
}

// EnvelopeType returns the kind of value inside this struct.
//
// This will always be Call for this struct.
func (v *Echo_EchoStringMap_Args) EnvelopeType() wire.EnvelopeType {
	return wire.Call
}

// Echo_EchoStringMap_Helper provides functions that aid in handling the
// parameters and return values of the Echo.echoStringMap
// function.
var Echo_EchoStringMap_Helper = struct {
	// Args accepts the parameters of echoStringMap in-order and returns
	// the arguments struct for the function.
	Args func(
		arg map[string]*BarResponse,
	) *Echo_EchoStringMap_Args

	// IsException returns true if the given error can be thrown
	// by echoStringMap.
	//
	// An error can be thrown by echoStringMap only if the
	// corresponding exception type was mentioned in the 'throws'
	// section for it in the Thrift file.
	IsException func(error) bool

	// WrapResponse returns the result struct for echoStringMap
	// given its return value and error.
	//
	// This allows mapping values and errors returned by
	// echoStringMap into a serializable result struct.
	// WrapResponse returns a non-nil error if the provided
	// error cannot be thrown by echoStringMap
	//
	//   value, err := echoStringMap(args)
	//   result, err := Echo_EchoStringMap_Helper.WrapResponse(value, err)
	//   if err != nil {
	//     return fmt.Errorf("unexpected error from echoStringMap: %v", err)
	//   }
	//   serialize(result)
	WrapResponse func(map[string]*BarResponse, error) (*Echo_EchoStringMap_Result, error)

	// UnwrapResponse takes the result struct for echoStringMap
	// and returns the value or error returned by it.
	//
	// The error is non-nil only if echoStringMap threw an
	// exception.
	//
	//   result := deserialize(bytes)
	//   value, err := Echo_EchoStringMap_Helper.UnwrapResponse(result)
	UnwrapResponse func(*Echo_EchoStringMap_Result) (map[string]*BarResponse, error)
}{}

func init() {
	Echo_EchoStringMap_Helper.Args = func(
		arg map[string]*BarResponse,
	) *Echo_EchoStringMap_Args {
		return &Echo_EchoStringMap_Args{
			Arg: arg,
		}
	}

	Echo_EchoStringMap_Helper.IsException = func(err error) bool {
		switch err.(type) {
		default:
			return false
		}
	}

	Echo_EchoStringMap_Helper.WrapResponse = func(success map[string]*BarResponse, err error) (*Echo_EchoStringMap_Result, error) {
		if err == nil {
			return &Echo_EchoStringMap_Result{Success: success}, nil
		}

		return nil, err
	}
	Echo_EchoStringMap_Helper.UnwrapResponse = func(result *Echo_EchoStringMap_Result) (success map[string]*BarResponse, err error) {

		if result.Success != nil {
			success = result.Success
			return
		}

		err = errors.New("expected a non-void result")
		return
	}

}

// Echo_EchoStringMap_Result represents the result of a Echo.echoStringMap function call.
//
// The result of a echoStringMap execution is sent and received over the wire as this struct.
//
// Success is set only if the function did not throw an exception.
type Echo_EchoStringMap_Result struct {
	// Value returned by echoStringMap after a successful execution.
	Success map[string]*BarResponse `json:"success,omitempty"`
}

// ToWire translates a Echo_EchoStringMap_Result struct into a Thrift-level intermediate
// representation. This intermediate representation may be serialized
// into bytes using a ThriftRW protocol implementation.
//
// An error is returned if the struct or any of its fields failed to
// validate.
//
//   x, err := v.ToWire()
//   if err != nil {
//     return err
//   }
//
//   if err := binaryProtocol.Encode(x, writer); err != nil {
//     return err
//   }
func (v *Echo_EchoStringMap_Result) ToWire() (wire.Value, error) {
	var (
		fields [1]wire.Field
		i      int = 0
		w      wire.Value
		err    error
	)

	if v.Success != nil {
		w, err = wire.NewValueMap(_Map_String_BarResponse_MapItemList(v.Success)), error(nil)
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 0, Value: w}
		i++
	}

	if i != 1 {
		return wire.Value{}, fmt.Errorf("Echo_EchoStringMap_Result should have exactly one field: got %v fields", i)
	}

	return wire.NewValueStruct(wire.Struct{Fields: fields[:i]}), nil
}

// FromWire deserializes a Echo_EchoStringMap_Result struct from its Thrift-level
// representation. The Thrift-level representation may be obtained
// from a ThriftRW protocol implementation.
//
// An error is returned if we were unable to build a Echo_EchoStringMap_Result struct
// from the provided intermediate representation.
//
//   x, err := binaryProtocol.Decode(reader, wire.TStruct)
//   if err != nil {
//     return nil, err
//   }
//
//   var v Echo_EchoStringMap_Result
//   if err := v.FromWire(x); err != nil {
//     return nil, err
//   }
//   return &v, nil
func (v *Echo_EchoStringMap_Result) FromWire(w wire.Value) error {
	var err error

	for _, field := range w.GetStruct().Fields {
		switch field.ID {
		case 0:
			if field.Value.Type() == wire.TMap {
				v.Success, err = _Map_String_BarResponse_Read(field.Value.GetMap())
				if err != nil {
					return err
				}

			}
		}
	}

	count := 0
	if v.Success != nil {
		count++
	}
	if count != 1 {
		return fmt.Errorf("Echo_EchoStringMap_Result should have exactly one field: got %v fields", count)
	}

	return nil
}

// String returns a readable string representation of a Echo_EchoStringMap_Result
// struct.
func (v *Echo_EchoStringMap_Result) String() string {
	if v == nil {
		return "<nil>"
	}

	var fields [1]string
	i := 0
	if v.Success != nil {
		fields[i] = fmt.Sprintf("Success: %v", v.Success)
		i++
	}

	return fmt.Sprintf("Echo_EchoStringMap_Result{%v}", strings.Join(fields[:i], ", "))
}

// Equals returns true if all the fields of this Echo_EchoStringMap_Result match the
// provided Echo_EchoStringMap_Result.
//
// This function performs a deep comparison.
func (v *Echo_EchoStringMap_Result) Equals(rhs *Echo_EchoStringMap_Result) bool {
	if v == nil {
		return rhs == nil
	} else if rhs == nil {
		return false
	}
	if !((v.Success == nil && rhs.Success == nil) || (v.Success != nil && rhs.Success != nil && _Map_String_BarResponse_Equals(v.Success, rhs.Success))) {
		return false
	}

	return true
}

// MarshalLogObject implements zapcore.ObjectMarshaler, enabling
// fast logging of Echo_EchoStringMap_Result.
func (v *Echo_EchoStringMap_Result) MarshalLogObject(enc zapcore.ObjectEncoder) (err error) {
	if v == nil {
		return nil
	}
	if v.Success != nil {
		err = multierr.Append(err, enc.AddObject("success", (_Map_String_BarResponse_Zapper)(v.Success)))
	}
	return err
}

// GetSuccess returns the value of Success if it is set or its
// zero value if it is unset.
func (v *Echo_EchoStringMap_Result) GetSuccess() (o map[string]*BarResponse) {
	if v != nil && v.Success != nil {
		return v.Success
	}

	return
}

// IsSetSuccess returns true if Success is not nil.
func (v *Echo_EchoStringMap_Result) IsSetSuccess() bool {
	return v != nil && v.Success != nil
}

// MethodName returns the name of the Thrift function as specified in
// the IDL, for which this struct represent the result.
//
// This will always be "echoStringMap" for this struct.
func (v *Echo_EchoStringMap_Result) MethodName() string {
	return "echoStringMap"
}

// EnvelopeType returns the kind of value inside this struct.
//
// This will always be Reply for this struct.
func (v *Echo_EchoStringMap_Result) EnvelopeType() wire.EnvelopeType {
	return wire.Reply
}

// Echo_EchoStringSet_Args represents the arguments for the Echo.echoStringSet function.
//
// The arguments for echoStringSet are sent and received over the wire as this struct.
type Echo_EchoStringSet_Args struct {
	Arg map[string]struct{} `json:"arg,required"`
}

type _Set_String_mapType_ValueList map[string]struct{}

func (v _Set_String_mapType_ValueList) ForEach(f func(wire.Value) error) error {
	for x := range v {
		w, err := wire.NewValueString(x), error(nil)
		if err != nil {
			return err
		}

		if err := f(w); err != nil {
			return err
		}
	}
	return nil
}

func (v _Set_String_mapType_ValueList) Size() int {
	return len(v)
}

func (_Set_String_mapType_ValueList) ValueType() wire.Type {
	return wire.TBinary
}

func (_Set_String_mapType_ValueList) Close() {}

// ToWire translates a Echo_EchoStringSet_Args struct into a Thrift-level intermediate
// representation. This intermediate representation may be serialized
// into bytes using a ThriftRW protocol implementation.
//
// An error is returned if the struct or any of its fields failed to
// validate.
//
//   x, err := v.ToWire()
//   if err != nil {
//     return err
//   }
//
//   if err := binaryProtocol.Encode(x, writer); err != nil {
//     return err
//   }
func (v *Echo_EchoStringSet_Args) ToWire() (wire.Value, error) {
	var (
		fields [1]wire.Field
		i      int = 0
		w      wire.Value
		err    error
	)

	if v.Arg == nil {
		return w, errors.New("field Arg of Echo_EchoStringSet_Args is required")
	}
	w, err = wire.NewValueSet(_Set_String_mapType_ValueList(v.Arg)), error(nil)
	if err != nil {
		return w, err
	}
	fields[i] = wire.Field{ID: 1, Value: w}
	i++

	return wire.NewValueStruct(wire.Struct{Fields: fields[:i]}), nil
}

func _Set_String_mapType_Read(s wire.ValueList) (map[string]struct{}, error) {
	if s.ValueType() != wire.TBinary {
		return nil, nil
	}

	o := make(map[string]struct{}, s.Size())
	err := s.ForEach(func(x wire.Value) error {
		i, err := x.GetString(), error(nil)
		if err != nil {
			return err
		}

		o[i] = struct{}{}
		return nil
	})
	s.Close()
	return o, err
}

// FromWire deserializes a Echo_EchoStringSet_Args struct from its Thrift-level
// representation. The Thrift-level representation may be obtained
// from a ThriftRW protocol implementation.
//
// An error is returned if we were unable to build a Echo_EchoStringSet_Args struct
// from the provided intermediate representation.
//
//   x, err := binaryProtocol.Decode(reader, wire.TStruct)
//   if err != nil {
//     return nil, err
//   }
//
//   var v Echo_EchoStringSet_Args
//   if err := v.FromWire(x); err != nil {
//     return nil, err
//   }
//   return &v, nil
func (v *Echo_EchoStringSet_Args) FromWire(w wire.Value) error {
	var err error

	argIsSet := false

	for _, field := range w.GetStruct().Fields {
		switch field.ID {
		case 1:
			if field.Value.Type() == wire.TSet {
				v.Arg, err = _Set_String_mapType_Read(field.Value.GetSet())
				if err != nil {
					return err
				}
				argIsSet = true
			}
		}
	}

	if !argIsSet {
		return errors.New("field Arg of Echo_EchoStringSet_Args is required")
	}

	return nil
}

// String returns a readable string representation of a Echo_EchoStringSet_Args
// struct.
func (v *Echo_EchoStringSet_Args) String() string {
	if v == nil {
		return "<nil>"
	}

	var fields [1]string
	i := 0
	fields[i] = fmt.Sprintf("Arg: %v", v.Arg)
	i++

	return fmt.Sprintf("Echo_EchoStringSet_Args{%v}", strings.Join(fields[:i], ", "))
}

func _Set_String_mapType_Equals(lhs, rhs map[string]struct{}) bool {
	if len(lhs) != len(rhs) {
		return false
	}

	for x := range rhs {
		if _, ok := lhs[x]; !ok {
			return false
		}
	}

	return true
}

// Equals returns true if all the fields of this Echo_EchoStringSet_Args match the
// provided Echo_EchoStringSet_Args.
//
// This function performs a deep comparison.
func (v *Echo_EchoStringSet_Args) Equals(rhs *Echo_EchoStringSet_Args) bool {
	if v == nil {
		return rhs == nil
	} else if rhs == nil {
		return false
	}
	if !_Set_String_mapType_Equals(v.Arg, rhs.Arg) {
		return false
	}

	return true
}

type _Set_String_mapType_Zapper map[string]struct{}

// MarshalLogArray implements zapcore.ArrayMarshaler, enabling
// fast logging of _Set_String_mapType_Zapper.
func (s _Set_String_mapType_Zapper) MarshalLogArray(enc zapcore.ArrayEncoder) (err error) {
	for v := range s {
		enc.AppendString(v)
	}
	return err
}

// MarshalLogObject implements zapcore.ObjectMarshaler, enabling
// fast logging of Echo_EchoStringSet_Args.
func (v *Echo_EchoStringSet_Args) MarshalLogObject(enc zapcore.ObjectEncoder) (err error) {
	if v == nil {
		return nil
	}
	err = multierr.Append(err, enc.AddArray("arg", (_Set_String_mapType_Zapper)(v.Arg)))
	return err
}

// GetArg returns the value of Arg if it is set or its
// zero value if it is unset.
func (v *Echo_EchoStringSet_Args) GetArg() (o map[string]struct{}) {
	if v != nil {
		o = v.Arg
	}
	return
}

// IsSetArg returns true if Arg is not nil.
func (v *Echo_EchoStringSet_Args) IsSetArg() bool {
	return v != nil && v.Arg != nil
}

// MethodName returns the name of the Thrift function as specified in
// the IDL, for which this struct represent the arguments.
//
// This will always be "echoStringSet" for this struct.
func (v *Echo_EchoStringSet_Args) MethodName() string {
	return "echoStringSet"
}

// EnvelopeType returns the kind of value inside this struct.
//
// This will always be Call for this struct.
func (v *Echo_EchoStringSet_Args) EnvelopeType() wire.EnvelopeType {
	return wire.Call
}

// Echo_EchoStringSet_Helper provides functions that aid in handling the
// parameters and return values of the Echo.echoStringSet
// function.
var Echo_EchoStringSet_Helper = struct {
	// Args accepts the parameters of echoStringSet in-order and returns
	// the arguments struct for the function.
	Args func(
		arg map[string]struct{},
	) *Echo_EchoStringSet_Args

	// IsException returns true if the given error can be thrown
	// by echoStringSet.
	//
	// An error can be thrown by echoStringSet only if the
	// corresponding exception type was mentioned in the 'throws'
	// section for it in the Thrift file.
	IsException func(error) bool

	// WrapResponse returns the result struct for echoStringSet
	// given its return value and error.
	//
	// This allows mapping values and errors returned by
	// echoStringSet into a serializable result struct.
	// WrapResponse returns a non-nil error if the provided
	// error cannot be thrown by echoStringSet
	//
	//   value, err := echoStringSet(args)
	//   result, err := Echo_EchoStringSet_Helper.WrapResponse(value, err)
	//   if err != nil {
	//     return fmt.Errorf("unexpected error from echoStringSet: %v", err)
	//   }
	//   serialize(result)
	WrapResponse func(map[string]struct{}, error) (*Echo_EchoStringSet_Result, error)

	// UnwrapResponse takes the result struct for echoStringSet
	// and returns the value or error returned by it.
	//
	// The error is non-nil only if echoStringSet threw an
	// exception.
	//
	//   result := deserialize(bytes)
	//   value, err := Echo_EchoStringSet_Helper.UnwrapResponse(result)
	UnwrapResponse func(*Echo_EchoStringSet_Result) (map[string]struct{}, error)
}{}

func init() {
	Echo_EchoStringSet_Helper.Args = func(
		arg map[string]struct{},
	) *Echo_EchoStringSet_Args {
		return &Echo_EchoStringSet_Args{
			Arg: arg,
		}
	}

	Echo_EchoStringSet_Helper.IsException = func(err error) bool {
		switch err.(type) {
		default:
			return false
		}
	}

	Echo_EchoStringSet_Helper.WrapResponse = func(success map[string]struct{}, err error) (*Echo_EchoStringSet_Result, error) {
		if err == nil {
			return &Echo_EchoStringSet_Result{Success: success}, nil
		}

		return nil, err
	}
	Echo_EchoStringSet_Helper.UnwrapResponse = func(result *Echo_EchoStringSet_Result) (success map[string]struct{}, err error) {

		if result.Success != nil {
			success = result.Success
			return
		}

		err = errors.New("expected a non-void result")
		return
	}

}

// Echo_EchoStringSet_Result represents the result of a Echo.echoStringSet function call.
//
// The result of a echoStringSet execution is sent and received over the wire as this struct.
//
// Success is set only if the function did not throw an exception.
type Echo_EchoStringSet_Result struct {
	// Value returned by echoStringSet after a successful execution.
	Success map[string]struct{} `json:"success,omitempty"`
}

// ToWire translates a Echo_EchoStringSet_Result struct into a Thrift-level intermediate
// representation. This intermediate representation may be serialized
// into bytes using a ThriftRW protocol implementation.
//
// An error is returned if the struct or any of its fields failed to
// validate.
//
//   x, err := v.ToWire()
//   if err != nil {
//     return err
//   }
//
//   if err := binaryProtocol.Encode(x, writer); err != nil {
//     return err
//   }
func (v *Echo_EchoStringSet_Result) ToWire() (wire.Value, error) {
	var (
		fields [1]wire.Field
		i      int = 0
		w      wire.Value
		err    error
	)

	if v.Success != nil {
		w, err = wire.NewValueSet(_Set_String_mapType_ValueList(v.Success)), error(nil)
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 0, Value: w}
		i++
	}

	if i != 1 {
		return wire.Value{}, fmt.Errorf("Echo_EchoStringSet_Result should have exactly one field: got %v fields", i)
	}

	return wire.NewValueStruct(wire.Struct{Fields: fields[:i]}), nil
}

// FromWire deserializes a Echo_EchoStringSet_Result struct from its Thrift-level
// representation. The Thrift-level representation may be obtained
// from a ThriftRW protocol implementation.
//
// An error is returned if we were unable to build a Echo_EchoStringSet_Result struct
// from the provided intermediate representation.
//
//   x, err := binaryProtocol.Decode(reader, wire.TStruct)
//   if err != nil {
//     return nil, err
//   }
//
//   var v Echo_EchoStringSet_Result
//   if err := v.FromWire(x); err != nil {
//     return nil, err
//   }
//   return &v, nil
func (v *Echo_EchoStringSet_Result) FromWire(w wire.Value) error {
	var err error

	for _, field := range w.GetStruct().Fields {
		switch field.ID {
		case 0:
			if field.Value.Type() == wire.TSet {
				v.Success, err = _Set_String_mapType_Read(field.Value.GetSet())
				if err != nil {
					return err
				}

			}
		}
	}

	count := 0
	if v.Success != nil {
		count++
	}
	if count != 1 {
		return fmt.Errorf("Echo_EchoStringSet_Result should have exactly one field: got %v fields", count)
	}

	return nil
}

// String returns a readable string representation of a Echo_EchoStringSet_Result
// struct.
func (v *Echo_EchoStringSet_Result) String() string {
	if v == nil {
		return "<nil>"
	}

	var fields [1]string
	i := 0
	if v.Success != nil {
		fields[i] = fmt.Sprintf("Success: %v", v.Success)
		i++
	}

	return fmt.Sprintf("Echo_EchoStringSet_Result{%v}", strings.Join(fields[:i], ", "))
}

// Equals returns true if all the fields of this Echo_EchoStringSet_Result match the
// provided Echo_EchoStringSet_Result.
//
// This function performs a deep comparison.
func (v *Echo_EchoStringSet_Result) Equals(rhs *Echo_EchoStringSet_Result) bool {
	if v == nil {
		return rhs == nil
	} else if rhs == nil {
		return false
	}
	if !((v.Success == nil && rhs.Success == nil) || (v.Success != nil && rhs.Success != nil && _Set_String_mapType_Equals(v.Success, rhs.Success))) {
		return false
	}

	return true
}

// MarshalLogObject implements zapcore.ObjectMarshaler, enabling
// fast logging of Echo_EchoStringSet_Result.
func (v *Echo_EchoStringSet_Result) MarshalLogObject(enc zapcore.ObjectEncoder) (err error) {
	if v == nil {
		return nil
	}
	if v.Success != nil {
		err = multierr.Append(err, enc.AddArray("success", (_Set_String_mapType_Zapper)(v.Success)))
	}
	return err
}

// GetSuccess returns the value of Success if it is set or its
// zero value if it is unset.
func (v *Echo_EchoStringSet_Result) GetSuccess() (o map[string]struct{}) {
	if v != nil && v.Success != nil {
		return v.Success
	}

	return
}

// IsSetSuccess returns true if Success is not nil.
func (v *Echo_EchoStringSet_Result) IsSetSuccess() bool {
	return v != nil && v.Success != nil
}

// MethodName returns the name of the Thrift function as specified in
// the IDL, for which this struct represent the result.
//
// This will always be "echoStringSet" for this struct.
func (v *Echo_EchoStringSet_Result) MethodName() string {
	return "echoStringSet"
}

// EnvelopeType returns the kind of value inside this struct.
//
// This will always be Reply for this struct.
func (v *Echo_EchoStringSet_Result) EnvelopeType() wire.EnvelopeType {
	return wire.Reply
}

// Echo_EchoStructList_Args represents the arguments for the Echo.echoStructList function.
//
// The arguments for echoStructList are sent and received over the wire as this struct.
type Echo_EchoStructList_Args struct {
	Arg []*BarResponse `json:"arg,required"`
}

type _List_BarResponse_ValueList []*BarResponse

func (v _List_BarResponse_ValueList) ForEach(f func(wire.Value) error) error {
	for i, x := range v {
		if x == nil {
			return fmt.Errorf("invalid [%v]: value is nil", i)
		}
		w, err := x.ToWire()
		if err != nil {
			return err
		}
		err = f(w)
		if err != nil {
			return err
		}
	}
	return nil
}

func (v _List_BarResponse_ValueList) Size() int {
	return len(v)
}

func (_List_BarResponse_ValueList) ValueType() wire.Type {
	return wire.TStruct
}

func (_List_BarResponse_ValueList) Close() {}

// ToWire translates a Echo_EchoStructList_Args struct into a Thrift-level intermediate
// representation. This intermediate representation may be serialized
// into bytes using a ThriftRW protocol implementation.
//
// An error is returned if the struct or any of its fields failed to
// validate.
//
//   x, err := v.ToWire()
//   if err != nil {
//     return err
//   }
//
//   if err := binaryProtocol.Encode(x, writer); err != nil {
//     return err
//   }
func (v *Echo_EchoStructList_Args) ToWire() (wire.Value, error) {
	var (
		fields [1]wire.Field
		i      int = 0
		w      wire.Value
		err    error
	)

	w, err = wire.NewValueList(_List_BarResponse_ValueList(v.Arg)), error(nil)
	if err != nil {
		return w, err
	}
	fields[i] = wire.Field{ID: 1, Value: w}
	i++

	return wire.NewValueStruct(wire.Struct{Fields: fields[:i]}), nil
}

func _List_BarResponse_Read(l wire.ValueList) ([]*BarResponse, error) {
	if l.ValueType() != wire.TStruct {
		return nil, nil
	}

	o := make([]*BarResponse, 0, l.Size())
	err := l.ForEach(func(x wire.Value) error {
		i, err := _BarResponse_Read(x)
		if err != nil {
			return err
		}
		o = append(o, i)
		return nil
	})
	l.Close()
	return o, err
}

// FromWire deserializes a Echo_EchoStructList_Args struct from its Thrift-level
// representation. The Thrift-level representation may be obtained
// from a ThriftRW protocol implementation.
//
// An error is returned if we were unable to build a Echo_EchoStructList_Args struct
// from the provided intermediate representation.
//
//   x, err := binaryProtocol.Decode(reader, wire.TStruct)
//   if err != nil {
//     return nil, err
//   }
//
//   var v Echo_EchoStructList_Args
//   if err := v.FromWire(x); err != nil {
//     return nil, err
//   }
//   return &v, nil
func (v *Echo_EchoStructList_Args) FromWire(w wire.Value) error {
	var err error

	argIsSet := false

	for _, field := range w.GetStruct().Fields {
		switch field.ID {
		case 1:
			if field.Value.Type() == wire.TList {
				v.Arg, err = _List_BarResponse_Read(field.Value.GetList())
				if err != nil {
					return err
				}
				argIsSet = true
			}
		}
	}

	if !argIsSet {
		return errors.New("field Arg of Echo_EchoStructList_Args is required")
	}

	return nil
}

// String returns a readable string representation of a Echo_EchoStructList_Args
// struct.
func (v *Echo_EchoStructList_Args) String() string {
	if v == nil {
		return "<nil>"
	}

	var fields [1]string
	i := 0
	fields[i] = fmt.Sprintf("Arg: %v", v.Arg)
	i++

	return fmt.Sprintf("Echo_EchoStructList_Args{%v}", strings.Join(fields[:i], ", "))
}

func _List_BarResponse_Equals(lhs, rhs []*BarResponse) bool {
	if len(lhs) != len(rhs) {
		return false
	}

	for i, lv := range lhs {
		rv := rhs[i]
		if !lv.Equals(rv) {
			return false
		}
	}

	return true
}

// Equals returns true if all the fields of this Echo_EchoStructList_Args match the
// provided Echo_EchoStructList_Args.
//
// This function performs a deep comparison.
func (v *Echo_EchoStructList_Args) Equals(rhs *Echo_EchoStructList_Args) bool {
	if v == nil {
		return rhs == nil
	} else if rhs == nil {
		return false
	}
	if !_List_BarResponse_Equals(v.Arg, rhs.Arg) {
		return false
	}

	return true
}

type _List_BarResponse_Zapper []*BarResponse

// MarshalLogArray implements zapcore.ArrayMarshaler, enabling
// fast logging of _List_BarResponse_Zapper.
func (l _List_BarResponse_Zapper) MarshalLogArray(enc zapcore.ArrayEncoder) (err error) {
	for _, v := range l {
		err = multierr.Append(err, enc.AppendObject(v))
	}
	return err
}

// MarshalLogObject implements zapcore.ObjectMarshaler, enabling
// fast logging of Echo_EchoStructList_Args.
func (v *Echo_EchoStructList_Args) MarshalLogObject(enc zapcore.ObjectEncoder) (err error) {
	if v == nil {
		return nil
	}
	err = multierr.Append(err, enc.AddArray("arg", (_List_BarResponse_Zapper)(v.Arg)))
	return err
}

// GetArg returns the value of Arg if it is set or its
// zero value if it is unset.
func (v *Echo_EchoStructList_Args) GetArg() (o []*BarResponse) {
	if v != nil {
		o = v.Arg
	}
	return
}

// IsSetArg returns true if Arg is not nil.
func (v *Echo_EchoStructList_Args) IsSetArg() bool {
	return v != nil && v.Arg != nil
}

// MethodName returns the name of the Thrift function as specified in
// the IDL, for which this struct represent the arguments.
//
// This will always be "echoStructList" for this struct.
func (v *Echo_EchoStructList_Args) MethodName() string {
	return "echoStructList"
}

// EnvelopeType returns the kind of value inside this struct.
//
// This will always be Call for this struct.
func (v *Echo_EchoStructList_Args) EnvelopeType() wire.EnvelopeType {
	return wire.Call
}

// Echo_EchoStructList_Helper provides functions that aid in handling the
// parameters and return values of the Echo.echoStructList
// function.
var Echo_EchoStructList_Helper = struct {
	// Args accepts the parameters of echoStructList in-order and returns
	// the arguments struct for the function.
	Args func(
		arg []*BarResponse,
	) *Echo_EchoStructList_Args

	// IsException returns true if the given error can be thrown
	// by echoStructList.
	//
	// An error can be thrown by echoStructList only if the
	// corresponding exception type was mentioned in the 'throws'
	// section for it in the Thrift file.
	IsException func(error) bool

	// WrapResponse returns the result struct for echoStructList
	// given its return value and error.
	//
	// This allows mapping values and errors returned by
	// echoStructList into a serializable result struct.
	// WrapResponse returns a non-nil error if the provided
	// error cannot be thrown by echoStructList
	//
	//   value, err := echoStructList(args)
	//   result, err := Echo_EchoStructList_Helper.WrapResponse(value, err)
	//   if err != nil {
	//     return fmt.Errorf("unexpected error from echoStructList: %v", err)
	//   }
	//   serialize(result)
	WrapResponse func([]*BarResponse, error) (*Echo_EchoStructList_Result, error)

	// UnwrapResponse takes the result struct for echoStructList
	// and returns the value or error returned by it.
	//
	// The error is non-nil only if echoStructList threw an
	// exception.
	//
	//   result := deserialize(bytes)
	//   value, err := Echo_EchoStructList_Helper.UnwrapResponse(result)
	UnwrapResponse func(*Echo_EchoStructList_Result) ([]*BarResponse, error)
}{}

func init() {
	Echo_EchoStructList_Helper.Args = func(
		arg []*BarResponse,
	) *Echo_EchoStructList_Args {
		return &Echo_EchoStructList_Args{
			Arg: arg,
		}
	}

	Echo_EchoStructList_Helper.IsException = func(err error) bool {
		switch err.(type) {
		default:
			return false
		}
	}

	Echo_EchoStructList_Helper.WrapResponse = func(success []*BarResponse, err error) (*Echo_EchoStructList_Result, error) {
		if err == nil {
			return &Echo_EchoStructList_Result{Success: success}, nil
		}

		return nil, err
	}
	Echo_EchoStructList_Helper.UnwrapResponse = func(result *Echo_EchoStructList_Result) (success []*BarResponse, err error) {

		if result.Success != nil {
			success = result.Success
			return
		}

		err = errors.New("expected a non-void result")
		return
	}

}

// Echo_EchoStructList_Result represents the result of a Echo.echoStructList function call.
//
// The result of a echoStructList execution is sent and received over the wire as this struct.
//
// Success is set only if the function did not throw an exception.
type Echo_EchoStructList_Result struct {
	// Value returned by echoStructList after a successful execution.
	Success []*BarResponse `json:"success,omitempty"`
}

// ToWire translates a Echo_EchoStructList_Result struct into a Thrift-level intermediate
// representation. This intermediate representation may be serialized
// into bytes using a ThriftRW protocol implementation.
//
// An error is returned if the struct or any of its fields failed to
// validate.
//
//   x, err := v.ToWire()
//   if err != nil {
//     return err
//   }
//
//   if err := binaryProtocol.Encode(x, writer); err != nil {
//     return err
//   }
func (v *Echo_EchoStructList_Result) ToWire() (wire.Value, error) {
	var (
		fields [1]wire.Field
		i      int = 0
		w      wire.Value
		err    error
	)

	if v.Success != nil {
		w, err = wire.NewValueList(_List_BarResponse_ValueList(v.Success)), error(nil)
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 0, Value: w}
		i++
	}

	if i != 1 {
		return wire.Value{}, fmt.Errorf("Echo_EchoStructList_Result should have exactly one field: got %v fields", i)
	}

	return wire.NewValueStruct(wire.Struct{Fields: fields[:i]}), nil
}

// FromWire deserializes a Echo_EchoStructList_Result struct from its Thrift-level
// representation. The Thrift-level representation may be obtained
// from a ThriftRW protocol implementation.
//
// An error is returned if we were unable to build a Echo_EchoStructList_Result struct
// from the provided intermediate representation.
//
//   x, err := binaryProtocol.Decode(reader, wire.TStruct)
//   if err != nil {
//     return nil, err
//   }
//
//   var v Echo_EchoStructList_Result
//   if err := v.FromWire(x); err != nil {
//     return nil, err
//   }
//   return &v, nil
func (v *Echo_EchoStructList_Result) FromWire(w wire.Value) error {
	var err error

	for _, field := range w.GetStruct().Fields {
		switch field.ID {
		case 0:
			if field.Value.Type() == wire.TList {
				v.Success, err = _List_BarResponse_Read(field.Value.GetList())
				if err != nil {
					return err
				}

			}
		}
	}

	count := 0
	if v.Success != nil {
		count++
	}
	if count != 1 {
		return fmt.Errorf("Echo_EchoStructList_Result should have exactly one field: got %v fields", count)
	}

	return nil
}

// String returns a readable string representation of a Echo_EchoStructList_Result
// struct.
func (v *Echo_EchoStructList_Result) String() string {
	if v == nil {
		return "<nil>"
	}

	var fields [1]string
	i := 0
	if v.Success != nil {
		fields[i] = fmt.Sprintf("Success: %v", v.Success)
		i++
	}

	return fmt.Sprintf("Echo_EchoStructList_Result{%v}", strings.Join(fields[:i], ", "))
}

// Equals returns true if all the fields of this Echo_EchoStructList_Result match the
// provided Echo_EchoStructList_Result.
//
// This function performs a deep comparison.
func (v *Echo_EchoStructList_Result) Equals(rhs *Echo_EchoStructList_Result) bool {
	if v == nil {
		return rhs == nil
	} else if rhs == nil {
		return false
	}
	if !((v.Success == nil && rhs.Success == nil) || (v.Success != nil && rhs.Success != nil && _List_BarResponse_Equals(v.Success, rhs.Success))) {
		return false
	}

	return true
}

// MarshalLogObject implements zapcore.ObjectMarshaler, enabling
// fast logging of Echo_EchoStructList_Result.
func (v *Echo_EchoStructList_Result) MarshalLogObject(enc zapcore.ObjectEncoder) (err error) {
	if v == nil {
		return nil
	}
	if v.Success != nil {
		err = multierr.Append(err, enc.AddArray("success", (_List_BarResponse_Zapper)(v.Success)))
	}
	return err
}

// GetSuccess returns the value of Success if it is set or its
// zero value if it is unset.
func (v *Echo_EchoStructList_Result) GetSuccess() (o []*BarResponse) {
	if v != nil && v.Success != nil {
		return v.Success
	}

	return
}

// IsSetSuccess returns true if Success is not nil.
func (v *Echo_EchoStructList_Result) IsSetSuccess() bool {
	return v != nil && v.Success != nil
}

// MethodName returns the name of the Thrift function as specified in
// the IDL, for which this struct represent the result.
//
// This will always be "echoStructList" for this struct.
func (v *Echo_EchoStructList_Result) MethodName() string {
	return "echoStructList"
}

// EnvelopeType returns the kind of value inside this struct.
//
// This will always be Reply for this struct.
func (v *Echo_EchoStructList_Result) EnvelopeType() wire.EnvelopeType {
	return wire.Reply
}

// Echo_EchoStructMap_Args represents the arguments for the Echo.echoStructMap function.
//
// The arguments for echoStructMap are sent and received over the wire as this struct.
type Echo_EchoStructMap_Args struct {
	Arg []struct {
		Key   *BarResponse
		Value string
	} `json:"arg,required"`
}

type _Map_BarResponse_String_MapItemList []struct {
	Key   *BarResponse
	Value string
}

func (m _Map_BarResponse_String_MapItemList) ForEach(f func(wire.MapItem) error) error {
	for _, i := range m {
		k := i.Key
		v := i.Value
		if k == nil {
			return fmt.Errorf("invalid map key: value is nil")
		}
		kw, err := k.ToWire()
		if err != nil {
			return err
		}

		vw, err := wire.NewValueString(v), error(nil)
		if err != nil {
			return err
		}
		err = f(wire.MapItem{Key: kw, Value: vw})
		if err != nil {
			return err
		}
	}
	return nil
}

func (m _Map_BarResponse_String_MapItemList) Size() int {
	return len(m)
}

func (_Map_BarResponse_String_MapItemList) KeyType() wire.Type {
	return wire.TStruct
}

func (_Map_BarResponse_String_MapItemList) ValueType() wire.Type {
	return wire.TBinary
}

func (_Map_BarResponse_String_MapItemList) Close() {}

// ToWire translates a Echo_EchoStructMap_Args struct into a Thrift-level intermediate
// representation. This intermediate representation may be serialized
// into bytes using a ThriftRW protocol implementation.
//
// An error is returned if the struct or any of its fields failed to
// validate.
//
//   x, err := v.ToWire()
//   if err != nil {
//     return err
//   }
//
//   if err := binaryProtocol.Encode(x, writer); err != nil {
//     return err
//   }
func (v *Echo_EchoStructMap_Args) ToWire() (wire.Value, error) {
	var (
		fields [1]wire.Field
		i      int = 0
		w      wire.Value
		err    error
	)

	if v.Arg == nil {
		return w, errors.New("field Arg of Echo_EchoStructMap_Args is required")
	}
	w, err = wire.NewValueMap(_Map_BarResponse_String_MapItemList(v.Arg)), error(nil)
	if err != nil {
		return w, err
	}
	fields[i] = wire.Field{ID: 1, Value: w}
	i++

	return wire.NewValueStruct(wire.Struct{Fields: fields[:i]}), nil
}

func _Map_BarResponse_String_Read(m wire.MapItemList) ([]struct {
	Key   *BarResponse
	Value string
}, error) {
	if m.KeyType() != wire.TStruct {
		return nil, nil
	}

	if m.ValueType() != wire.TBinary {
		return nil, nil
	}

	o := make([]struct {
		Key   *BarResponse
		Value string
	}, 0, m.Size())
	err := m.ForEach(func(x wire.MapItem) error {
		k, err := _BarResponse_Read(x.Key)
		if err != nil {
			return err
		}

		v, err := x.Value.GetString(), error(nil)
		if err != nil {
			return err
		}

		o = append(o, struct {
			Key   *BarResponse
			Value string
		}{k, v})
		return nil
	})
	m.Close()
	return o, err
}

// FromWire deserializes a Echo_EchoStructMap_Args struct from its Thrift-level
// representation. The Thrift-level representation may be obtained
// from a ThriftRW protocol implementation.
//
// An error is returned if we were unable to build a Echo_EchoStructMap_Args struct
// from the provided intermediate representation.
//
//   x, err := binaryProtocol.Decode(reader, wire.TStruct)
//   if err != nil {
//     return nil, err
//   }
//
//   var v Echo_EchoStructMap_Args
//   if err := v.FromWire(x); err != nil {
//     return nil, err
//   }
//   return &v, nil
func (v *Echo_EchoStructMap_Args) FromWire(w wire.Value) error {
	var err error

	argIsSet := false

	for _, field := range w.GetStruct().Fields {
		switch field.ID {
		case 1:
			if field.Value.Type() == wire.TMap {
				v.Arg, err = _Map_BarResponse_String_Read(field.Value.GetMap())
				if err != nil {
					return err
				}
				argIsSet = true
			}
		}
	}

	if !argIsSet {
		return errors.New("field Arg of Echo_EchoStructMap_Args is required")
	}

	return nil
}

// String returns a readable string representation of a Echo_EchoStructMap_Args
// struct.
func (v *Echo_EchoStructMap_Args) String() string {
	if v == nil {
		return "<nil>"
	}

	var fields [1]string
	i := 0
	fields[i] = fmt.Sprintf("Arg: %v", v.Arg)
	i++

	return fmt.Sprintf("Echo_EchoStructMap_Args{%v}", strings.Join(fields[:i], ", "))
}

func _Map_BarResponse_String_Equals(lhs, rhs []struct {
	Key   *BarResponse
	Value string
}) bool {
	if len(lhs) != len(rhs) {
		return false
	}

	for _, i := range lhs {
		lk := i.Key
		lv := i.Value
		ok := false
		for _, j := range rhs {
			rk := j.Key
			rv := j.Value
			if !lk.Equals(rk) {
				continue
			}

			if !(lv == rv) {
				return false
			}
			ok = true
			break
		}

		if !ok {
			return false
		}
	}
	return true
}

// Equals returns true if all the fields of this Echo_EchoStructMap_Args match the
// provided Echo_EchoStructMap_Args.
//
// This function performs a deep comparison.
func (v *Echo_EchoStructMap_Args) Equals(rhs *Echo_EchoStructMap_Args) bool {
	if v == nil {
		return rhs == nil
	} else if rhs == nil {
		return false
	}
	if !_Map_BarResponse_String_Equals(v.Arg, rhs.Arg) {
		return false
	}

	return true
}

type _Map_BarResponse_String_Item_Zapper struct {
	Key   *BarResponse
	Value string
}

// MarshalLogArray implements zapcore.ArrayMarshaler, enabling
// fast logging of _Map_BarResponse_String_Item_Zapper.
func (v _Map_BarResponse_String_Item_Zapper) MarshalLogObject(enc zapcore.ObjectEncoder) (err error) {
	err = multierr.Append(err, enc.AddObject("key", v.Key))
	enc.AddString("value", v.Value)
	return err
}

type _Map_BarResponse_String_Zapper []struct {
	Key   *BarResponse
	Value string
}

// MarshalLogArray implements zapcore.ArrayMarshaler, enabling
// fast logging of _Map_BarResponse_String_Zapper.
func (m _Map_BarResponse_String_Zapper) MarshalLogArray(enc zapcore.ArrayEncoder) (err error) {
	for _, i := range m {
		k := i.Key
		v := i.Value
		err = multierr.Append(err, enc.AppendObject(_Map_BarResponse_String_Item_Zapper{Key: k, Value: v}))
	}
	return err
}

// MarshalLogObject implements zapcore.ObjectMarshaler, enabling
// fast logging of Echo_EchoStructMap_Args.
func (v *Echo_EchoStructMap_Args) MarshalLogObject(enc zapcore.ObjectEncoder) (err error) {
	if v == nil {
		return nil
	}
	err = multierr.Append(err, enc.AddArray("arg", (_Map_BarResponse_String_Zapper)(v.Arg)))
	return err
}

// GetArg returns the value of Arg if it is set or its
// zero value if it is unset.
func (v *Echo_EchoStructMap_Args) GetArg() (o []struct {
	Key   *BarResponse
	Value string
}) {
	if v != nil {
		o = v.Arg
	}
	return
}

// IsSetArg returns true if Arg is not nil.
func (v *Echo_EchoStructMap_Args) IsSetArg() bool {
	return v != nil && v.Arg != nil
}

// MethodName returns the name of the Thrift function as specified in
// the IDL, for which this struct represent the arguments.
//
// This will always be "echoStructMap" for this struct.
func (v *Echo_EchoStructMap_Args) MethodName() string {
	return "echoStructMap"
}

// EnvelopeType returns the kind of value inside this struct.
//
// This will always be Call for this struct.
func (v *Echo_EchoStructMap_Args) EnvelopeType() wire.EnvelopeType {
	return wire.Call
}

// Echo_EchoStructMap_Helper provides functions that aid in handling the
// parameters and return values of the Echo.echoStructMap
// function.
var Echo_EchoStructMap_Helper = struct {
	// Args accepts the parameters of echoStructMap in-order and returns
	// the arguments struct for the function.
	Args func(
		arg []struct {
			Key   *BarResponse
			Value string
		},
	) *Echo_EchoStructMap_Args

	// IsException returns true if the given error can be thrown
	// by echoStructMap.
	//
	// An error can be thrown by echoStructMap only if the
	// corresponding exception type was mentioned in the 'throws'
	// section for it in the Thrift file.
	IsException func(error) bool

	// WrapResponse returns the result struct for echoStructMap
	// given its return value and error.
	//
	// This allows mapping values and errors returned by
	// echoStructMap into a serializable result struct.
	// WrapResponse returns a non-nil error if the provided
	// error cannot be thrown by echoStructMap
	//
	//   value, err := echoStructMap(args)
	//   result, err := Echo_EchoStructMap_Helper.WrapResponse(value, err)
	//   if err != nil {
	//     return fmt.Errorf("unexpected error from echoStructMap: %v", err)
	//   }
	//   serialize(result)
	WrapResponse func([]struct {
		Key   *BarResponse
		Value string
	}, error) (*Echo_EchoStructMap_Result, error)

	// UnwrapResponse takes the result struct for echoStructMap
	// and returns the value or error returned by it.
	//
	// The error is non-nil only if echoStructMap threw an
	// exception.
	//
	//   result := deserialize(bytes)
	//   value, err := Echo_EchoStructMap_Helper.UnwrapResponse(result)
	UnwrapResponse func(*Echo_EchoStructMap_Result) ([]struct {
		Key   *BarResponse
		Value string
	}, error)
}{}

func init() {
	Echo_EchoStructMap_Helper.Args = func(
		arg []struct {
			Key   *BarResponse
			Value string
		},
	) *Echo_EchoStructMap_Args {
		return &Echo_EchoStructMap_Args{
			Arg: arg,
		}
	}

	Echo_EchoStructMap_Helper.IsException = func(err error) bool {
		switch err.(type) {
		default:
			return false
		}
	}

	Echo_EchoStructMap_Helper.WrapResponse = func(success []struct {
		Key   *BarResponse
		Value string
	}, err error) (*Echo_EchoStructMap_Result, error) {
		if err == nil {
			return &Echo_EchoStructMap_Result{Success: success}, nil
		}

		return nil, err
	}
	Echo_EchoStructMap_Helper.UnwrapResponse = func(result *Echo_EchoStructMap_Result) (success []struct {
		Key   *BarResponse
		Value string
	}, err error) {
		if result.Success != nil {
			success = result.Success
			return
		}
		err = errors.New("expected a non-void result")
		return
	}

}

// Echo_EchoStructMap_Result represents the result of a Echo.echoStructMap function call.
//
// The result of a echoStructMap execution is sent and received over the wire as this struct.
//
// Success is set only if the function did not throw an exception.
type Echo_EchoStructMap_Result struct {
	// Value returned by echoStructMap after a successful execution.
	Success []struct {
		Key   *BarResponse
		Value string
	} `json:"success,omitempty"`
}

// ToWire translates a Echo_EchoStructMap_Result struct into a Thrift-level intermediate
// representation. This intermediate representation may be serialized
// into bytes using a ThriftRW protocol implementation.
//
// An error is returned if the struct or any of its fields failed to
// validate.
//
//   x, err := v.ToWire()
//   if err != nil {
//     return err
//   }
//
//   if err := binaryProtocol.Encode(x, writer); err != nil {
//     return err
//   }
func (v *Echo_EchoStructMap_Result) ToWire() (wire.Value, error) {
	var (
		fields [1]wire.Field
		i      int = 0
		w      wire.Value
		err    error
	)

	if v.Success != nil {
		w, err = wire.NewValueMap(_Map_BarResponse_String_MapItemList(v.Success)), error(nil)
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 0, Value: w}
		i++
	}

	if i != 1 {
		return wire.Value{}, fmt.Errorf("Echo_EchoStructMap_Result should have exactly one field: got %v fields", i)
	}

	return wire.NewValueStruct(wire.Struct{Fields: fields[:i]}), nil
}

// FromWire deserializes a Echo_EchoStructMap_Result struct from its Thrift-level
// representation. The Thrift-level representation may be obtained
// from a ThriftRW protocol implementation.
//
// An error is returned if we were unable to build a Echo_EchoStructMap_Result struct
// from the provided intermediate representation.
//
//   x, err := binaryProtocol.Decode(reader, wire.TStruct)
//   if err != nil {
//     return nil, err
//   }
//
//   var v Echo_EchoStructMap_Result
//   if err := v.FromWire(x); err != nil {
//     return nil, err
//   }
//   return &v, nil
func (v *Echo_EchoStructMap_Result) FromWire(w wire.Value) error {
	var err error

	for _, field := range w.GetStruct().Fields {
		switch field.ID {
		case 0:
			if field.Value.Type() == wire.TMap {
				v.Success, err = _Map_BarResponse_String_Read(field.Value.GetMap())
				if err != nil {
					return err
				}

			}
		}
	}

	count := 0
	if v.Success != nil {
		count++
	}
	if count != 1 {
		return fmt.Errorf("Echo_EchoStructMap_Result should have exactly one field: got %v fields", count)
	}

	return nil
}

// String returns a readable string representation of a Echo_EchoStructMap_Result
// struct.
func (v *Echo_EchoStructMap_Result) String() string {
	if v == nil {
		return "<nil>"
	}

	var fields [1]string
	i := 0
	if v.Success != nil {
		fields[i] = fmt.Sprintf("Success: %v", v.Success)
		i++
	}

	return fmt.Sprintf("Echo_EchoStructMap_Result{%v}", strings.Join(fields[:i], ", "))
}

// Equals returns true if all the fields of this Echo_EchoStructMap_Result match the
// provided Echo_EchoStructMap_Result.
//
// This function performs a deep comparison.
func (v *Echo_EchoStructMap_Result) Equals(rhs *Echo_EchoStructMap_Result) bool {
	if v == nil {
		return rhs == nil
	} else if rhs == nil {
		return false
	}
	if !((v.Success == nil && rhs.Success == nil) || (v.Success != nil && rhs.Success != nil && _Map_BarResponse_String_Equals(v.Success, rhs.Success))) {
		return false
	}

	return true
}

// MarshalLogObject implements zapcore.ObjectMarshaler, enabling
// fast logging of Echo_EchoStructMap_Result.
func (v *Echo_EchoStructMap_Result) MarshalLogObject(enc zapcore.ObjectEncoder) (err error) {
	if v == nil {
		return nil
	}
	if v.Success != nil {
		err = multierr.Append(err, enc.AddArray("success", (_Map_BarResponse_String_Zapper)(v.Success)))
	}
	return err
}

// GetSuccess returns the value of Success if it is set or its
// zero value if it is unset.
func (v *Echo_EchoStructMap_Result) GetSuccess() (o []struct {
	Key   *BarResponse
	Value string
}) {
	if v != nil && v.Success != nil {
		return v.Success
	}

	return
}

// IsSetSuccess returns true if Success is not nil.
func (v *Echo_EchoStructMap_Result) IsSetSuccess() bool {
	return v != nil && v.Success != nil
}

// MethodName returns the name of the Thrift function as specified in
// the IDL, for which this struct represent the result.
//
// This will always be "echoStructMap" for this struct.
func (v *Echo_EchoStructMap_Result) MethodName() string {
	return "echoStructMap"
}

// EnvelopeType returns the kind of value inside this struct.
//
// This will always be Reply for this struct.
func (v *Echo_EchoStructMap_Result) EnvelopeType() wire.EnvelopeType {
	return wire.Reply
}

// Echo_EchoStructSet_Args represents the arguments for the Echo.echoStructSet function.
//
// The arguments for echoStructSet are sent and received over the wire as this struct.
type Echo_EchoStructSet_Args struct {
	Arg []*BarResponse `json:"arg,required"`
}

type _Set_BarResponse_sliceType_ValueList []*BarResponse

func (v _Set_BarResponse_sliceType_ValueList) ForEach(f func(wire.Value) error) error {
	for _, x := range v {
		if x == nil {
			return fmt.Errorf("invalid set item: value is nil")
		}
		w, err := x.ToWire()
		if err != nil {
			return err
		}

		if err := f(w); err != nil {
			return err
		}
	}
	return nil
}

func (v _Set_BarResponse_sliceType_ValueList) Size() int {
	return len(v)
}

func (_Set_BarResponse_sliceType_ValueList) ValueType() wire.Type {
	return wire.TStruct
}

func (_Set_BarResponse_sliceType_ValueList) Close() {}

// ToWire translates a Echo_EchoStructSet_Args struct into a Thrift-level intermediate
// representation. This intermediate representation may be serialized
// into bytes using a ThriftRW protocol implementation.
//
// An error is returned if the struct or any of its fields failed to
// validate.
//
//   x, err := v.ToWire()
//   if err != nil {
//     return err
//   }
//
//   if err := binaryProtocol.Encode(x, writer); err != nil {
//     return err
//   }
func (v *Echo_EchoStructSet_Args) ToWire() (wire.Value, error) {
	var (
		fields [1]wire.Field
		i      int = 0
		w      wire.Value
		err    error
	)

	if v.Arg == nil {
		return w, errors.New("field Arg of Echo_EchoStructSet_Args is required")
	}
	w, err = wire.NewValueSet(_Set_BarResponse_sliceType_ValueList(v.Arg)), error(nil)
	if err != nil {
		return w, err
	}
	fields[i] = wire.Field{ID: 1, Value: w}
	i++

	return wire.NewValueStruct(wire.Struct{Fields: fields[:i]}), nil
}

func _Set_BarResponse_sliceType_Read(s wire.ValueList) ([]*BarResponse, error) {
	if s.ValueType() != wire.TStruct {
		return nil, nil
	}

	o := make([]*BarResponse, 0, s.Size())
	err := s.ForEach(func(x wire.Value) error {
		i, err := _BarResponse_Read(x)
		if err != nil {
			return err
		}

		o = append(o, i)
		return nil
	})
	s.Close()
	return o, err
}

// FromWire deserializes a Echo_EchoStructSet_Args struct from its Thrift-level
// representation. The Thrift-level representation may be obtained
// from a ThriftRW protocol implementation.
//
// An error is returned if we were unable to build a Echo_EchoStructSet_Args struct
// from the provided intermediate representation.
//
//   x, err := binaryProtocol.Decode(reader, wire.TStruct)
//   if err != nil {
//     return nil, err
//   }
//
//   var v Echo_EchoStructSet_Args
//   if err := v.FromWire(x); err != nil {
//     return nil, err
//   }
//   return &v, nil
func (v *Echo_EchoStructSet_Args) FromWire(w wire.Value) error {
	var err error

	argIsSet := false

	for _, field := range w.GetStruct().Fields {
		switch field.ID {
		case 1:
			if field.Value.Type() == wire.TSet {
				v.Arg, err = _Set_BarResponse_sliceType_Read(field.Value.GetSet())
				if err != nil {
					return err
				}
				argIsSet = true
			}
		}
	}

	if !argIsSet {
		return errors.New("field Arg of Echo_EchoStructSet_Args is required")
	}

	return nil
}

// String returns a readable string representation of a Echo_EchoStructSet_Args
// struct.
func (v *Echo_EchoStructSet_Args) String() string {
	if v == nil {
		return "<nil>"
	}

	var fields [1]string
	i := 0
	fields[i] = fmt.Sprintf("Arg: %v", v.Arg)
	i++

	return fmt.Sprintf("Echo_EchoStructSet_Args{%v}", strings.Join(fields[:i], ", "))
}

func _Set_BarResponse_sliceType_Equals(lhs, rhs []*BarResponse) bool {
	if len(lhs) != len(rhs) {
		return false
	}

	for _, x := range lhs {
		ok := false
		for _, y := range rhs {
			if x.Equals(y) {
				ok = true
				break
			}
		}
		if !ok {
			return false
		}
	}

	return true
}

// Equals returns true if all the fields of this Echo_EchoStructSet_Args match the
// provided Echo_EchoStructSet_Args.
//
// This function performs a deep comparison.
func (v *Echo_EchoStructSet_Args) Equals(rhs *Echo_EchoStructSet_Args) bool {
	if v == nil {
		return rhs == nil
	} else if rhs == nil {
		return false
	}
	if !_Set_BarResponse_sliceType_Equals(v.Arg, rhs.Arg) {
		return false
	}

	return true
}

type _Set_BarResponse_sliceType_Zapper []*BarResponse

// MarshalLogArray implements zapcore.ArrayMarshaler, enabling
// fast logging of _Set_BarResponse_sliceType_Zapper.
func (s _Set_BarResponse_sliceType_Zapper) MarshalLogArray(enc zapcore.ArrayEncoder) (err error) {
	for _, v := range s {
		err = multierr.Append(err, enc.AppendObject(v))
	}
	return err
}

// MarshalLogObject implements zapcore.ObjectMarshaler, enabling
// fast logging of Echo_EchoStructSet_Args.
func (v *Echo_EchoStructSet_Args) MarshalLogObject(enc zapcore.ObjectEncoder) (err error) {
	if v == nil {
		return nil
	}
	err = multierr.Append(err, enc.AddArray("arg", (_Set_BarResponse_sliceType_Zapper)(v.Arg)))
	return err
}

// GetArg returns the value of Arg if it is set or its
// zero value if it is unset.
func (v *Echo_EchoStructSet_Args) GetArg() (o []*BarResponse) {
	if v != nil {
		o = v.Arg
	}
	return
}

// IsSetArg returns true if Arg is not nil.
func (v *Echo_EchoStructSet_Args) IsSetArg() bool {
	return v != nil && v.Arg != nil
}

// MethodName returns the name of the Thrift function as specified in
// the IDL, for which this struct represent the arguments.
//
// This will always be "echoStructSet" for this struct.
func (v *Echo_EchoStructSet_Args) MethodName() string {
	return "echoStructSet"
}

// EnvelopeType returns the kind of value inside this struct.
//
// This will always be Call for this struct.
func (v *Echo_EchoStructSet_Args) EnvelopeType() wire.EnvelopeType {
	return wire.Call
}

// Echo_EchoStructSet_Helper provides functions that aid in handling the
// parameters and return values of the Echo.echoStructSet
// function.
var Echo_EchoStructSet_Helper = struct {
	// Args accepts the parameters of echoStructSet in-order and returns
	// the arguments struct for the function.
	Args func(
		arg []*BarResponse,
	) *Echo_EchoStructSet_Args

	// IsException returns true if the given error can be thrown
	// by echoStructSet.
	//
	// An error can be thrown by echoStructSet only if the
	// corresponding exception type was mentioned in the 'throws'
	// section for it in the Thrift file.
	IsException func(error) bool

	// WrapResponse returns the result struct for echoStructSet
	// given its return value and error.
	//
	// This allows mapping values and errors returned by
	// echoStructSet into a serializable result struct.
	// WrapResponse returns a non-nil error if the provided
	// error cannot be thrown by echoStructSet
	//
	//   value, err := echoStructSet(args)
	//   result, err := Echo_EchoStructSet_Helper.WrapResponse(value, err)
	//   if err != nil {
	//     return fmt.Errorf("unexpected error from echoStructSet: %v", err)
	//   }
	//   serialize(result)
	WrapResponse func([]*BarResponse, error) (*Echo_EchoStructSet_Result, error)

	// UnwrapResponse takes the result struct for echoStructSet
	// and returns the value or error returned by it.
	//
	// The error is non-nil only if echoStructSet threw an
	// exception.
	//
	//   result := deserialize(bytes)
	//   value, err := Echo_EchoStructSet_Helper.UnwrapResponse(result)
	UnwrapResponse func(*Echo_EchoStructSet_Result) ([]*BarResponse, error)
}{}

func init() {
	Echo_EchoStructSet_Helper.Args = func(
		arg []*BarResponse,
	) *Echo_EchoStructSet_Args {
		return &Echo_EchoStructSet_Args{
			Arg: arg,
		}
	}

	Echo_EchoStructSet_Helper.IsException = func(err error) bool {
		switch err.(type) {
		default:
			return false
		}
	}

	Echo_EchoStructSet_Helper.WrapResponse = func(success []*BarResponse, err error) (*Echo_EchoStructSet_Result, error) {
		if err == nil {
			return &Echo_EchoStructSet_Result{Success: success}, nil
		}

		return nil, err
	}
	Echo_EchoStructSet_Helper.UnwrapResponse = func(result *Echo_EchoStructSet_Result) (success []*BarResponse, err error) {

		if result.Success != nil {
			success = result.Success
			return
		}

		err = errors.New("expected a non-void result")
		return
	}

}

// Echo_EchoStructSet_Result represents the result of a Echo.echoStructSet function call.
//
// The result of a echoStructSet execution is sent and received over the wire as this struct.
//
// Success is set only if the function did not throw an exception.
type Echo_EchoStructSet_Result struct {
	// Value returned by echoStructSet after a successful execution.
	Success []*BarResponse `json:"success,omitempty"`
}

// ToWire translates a Echo_EchoStructSet_Result struct into a Thrift-level intermediate
// representation. This intermediate representation may be serialized
// into bytes using a ThriftRW protocol implementation.
//
// An error is returned if the struct or any of its fields failed to
// validate.
//
//   x, err := v.ToWire()
//   if err != nil {
//     return err
//   }
//
//   if err := binaryProtocol.Encode(x, writer); err != nil {
//     return err
//   }
func (v *Echo_EchoStructSet_Result) ToWire() (wire.Value, error) {
	var (
		fields [1]wire.Field
		i      int = 0
		w      wire.Value
		err    error
	)

	if v.Success != nil {
		w, err = wire.NewValueSet(_Set_BarResponse_sliceType_ValueList(v.Success)), error(nil)
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 0, Value: w}
		i++
	}

	if i != 1 {
		return wire.Value{}, fmt.Errorf("Echo_EchoStructSet_Result should have exactly one field: got %v fields", i)
	}

	return wire.NewValueStruct(wire.Struct{Fields: fields[:i]}), nil
}

// FromWire deserializes a Echo_EchoStructSet_Result struct from its Thrift-level
// representation. The Thrift-level representation may be obtained
// from a ThriftRW protocol implementation.
//
// An error is returned if we were unable to build a Echo_EchoStructSet_Result struct
// from the provided intermediate representation.
//
//   x, err := binaryProtocol.Decode(reader, wire.TStruct)
//   if err != nil {
//     return nil, err
//   }
//
//   var v Echo_EchoStructSet_Result
//   if err := v.FromWire(x); err != nil {
//     return nil, err
//   }
//   return &v, nil
func (v *Echo_EchoStructSet_Result) FromWire(w wire.Value) error {
	var err error

	for _, field := range w.GetStruct().Fields {
		switch field.ID {
		case 0:
			if field.Value.Type() == wire.TSet {
				v.Success, err = _Set_BarResponse_sliceType_Read(field.Value.GetSet())
				if err != nil {
					return err
				}

			}
		}
	}

	count := 0
	if v.Success != nil {
		count++
	}
	if count != 1 {
		return fmt.Errorf("Echo_EchoStructSet_Result should have exactly one field: got %v fields", count)
	}

	return nil
}

// String returns a readable string representation of a Echo_EchoStructSet_Result
// struct.
func (v *Echo_EchoStructSet_Result) String() string {
	if v == nil {
		return "<nil>"
	}

	var fields [1]string
	i := 0
	if v.Success != nil {
		fields[i] = fmt.Sprintf("Success: %v", v.Success)
		i++
	}

	return fmt.Sprintf("Echo_EchoStructSet_Result{%v}", strings.Join(fields[:i], ", "))
}

// Equals returns true if all the fields of this Echo_EchoStructSet_Result match the
// provided Echo_EchoStructSet_Result.
//
// This function performs a deep comparison.
func (v *Echo_EchoStructSet_Result) Equals(rhs *Echo_EchoStructSet_Result) bool {
	if v == nil {
		return rhs == nil
	} else if rhs == nil {
		return false
	}
	if !((v.Success == nil && rhs.Success == nil) || (v.Success != nil && rhs.Success != nil && _Set_BarResponse_sliceType_Equals(v.Success, rhs.Success))) {
		return false
	}

	return true
}

// MarshalLogObject implements zapcore.ObjectMarshaler, enabling
// fast logging of Echo_EchoStructSet_Result.
func (v *Echo_EchoStructSet_Result) MarshalLogObject(enc zapcore.ObjectEncoder) (err error) {
	if v == nil {
		return nil
	}
	if v.Success != nil {
		err = multierr.Append(err, enc.AddArray("success", (_Set_BarResponse_sliceType_Zapper)(v.Success)))
	}
	return err
}

// GetSuccess returns the value of Success if it is set or its
// zero value if it is unset.
func (v *Echo_EchoStructSet_Result) GetSuccess() (o []*BarResponse) {
	if v != nil && v.Success != nil {
		return v.Success
	}

	return
}

// IsSetSuccess returns true if Success is not nil.
func (v *Echo_EchoStructSet_Result) IsSetSuccess() bool {
	return v != nil && v.Success != nil
}

// MethodName returns the name of the Thrift function as specified in
// the IDL, for which this struct represent the result.
//
// This will always be "echoStructSet" for this struct.
func (v *Echo_EchoStructSet_Result) MethodName() string {
	return "echoStructSet"
}

// EnvelopeType returns the kind of value inside this struct.
//
// This will always be Reply for this struct.
func (v *Echo_EchoStructSet_Result) EnvelopeType() wire.EnvelopeType {
	return wire.Reply
}

// Echo_EchoTypedef_Args represents the arguments for the Echo.echoTypedef function.
//
// The arguments for echoTypedef are sent and received over the wire as this struct.
type Echo_EchoTypedef_Args struct {
	Arg UUID `json:"arg,required"`
}

// ToWire translates a Echo_EchoTypedef_Args struct into a Thrift-level intermediate
// representation. This intermediate representation may be serialized
// into bytes using a ThriftRW protocol implementation.
//
// An error is returned if the struct or any of its fields failed to
// validate.
//
//   x, err := v.ToWire()
//   if err != nil {
//     return err
//   }
//
//   if err := binaryProtocol.Encode(x, writer); err != nil {
//     return err
//   }
func (v *Echo_EchoTypedef_Args) ToWire() (wire.Value, error) {
	var (
		fields [1]wire.Field
		i      int = 0
		w      wire.Value
		err    error
	)

	w, err = v.Arg.ToWire()
	if err != nil {
		return w, err
	}
	fields[i] = wire.Field{ID: 1, Value: w}
	i++

	return wire.NewValueStruct(wire.Struct{Fields: fields[:i]}), nil
}

// FromWire deserializes a Echo_EchoTypedef_Args struct from its Thrift-level
// representation. The Thrift-level representation may be obtained
// from a ThriftRW protocol implementation.
//
// An error is returned if we were unable to build a Echo_EchoTypedef_Args struct
// from the provided intermediate representation.
//
//   x, err := binaryProtocol.Decode(reader, wire.TStruct)
//   if err != nil {
//     return nil, err
//   }
//
//   var v Echo_EchoTypedef_Args
//   if err := v.FromWire(x); err != nil {
//     return nil, err
//   }
//   return &v, nil
func (v *Echo_EchoTypedef_Args) FromWire(w wire.Value) error {
	var err error

	argIsSet := false

	for _, field := range w.GetStruct().Fields {
		switch field.ID {
		case 1:
			if field.Value.Type() == wire.TBinary {
				v.Arg, err = _UUID_Read(field.Value)
				if err != nil {
					return err
				}
				argIsSet = true
			}
		}
	}

	if !argIsSet {
		return errors.New("field Arg of Echo_EchoTypedef_Args is required")
	}

	return nil
}

// String returns a readable string representation of a Echo_EchoTypedef_Args
// struct.
func (v *Echo_EchoTypedef_Args) String() string {
	if v == nil {
		return "<nil>"
	}

	var fields [1]string
	i := 0
	fields[i] = fmt.Sprintf("Arg: %v", v.Arg)
	i++

	return fmt.Sprintf("Echo_EchoTypedef_Args{%v}", strings.Join(fields[:i], ", "))
}

// Equals returns true if all the fields of this Echo_EchoTypedef_Args match the
// provided Echo_EchoTypedef_Args.
//
// This function performs a deep comparison.
func (v *Echo_EchoTypedef_Args) Equals(rhs *Echo_EchoTypedef_Args) bool {
	if v == nil {
		return rhs == nil
	} else if rhs == nil {
		return false
	}
	if !(v.Arg == rhs.Arg) {
		return false
	}

	return true
}

// MarshalLogObject implements zapcore.ObjectMarshaler, enabling
// fast logging of Echo_EchoTypedef_Args.
func (v *Echo_EchoTypedef_Args) MarshalLogObject(enc zapcore.ObjectEncoder) (err error) {
	if v == nil {
		return nil
	}
	enc.AddString("arg", (string)(v.Arg))
	return err
}

// GetArg returns the value of Arg if it is set or its
// zero value if it is unset.
func (v *Echo_EchoTypedef_Args) GetArg() (o UUID) {
	if v != nil {
		o = v.Arg
	}
	return
}

// MethodName returns the name of the Thrift function as specified in
// the IDL, for which this struct represent the arguments.
//
// This will always be "echoTypedef" for this struct.
func (v *Echo_EchoTypedef_Args) MethodName() string {
	return "echoTypedef"
}

// EnvelopeType returns the kind of value inside this struct.
//
// This will always be Call for this struct.
func (v *Echo_EchoTypedef_Args) EnvelopeType() wire.EnvelopeType {
	return wire.Call
}

// Echo_EchoTypedef_Helper provides functions that aid in handling the
// parameters and return values of the Echo.echoTypedef
// function.
var Echo_EchoTypedef_Helper = struct {
	// Args accepts the parameters of echoTypedef in-order and returns
	// the arguments struct for the function.
	Args func(
		arg UUID,
	) *Echo_EchoTypedef_Args

	// IsException returns true if the given error can be thrown
	// by echoTypedef.
	//
	// An error can be thrown by echoTypedef only if the
	// corresponding exception type was mentioned in the 'throws'
	// section for it in the Thrift file.
	IsException func(error) bool

	// WrapResponse returns the result struct for echoTypedef
	// given its return value and error.
	//
	// This allows mapping values and errors returned by
	// echoTypedef into a serializable result struct.
	// WrapResponse returns a non-nil error if the provided
	// error cannot be thrown by echoTypedef
	//
	//   value, err := echoTypedef(args)
	//   result, err := Echo_EchoTypedef_Helper.WrapResponse(value, err)
	//   if err != nil {
	//     return fmt.Errorf("unexpected error from echoTypedef: %v", err)
	//   }
	//   serialize(result)
	WrapResponse func(UUID, error) (*Echo_EchoTypedef_Result, error)

	// UnwrapResponse takes the result struct for echoTypedef
	// and returns the value or error returned by it.
	//
	// The error is non-nil only if echoTypedef threw an
	// exception.
	//
	//   result := deserialize(bytes)
	//   value, err := Echo_EchoTypedef_Helper.UnwrapResponse(result)
	UnwrapResponse func(*Echo_EchoTypedef_Result) (UUID, error)
}{}

func init() {
	Echo_EchoTypedef_Helper.Args = func(
		arg UUID,
	) *Echo_EchoTypedef_Args {
		return &Echo_EchoTypedef_Args{
			Arg: arg,
		}
	}

	Echo_EchoTypedef_Helper.IsException = func(err error) bool {
		switch err.(type) {
		default:
			return false
		}
	}

	Echo_EchoTypedef_Helper.WrapResponse = func(success UUID, err error) (*Echo_EchoTypedef_Result, error) {
		if err == nil {
			return &Echo_EchoTypedef_Result{Success: &success}, nil
		}

		return nil, err
	}
	Echo_EchoTypedef_Helper.UnwrapResponse = func(result *Echo_EchoTypedef_Result) (success UUID, err error) {

		if result.Success != nil {
			success = *result.Success
			return
		}

		err = errors.New("expected a non-void result")
		return
	}

}

// Echo_EchoTypedef_Result represents the result of a Echo.echoTypedef function call.
//
// The result of a echoTypedef execution is sent and received over the wire as this struct.
//
// Success is set only if the function did not throw an exception.
type Echo_EchoTypedef_Result struct {
	// Value returned by echoTypedef after a successful execution.
	Success *UUID `json:"success,omitempty"`
}

// ToWire translates a Echo_EchoTypedef_Result struct into a Thrift-level intermediate
// representation. This intermediate representation may be serialized
// into bytes using a ThriftRW protocol implementation.
//
// An error is returned if the struct or any of its fields failed to
// validate.
//
//   x, err := v.ToWire()
//   if err != nil {
//     return err
//   }
//
//   if err := binaryProtocol.Encode(x, writer); err != nil {
//     return err
//   }
func (v *Echo_EchoTypedef_Result) ToWire() (wire.Value, error) {
	var (
		fields [1]wire.Field
		i      int = 0
		w      wire.Value
		err    error
	)

	if v.Success != nil {
		w, err = v.Success.ToWire()
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 0, Value: w}
		i++
	}

	if i != 1 {
		return wire.Value{}, fmt.Errorf("Echo_EchoTypedef_Result should have exactly one field: got %v fields", i)
	}

	return wire.NewValueStruct(wire.Struct{Fields: fields[:i]}), nil
}

// FromWire deserializes a Echo_EchoTypedef_Result struct from its Thrift-level
// representation. The Thrift-level representation may be obtained
// from a ThriftRW protocol implementation.
//
// An error is returned if we were unable to build a Echo_EchoTypedef_Result struct
// from the provided intermediate representation.
//
//   x, err := binaryProtocol.Decode(reader, wire.TStruct)
//   if err != nil {
//     return nil, err
//   }
//
//   var v Echo_EchoTypedef_Result
//   if err := v.FromWire(x); err != nil {
//     return nil, err
//   }
//   return &v, nil
func (v *Echo_EchoTypedef_Result) FromWire(w wire.Value) error {
	var err error

	for _, field := range w.GetStruct().Fields {
		switch field.ID {
		case 0:
			if field.Value.Type() == wire.TBinary {
				var x UUID
				x, err = _UUID_Read(field.Value)
				v.Success = &x
				if err != nil {
					return err
				}

			}
		}
	}

	count := 0
	if v.Success != nil {
		count++
	}
	if count != 1 {
		return fmt.Errorf("Echo_EchoTypedef_Result should have exactly one field: got %v fields", count)
	}

	return nil
}

// String returns a readable string representation of a Echo_EchoTypedef_Result
// struct.
func (v *Echo_EchoTypedef_Result) String() string {
	if v == nil {
		return "<nil>"
	}

	var fields [1]string
	i := 0
	if v.Success != nil {
		fields[i] = fmt.Sprintf("Success: %v", *(v.Success))
		i++
	}

	return fmt.Sprintf("Echo_EchoTypedef_Result{%v}", strings.Join(fields[:i], ", "))
}

// Equals returns true if all the fields of this Echo_EchoTypedef_Result match the
// provided Echo_EchoTypedef_Result.
//
// This function performs a deep comparison.
func (v *Echo_EchoTypedef_Result) Equals(rhs *Echo_EchoTypedef_Result) bool {
	if v == nil {
		return rhs == nil
	} else if rhs == nil {
		return false
	}
	if !_UUID_EqualsPtr(v.Success, rhs.Success) {
		return false
	}

	return true
}

// MarshalLogObject implements zapcore.ObjectMarshaler, enabling
// fast logging of Echo_EchoTypedef_Result.
func (v *Echo_EchoTypedef_Result) MarshalLogObject(enc zapcore.ObjectEncoder) (err error) {
	if v == nil {
		return nil
	}
	if v.Success != nil {
		enc.AddString("success", (string)(*v.Success))
	}
	return err
}

// GetSuccess returns the value of Success if it is set or its
// zero value if it is unset.
func (v *Echo_EchoTypedef_Result) GetSuccess() (o UUID) {
	if v != nil && v.Success != nil {
		return *v.Success
	}

	return
}

// IsSetSuccess returns true if Success is not nil.
func (v *Echo_EchoTypedef_Result) IsSetSuccess() bool {
	return v != nil && v.Success != nil
}

// MethodName returns the name of the Thrift function as specified in
// the IDL, for which this struct represent the result.
//
// This will always be "echoTypedef" for this struct.
func (v *Echo_EchoTypedef_Result) MethodName() string {
	return "echoTypedef"
}

// EnvelopeType returns the kind of value inside this struct.
//
// This will always be Reply for this struct.
func (v *Echo_EchoTypedef_Result) EnvelopeType() wire.EnvelopeType {
	return wire.Reply
}
