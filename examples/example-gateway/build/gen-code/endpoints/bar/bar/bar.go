// Code generated by thriftrw v1.20.2. DO NOT EDIT.
// @generated

package bar

import (
	bytes "bytes"
	base64 "encoding/base64"
	json "encoding/json"
	errors "errors"
	fmt "fmt"
	math "math"
	strconv "strconv"
	strings "strings"

	foo "github.com/uber/zanzibar/examples/example-gateway/build/gen-code/endpoints/foo/foo"
	multierr "go.uber.org/multierr"
	wire "go.uber.org/thriftrw/wire"
	zapcore "go.uber.org/zap/zapcore"
)

type BarException struct {
	StringField string `json:"stringField,required"`
}

// ToWire translates a BarException struct into a Thrift-level intermediate
// representation. This intermediate representation may be serialized
// into bytes using a ThriftRW protocol implementation.
//
// An error is returned if the struct or any of its fields failed to
// validate.
//
//   x, err := v.ToWire()
//   if err != nil {
//     return err
//   }
//
//   if err := binaryProtocol.Encode(x, writer); err != nil {
//     return err
//   }
func (v *BarException) ToWire() (wire.Value, error) {
	var (
		fields [1]wire.Field
		i      int = 0
		w      wire.Value
		err    error
	)

	w, err = wire.NewValueString(v.StringField), error(nil)
	if err != nil {
		return w, err
	}
	fields[i] = wire.Field{ID: 1, Value: w}
	i++

	return wire.NewValueStruct(wire.Struct{Fields: fields[:i]}), nil
}

// FromWire deserializes a BarException struct from its Thrift-level
// representation. The Thrift-level representation may be obtained
// from a ThriftRW protocol implementation.
//
// An error is returned if we were unable to build a BarException struct
// from the provided intermediate representation.
//
//   x, err := binaryProtocol.Decode(reader, wire.TStruct)
//   if err != nil {
//     return nil, err
//   }
//
//   var v BarException
//   if err := v.FromWire(x); err != nil {
//     return nil, err
//   }
//   return &v, nil
func (v *BarException) FromWire(w wire.Value) error {
	var err error

	stringFieldIsSet := false

	for _, field := range w.GetStruct().Fields {
		switch field.ID {
		case 1:
			if field.Value.Type() == wire.TBinary {
				v.StringField, err = field.Value.GetString(), error(nil)
				if err != nil {
					return err
				}
				stringFieldIsSet = true
			}
		}
	}

	if !stringFieldIsSet {
		return errors.New("field StringField of BarException is required")
	}

	return nil
}

// String returns a readable string representation of a BarException
// struct.
func (v *BarException) String() string {
	if v == nil {
		return "<nil>"
	}

	var fields [1]string
	i := 0
	fields[i] = fmt.Sprintf("StringField: %v", v.StringField)
	i++

	return fmt.Sprintf("BarException{%v}", strings.Join(fields[:i], ", "))
}

// Equals returns true if all the fields of this BarException match the
// provided BarException.
//
// This function performs a deep comparison.
func (v *BarException) Equals(rhs *BarException) bool {
	if v == nil {
		return rhs == nil
	} else if rhs == nil {
		return false
	}
	if !(v.StringField == rhs.StringField) {
		return false
	}

	return true
}

// MarshalLogObject implements zapcore.ObjectMarshaler, enabling
// fast logging of BarException.
func (v *BarException) MarshalLogObject(enc zapcore.ObjectEncoder) (err error) {
	if v == nil {
		return nil
	}
	enc.AddString("stringField", v.StringField)
	return err
}

// GetStringField returns the value of StringField if it is set or its
// zero value if it is unset.
func (v *BarException) GetStringField() (o string) {
	if v != nil {
		o = v.StringField
	}
	return
}

func (v *BarException) Error() string {
	return v.String()
}

type BarRequest struct {
	StringField string    `json:"stringField,required"`
	BoolField   bool      `json:"boolField,required"`
	BinaryField []byte    `json:"binaryField,required"`
	Timestamp   Timestamp `json:"timestamp,required"`
	EnumField   Fruit     `json:"enumField,required"`
	LongField   Long      `json:"longField,required"`
}

// ToWire translates a BarRequest struct into a Thrift-level intermediate
// representation. This intermediate representation may be serialized
// into bytes using a ThriftRW protocol implementation.
//
// An error is returned if the struct or any of its fields failed to
// validate.
//
//   x, err := v.ToWire()
//   if err != nil {
//     return err
//   }
//
//   if err := binaryProtocol.Encode(x, writer); err != nil {
//     return err
//   }
func (v *BarRequest) ToWire() (wire.Value, error) {
	var (
		fields [6]wire.Field
		i      int = 0
		w      wire.Value
		err    error
	)

	w, err = wire.NewValueString(v.StringField), error(nil)
	if err != nil {
		return w, err
	}
	fields[i] = wire.Field{ID: 1, Value: w}
	i++

	w, err = wire.NewValueBool(v.BoolField), error(nil)
	if err != nil {
		return w, err
	}
	fields[i] = wire.Field{ID: 2, Value: w}
	i++
	if v.BinaryField == nil {
		return w, errors.New("field BinaryField of BarRequest is required")
	}
	w, err = wire.NewValueBinary(v.BinaryField), error(nil)
	if err != nil {
		return w, err
	}
	fields[i] = wire.Field{ID: 3, Value: w}
	i++

	w, err = v.Timestamp.ToWire()
	if err != nil {
		return w, err
	}
	fields[i] = wire.Field{ID: 4, Value: w}
	i++

	w, err = v.EnumField.ToWire()
	if err != nil {
		return w, err
	}
	fields[i] = wire.Field{ID: 5, Value: w}
	i++

	w, err = v.LongField.ToWire()
	if err != nil {
		return w, err
	}
	fields[i] = wire.Field{ID: 6, Value: w}
	i++

	return wire.NewValueStruct(wire.Struct{Fields: fields[:i]}), nil
}

func _Timestamp_Read(w wire.Value) (Timestamp, error) {
	var x Timestamp
	err := x.FromWire(w)
	return x, err
}

func _Fruit_Read(w wire.Value) (Fruit, error) {
	var v Fruit
	err := v.FromWire(w)
	return v, err
}

func _Long_Read(w wire.Value) (Long, error) {
	var x Long
	err := x.FromWire(w)
	return x, err
}

// FromWire deserializes a BarRequest struct from its Thrift-level
// representation. The Thrift-level representation may be obtained
// from a ThriftRW protocol implementation.
//
// An error is returned if we were unable to build a BarRequest struct
// from the provided intermediate representation.
//
//   x, err := binaryProtocol.Decode(reader, wire.TStruct)
//   if err != nil {
//     return nil, err
//   }
//
//   var v BarRequest
//   if err := v.FromWire(x); err != nil {
//     return nil, err
//   }
//   return &v, nil
func (v *BarRequest) FromWire(w wire.Value) error {
	var err error

	stringFieldIsSet := false
	boolFieldIsSet := false
	binaryFieldIsSet := false
	timestampIsSet := false
	enumFieldIsSet := false
	longFieldIsSet := false

	for _, field := range w.GetStruct().Fields {
		switch field.ID {
		case 1:
			if field.Value.Type() == wire.TBinary {
				v.StringField, err = field.Value.GetString(), error(nil)
				if err != nil {
					return err
				}
				stringFieldIsSet = true
			}
		case 2:
			if field.Value.Type() == wire.TBool {
				v.BoolField, err = field.Value.GetBool(), error(nil)
				if err != nil {
					return err
				}
				boolFieldIsSet = true
			}
		case 3:
			if field.Value.Type() == wire.TBinary {
				v.BinaryField, err = field.Value.GetBinary(), error(nil)
				if err != nil {
					return err
				}
				binaryFieldIsSet = true
			}
		case 4:
			if field.Value.Type() == wire.TI64 {
				v.Timestamp, err = _Timestamp_Read(field.Value)
				if err != nil {
					return err
				}
				timestampIsSet = true
			}
		case 5:
			if field.Value.Type() == wire.TI32 {
				v.EnumField, err = _Fruit_Read(field.Value)
				if err != nil {
					return err
				}
				enumFieldIsSet = true
			}
		case 6:
			if field.Value.Type() == wire.TI64 {
				v.LongField, err = _Long_Read(field.Value)
				if err != nil {
					return err
				}
				longFieldIsSet = true
			}
		}
	}

	if !stringFieldIsSet {
		return errors.New("field StringField of BarRequest is required")
	}

	if !boolFieldIsSet {
		return errors.New("field BoolField of BarRequest is required")
	}

	if !binaryFieldIsSet {
		return errors.New("field BinaryField of BarRequest is required")
	}

	if !timestampIsSet {
		return errors.New("field Timestamp of BarRequest is required")
	}

	if !enumFieldIsSet {
		return errors.New("field EnumField of BarRequest is required")
	}

	if !longFieldIsSet {
		return errors.New("field LongField of BarRequest is required")
	}

	return nil
}

// String returns a readable string representation of a BarRequest
// struct.
func (v *BarRequest) String() string {
	if v == nil {
		return "<nil>"
	}

	var fields [6]string
	i := 0
	fields[i] = fmt.Sprintf("StringField: %v", v.StringField)
	i++
	fields[i] = fmt.Sprintf("BoolField: %v", v.BoolField)
	i++
	fields[i] = fmt.Sprintf("BinaryField: %v", v.BinaryField)
	i++
	fields[i] = fmt.Sprintf("Timestamp: %v", v.Timestamp)
	i++
	fields[i] = fmt.Sprintf("EnumField: %v", v.EnumField)
	i++
	fields[i] = fmt.Sprintf("LongField: %v", v.LongField)
	i++

	return fmt.Sprintf("BarRequest{%v}", strings.Join(fields[:i], ", "))
}

// Equals returns true if all the fields of this BarRequest match the
// provided BarRequest.
//
// This function performs a deep comparison.
func (v *BarRequest) Equals(rhs *BarRequest) bool {
	if v == nil {
		return rhs == nil
	} else if rhs == nil {
		return false
	}
	if !(v.StringField == rhs.StringField) {
		return false
	}
	if !(v.BoolField == rhs.BoolField) {
		return false
	}
	if !bytes.Equal(v.BinaryField, rhs.BinaryField) {
		return false
	}
	if !(v.Timestamp == rhs.Timestamp) {
		return false
	}
	if !v.EnumField.Equals(rhs.EnumField) {
		return false
	}
	if !(v.LongField == rhs.LongField) {
		return false
	}

	return true
}

// MarshalLogObject implements zapcore.ObjectMarshaler, enabling
// fast logging of BarRequest.
func (v *BarRequest) MarshalLogObject(enc zapcore.ObjectEncoder) (err error) {
	if v == nil {
		return nil
	}
	enc.AddString("stringField", v.StringField)
	enc.AddBool("boolField", v.BoolField)
	enc.AddString("binaryField", base64.StdEncoding.EncodeToString(v.BinaryField))
	enc.AddInt64("timestamp", (int64)(v.Timestamp))
	err = multierr.Append(err, enc.AddObject("enumField", v.EnumField))
	enc.AddInt64("longField", (int64)(v.LongField))
	return err
}

// GetStringField returns the value of StringField if it is set or its
// zero value if it is unset.
func (v *BarRequest) GetStringField() (o string) {
	if v != nil {
		o = v.StringField
	}
	return
}

// GetBoolField returns the value of BoolField if it is set or its
// zero value if it is unset.
func (v *BarRequest) GetBoolField() (o bool) {
	if v != nil {
		o = v.BoolField
	}
	return
}

// GetBinaryField returns the value of BinaryField if it is set or its
// zero value if it is unset.
func (v *BarRequest) GetBinaryField() (o []byte) {
	if v != nil {
		o = v.BinaryField
	}
	return
}

// IsSetBinaryField returns true if BinaryField is not nil.
func (v *BarRequest) IsSetBinaryField() bool {
	return v != nil && v.BinaryField != nil
}

// GetTimestamp returns the value of Timestamp if it is set or its
// zero value if it is unset.
func (v *BarRequest) GetTimestamp() (o Timestamp) {
	if v != nil {
		o = v.Timestamp
	}
	return
}

// GetEnumField returns the value of EnumField if it is set or its
// zero value if it is unset.
func (v *BarRequest) GetEnumField() (o Fruit) {
	if v != nil {
		o = v.EnumField
	}
	return
}

// GetLongField returns the value of LongField if it is set or its
// zero value if it is unset.
func (v *BarRequest) GetLongField() (o Long) {
	if v != nil {
		o = v.LongField
	}
	return
}

type BarResponse struct {
	StringField        string           `json:"stringField,required"`
	IntWithRange       int32            `json:"intWithRange,required"`
	IntWithoutRange    int32            `json:"intWithoutRange,required"`
	MapIntWithRange    map[UUID]int32   `json:"mapIntWithRange,required"`
	MapIntWithoutRange map[string]int32 `json:"mapIntWithoutRange,required"`
	BinaryField        []byte           `json:"binaryField,required"`
	NextResponse       *BarResponse     `json:"nextResponse,omitempty"`
}

type _Map_UUID_I32_MapItemList map[UUID]int32

func (m _Map_UUID_I32_MapItemList) ForEach(f func(wire.MapItem) error) error {
	for k, v := range m {
		kw, err := k.ToWire()
		if err != nil {
			return err
		}

		vw, err := wire.NewValueI32(v), error(nil)
		if err != nil {
			return err
		}
		err = f(wire.MapItem{Key: kw, Value: vw})
		if err != nil {
			return err
		}
	}
	return nil
}

func (m _Map_UUID_I32_MapItemList) Size() int {
	return len(m)
}

func (_Map_UUID_I32_MapItemList) KeyType() wire.Type {
	return wire.TBinary
}

func (_Map_UUID_I32_MapItemList) ValueType() wire.Type {
	return wire.TI32
}

func (_Map_UUID_I32_MapItemList) Close() {}

type _Map_String_I32_MapItemList map[string]int32

func (m _Map_String_I32_MapItemList) ForEach(f func(wire.MapItem) error) error {
	for k, v := range m {
		kw, err := wire.NewValueString(k), error(nil)
		if err != nil {
			return err
		}

		vw, err := wire.NewValueI32(v), error(nil)
		if err != nil {
			return err
		}
		err = f(wire.MapItem{Key: kw, Value: vw})
		if err != nil {
			return err
		}
	}
	return nil
}

func (m _Map_String_I32_MapItemList) Size() int {
	return len(m)
}

func (_Map_String_I32_MapItemList) KeyType() wire.Type {
	return wire.TBinary
}

func (_Map_String_I32_MapItemList) ValueType() wire.Type {
	return wire.TI32
}

func (_Map_String_I32_MapItemList) Close() {}

// ToWire translates a BarResponse struct into a Thrift-level intermediate
// representation. This intermediate representation may be serialized
// into bytes using a ThriftRW protocol implementation.
//
// An error is returned if the struct or any of its fields failed to
// validate.
//
//   x, err := v.ToWire()
//   if err != nil {
//     return err
//   }
//
//   if err := binaryProtocol.Encode(x, writer); err != nil {
//     return err
//   }
func (v *BarResponse) ToWire() (wire.Value, error) {
	var (
		fields [7]wire.Field
		i      int = 0
		w      wire.Value
		err    error
	)

	w, err = wire.NewValueString(v.StringField), error(nil)
	if err != nil {
		return w, err
	}
	fields[i] = wire.Field{ID: 1, Value: w}
	i++

	w, err = wire.NewValueI32(v.IntWithRange), error(nil)
	if err != nil {
		return w, err
	}
	fields[i] = wire.Field{ID: 2, Value: w}
	i++

	w, err = wire.NewValueI32(v.IntWithoutRange), error(nil)
	if err != nil {
		return w, err
	}
	fields[i] = wire.Field{ID: 3, Value: w}
	i++
	if v.MapIntWithRange == nil {
		return w, errors.New("field MapIntWithRange of BarResponse is required")
	}
	w, err = wire.NewValueMap(_Map_UUID_I32_MapItemList(v.MapIntWithRange)), error(nil)
	if err != nil {
		return w, err
	}
	fields[i] = wire.Field{ID: 4, Value: w}
	i++
	if v.MapIntWithoutRange == nil {
		return w, errors.New("field MapIntWithoutRange of BarResponse is required")
	}
	w, err = wire.NewValueMap(_Map_String_I32_MapItemList(v.MapIntWithoutRange)), error(nil)
	if err != nil {
		return w, err
	}
	fields[i] = wire.Field{ID: 5, Value: w}
	i++
	if v.BinaryField == nil {
		return w, errors.New("field BinaryField of BarResponse is required")
	}
	w, err = wire.NewValueBinary(v.BinaryField), error(nil)
	if err != nil {
		return w, err
	}
	fields[i] = wire.Field{ID: 6, Value: w}
	i++
	if v.NextResponse != nil {
		w, err = v.NextResponse.ToWire()
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 7, Value: w}
		i++
	}

	return wire.NewValueStruct(wire.Struct{Fields: fields[:i]}), nil
}

func _UUID_Read(w wire.Value) (UUID, error) {
	var x UUID
	err := x.FromWire(w)
	return x, err
}

func _Map_UUID_I32_Read(m wire.MapItemList) (map[UUID]int32, error) {
	if m.KeyType() != wire.TBinary {
		return nil, nil
	}

	if m.ValueType() != wire.TI32 {
		return nil, nil
	}

	o := make(map[UUID]int32, m.Size())
	err := m.ForEach(func(x wire.MapItem) error {
		k, err := _UUID_Read(x.Key)
		if err != nil {
			return err
		}

		v, err := x.Value.GetI32(), error(nil)
		if err != nil {
			return err
		}

		o[k] = v
		return nil
	})
	m.Close()
	return o, err
}

func _Map_String_I32_Read(m wire.MapItemList) (map[string]int32, error) {
	if m.KeyType() != wire.TBinary {
		return nil, nil
	}

	if m.ValueType() != wire.TI32 {
		return nil, nil
	}

	o := make(map[string]int32, m.Size())
	err := m.ForEach(func(x wire.MapItem) error {
		k, err := x.Key.GetString(), error(nil)
		if err != nil {
			return err
		}

		v, err := x.Value.GetI32(), error(nil)
		if err != nil {
			return err
		}

		o[k] = v
		return nil
	})
	m.Close()
	return o, err
}

func _BarResponse_Read(w wire.Value) (*BarResponse, error) {
	var v BarResponse
	err := v.FromWire(w)
	return &v, err
}

// FromWire deserializes a BarResponse struct from its Thrift-level
// representation. The Thrift-level representation may be obtained
// from a ThriftRW protocol implementation.
//
// An error is returned if we were unable to build a BarResponse struct
// from the provided intermediate representation.
//
//   x, err := binaryProtocol.Decode(reader, wire.TStruct)
//   if err != nil {
//     return nil, err
//   }
//
//   var v BarResponse
//   if err := v.FromWire(x); err != nil {
//     return nil, err
//   }
//   return &v, nil
func (v *BarResponse) FromWire(w wire.Value) error {
	var err error

	stringFieldIsSet := false
	intWithRangeIsSet := false
	intWithoutRangeIsSet := false
	mapIntWithRangeIsSet := false
	mapIntWithoutRangeIsSet := false
	binaryFieldIsSet := false

	for _, field := range w.GetStruct().Fields {
		switch field.ID {
		case 1:
			if field.Value.Type() == wire.TBinary {
				v.StringField, err = field.Value.GetString(), error(nil)
				if err != nil {
					return err
				}
				stringFieldIsSet = true
			}
		case 2:
			if field.Value.Type() == wire.TI32 {
				v.IntWithRange, err = field.Value.GetI32(), error(nil)
				if err != nil {
					return err
				}
				intWithRangeIsSet = true
			}
		case 3:
			if field.Value.Type() == wire.TI32 {
				v.IntWithoutRange, err = field.Value.GetI32(), error(nil)
				if err != nil {
					return err
				}
				intWithoutRangeIsSet = true
			}
		case 4:
			if field.Value.Type() == wire.TMap {
				v.MapIntWithRange, err = _Map_UUID_I32_Read(field.Value.GetMap())
				if err != nil {
					return err
				}
				mapIntWithRangeIsSet = true
			}
		case 5:
			if field.Value.Type() == wire.TMap {
				v.MapIntWithoutRange, err = _Map_String_I32_Read(field.Value.GetMap())
				if err != nil {
					return err
				}
				mapIntWithoutRangeIsSet = true
			}
		case 6:
			if field.Value.Type() == wire.TBinary {
				v.BinaryField, err = field.Value.GetBinary(), error(nil)
				if err != nil {
					return err
				}
				binaryFieldIsSet = true
			}
		case 7:
			if field.Value.Type() == wire.TStruct {
				v.NextResponse, err = _BarResponse_Read(field.Value)
				if err != nil {
					return err
				}

			}
		}
	}

	if !stringFieldIsSet {
		return errors.New("field StringField of BarResponse is required")
	}

	if !intWithRangeIsSet {
		return errors.New("field IntWithRange of BarResponse is required")
	}

	if !intWithoutRangeIsSet {
		return errors.New("field IntWithoutRange of BarResponse is required")
	}

	if !mapIntWithRangeIsSet {
		return errors.New("field MapIntWithRange of BarResponse is required")
	}

	if !mapIntWithoutRangeIsSet {
		return errors.New("field MapIntWithoutRange of BarResponse is required")
	}

	if !binaryFieldIsSet {
		return errors.New("field BinaryField of BarResponse is required")
	}

	return nil
}

// String returns a readable string representation of a BarResponse
// struct.
func (v *BarResponse) String() string {
	if v == nil {
		return "<nil>"
	}

	var fields [7]string
	i := 0
	fields[i] = fmt.Sprintf("StringField: %v", v.StringField)
	i++
	fields[i] = fmt.Sprintf("IntWithRange: %v", v.IntWithRange)
	i++
	fields[i] = fmt.Sprintf("IntWithoutRange: %v", v.IntWithoutRange)
	i++
	fields[i] = fmt.Sprintf("MapIntWithRange: %v", v.MapIntWithRange)
	i++
	fields[i] = fmt.Sprintf("MapIntWithoutRange: %v", v.MapIntWithoutRange)
	i++
	fields[i] = fmt.Sprintf("BinaryField: %v", v.BinaryField)
	i++
	if v.NextResponse != nil {
		fields[i] = fmt.Sprintf("NextResponse: %v", v.NextResponse)
		i++
	}

	return fmt.Sprintf("BarResponse{%v}", strings.Join(fields[:i], ", "))
}

func _Map_UUID_I32_Equals(lhs, rhs map[UUID]int32) bool {
	if len(lhs) != len(rhs) {
		return false
	}

	for lk, lv := range lhs {
		rv, ok := rhs[lk]
		if !ok {
			return false
		}
		if !(lv == rv) {
			return false
		}
	}
	return true
}

func _Map_String_I32_Equals(lhs, rhs map[string]int32) bool {
	if len(lhs) != len(rhs) {
		return false
	}

	for lk, lv := range lhs {
		rv, ok := rhs[lk]
		if !ok {
			return false
		}
		if !(lv == rv) {
			return false
		}
	}
	return true
}

// Equals returns true if all the fields of this BarResponse match the
// provided BarResponse.
//
// This function performs a deep comparison.
func (v *BarResponse) Equals(rhs *BarResponse) bool {
	if v == nil {
		return rhs == nil
	} else if rhs == nil {
		return false
	}
	if !(v.StringField == rhs.StringField) {
		return false
	}
	if !(v.IntWithRange == rhs.IntWithRange) {
		return false
	}
	if !(v.IntWithoutRange == rhs.IntWithoutRange) {
		return false
	}
	if !_Map_UUID_I32_Equals(v.MapIntWithRange, rhs.MapIntWithRange) {
		return false
	}
	if !_Map_String_I32_Equals(v.MapIntWithoutRange, rhs.MapIntWithoutRange) {
		return false
	}
	if !bytes.Equal(v.BinaryField, rhs.BinaryField) {
		return false
	}
	if !((v.NextResponse == nil && rhs.NextResponse == nil) || (v.NextResponse != nil && rhs.NextResponse != nil && v.NextResponse.Equals(rhs.NextResponse))) {
		return false
	}

	return true
}

type _Map_UUID_I32_Zapper map[UUID]int32

// MarshalLogObject implements zapcore.ObjectMarshaler, enabling
// fast logging of _Map_UUID_I32_Zapper.
func (m _Map_UUID_I32_Zapper) MarshalLogObject(enc zapcore.ObjectEncoder) (err error) {
	for k, v := range m {
		enc.AddInt32((string)(k), v)
	}
	return err
}

type _Map_String_I32_Zapper map[string]int32

// MarshalLogObject implements zapcore.ObjectMarshaler, enabling
// fast logging of _Map_String_I32_Zapper.
func (m _Map_String_I32_Zapper) MarshalLogObject(enc zapcore.ObjectEncoder) (err error) {
	for k, v := range m {
		enc.AddInt32((string)(k), v)
	}
	return err
}

// MarshalLogObject implements zapcore.ObjectMarshaler, enabling
// fast logging of BarResponse.
func (v *BarResponse) MarshalLogObject(enc zapcore.ObjectEncoder) (err error) {
	if v == nil {
		return nil
	}
	enc.AddString("stringField", v.StringField)
	enc.AddInt32("intWithRange", v.IntWithRange)
	enc.AddInt32("intWithoutRange", v.IntWithoutRange)
	err = multierr.Append(err, enc.AddObject("mapIntWithRange", (_Map_UUID_I32_Zapper)(v.MapIntWithRange)))
	err = multierr.Append(err, enc.AddObject("mapIntWithoutRange", (_Map_String_I32_Zapper)(v.MapIntWithoutRange)))
	enc.AddString("binaryField", base64.StdEncoding.EncodeToString(v.BinaryField))
	if v.NextResponse != nil {
		err = multierr.Append(err, enc.AddObject("nextResponse", v.NextResponse))
	}
	return err
}

// GetStringField returns the value of StringField if it is set or its
// zero value if it is unset.
func (v *BarResponse) GetStringField() (o string) {
	if v != nil {
		o = v.StringField
	}
	return
}

// GetIntWithRange returns the value of IntWithRange if it is set or its
// zero value if it is unset.
func (v *BarResponse) GetIntWithRange() (o int32) {
	if v != nil {
		o = v.IntWithRange
	}
	return
}

// GetIntWithoutRange returns the value of IntWithoutRange if it is set or its
// zero value if it is unset.
func (v *BarResponse) GetIntWithoutRange() (o int32) {
	if v != nil {
		o = v.IntWithoutRange
	}
	return
}

// GetMapIntWithRange returns the value of MapIntWithRange if it is set or its
// zero value if it is unset.
func (v *BarResponse) GetMapIntWithRange() (o map[UUID]int32) {
	if v != nil {
		o = v.MapIntWithRange
	}
	return
}

// IsSetMapIntWithRange returns true if MapIntWithRange is not nil.
func (v *BarResponse) IsSetMapIntWithRange() bool {
	return v != nil && v.MapIntWithRange != nil
}

// GetMapIntWithoutRange returns the value of MapIntWithoutRange if it is set or its
// zero value if it is unset.
func (v *BarResponse) GetMapIntWithoutRange() (o map[string]int32) {
	if v != nil {
		o = v.MapIntWithoutRange
	}
	return
}

// IsSetMapIntWithoutRange returns true if MapIntWithoutRange is not nil.
func (v *BarResponse) IsSetMapIntWithoutRange() bool {
	return v != nil && v.MapIntWithoutRange != nil
}

// GetBinaryField returns the value of BinaryField if it is set or its
// zero value if it is unset.
func (v *BarResponse) GetBinaryField() (o []byte) {
	if v != nil {
		o = v.BinaryField
	}
	return
}

// IsSetBinaryField returns true if BinaryField is not nil.
func (v *BarResponse) IsSetBinaryField() bool {
	return v != nil && v.BinaryField != nil
}

// GetNextResponse returns the value of NextResponse if it is set or its
// zero value if it is unset.
func (v *BarResponse) GetNextResponse() (o *BarResponse) {
	if v != nil && v.NextResponse != nil {
		return v.NextResponse
	}

	return
}

// IsSetNextResponse returns true if NextResponse is not nil.
func (v *BarResponse) IsSetNextResponse() bool {
	return v != nil && v.NextResponse != nil
}

type DemoType int32

const (
	DemoTypeFirst  DemoType = 0
	DemoTypeSecond DemoType = 1
)

// DemoType_Values returns all recognized values of DemoType.
func DemoType_Values() []DemoType {
	return []DemoType{
		DemoTypeFirst,
		DemoTypeSecond,
	}
}

// UnmarshalText tries to decode DemoType from a byte slice
// containing its name.
//
//   var v DemoType
//   err := v.UnmarshalText([]byte("FIRST"))
func (v *DemoType) UnmarshalText(value []byte) error {
	switch s := string(value); s {
	case "FIRST":
		*v = DemoTypeFirst
		return nil
	case "SECOND":
		*v = DemoTypeSecond
		return nil
	default:
		val, err := strconv.ParseInt(s, 10, 32)
		if err != nil {
			return fmt.Errorf("unknown enum value %q for %q: %v", s, "DemoType", err)
		}
		*v = DemoType(val)
		return nil
	}
}

// MarshalText encodes DemoType to text.
//
// If the enum value is recognized, its name is returned. Otherwise,
// its integer value is returned.
//
// This implements the TextMarshaler interface.
func (v DemoType) MarshalText() ([]byte, error) {
	switch int32(v) {
	case 0:
		return []byte("FIRST"), nil
	case 1:
		return []byte("SECOND"), nil
	}
	return []byte(strconv.FormatInt(int64(v), 10)), nil
}

// MarshalLogObject implements zapcore.ObjectMarshaler, enabling
// fast logging of DemoType.
// Enums are logged as objects, where the value is logged with key "value", and
// if this value's name is known, the name is logged with key "name".
func (v DemoType) MarshalLogObject(enc zapcore.ObjectEncoder) error {
	enc.AddInt32("value", int32(v))
	switch int32(v) {
	case 0:
		enc.AddString("name", "FIRST")
	case 1:
		enc.AddString("name", "SECOND")
	}
	return nil
}

// Ptr returns a pointer to this enum value.
func (v DemoType) Ptr() *DemoType {
	return &v
}

// ToWire translates DemoType into a Thrift-level intermediate
// representation. This intermediate representation may be serialized
// into bytes using a ThriftRW protocol implementation.
//
// Enums are represented as 32-bit integers over the wire.
func (v DemoType) ToWire() (wire.Value, error) {
	return wire.NewValueI32(int32(v)), nil
}

// FromWire deserializes DemoType from its Thrift-level
// representation.
//
//   x, err := binaryProtocol.Decode(reader, wire.TI32)
//   if err != nil {
//     return DemoType(0), err
//   }
//
//   var v DemoType
//   if err := v.FromWire(x); err != nil {
//     return DemoType(0), err
//   }
//   return v, nil
func (v *DemoType) FromWire(w wire.Value) error {
	*v = (DemoType)(w.GetI32())
	return nil
}

// String returns a readable string representation of DemoType.
func (v DemoType) String() string {
	w := int32(v)
	switch w {
	case 0:
		return "FIRST"
	case 1:
		return "SECOND"
	}
	return fmt.Sprintf("DemoType(%d)", w)
}

// Equals returns true if this DemoType value matches the provided
// value.
func (v DemoType) Equals(rhs DemoType) bool {
	return v == rhs
}

// MarshalJSON serializes DemoType into JSON.
//
// If the enum value is recognized, its name is returned. Otherwise,
// its integer value is returned.
//
// This implements json.Marshaler.
func (v DemoType) MarshalJSON() ([]byte, error) {
	switch int32(v) {
	case 0:
		return ([]byte)("\"FIRST\""), nil
	case 1:
		return ([]byte)("\"SECOND\""), nil
	}
	return ([]byte)(strconv.FormatInt(int64(v), 10)), nil
}

// UnmarshalJSON attempts to decode DemoType from its JSON
// representation.
//
// This implementation supports both, numeric and string inputs. If a
// string is provided, it must be a known enum name.
//
// This implements json.Unmarshaler.
func (v *DemoType) UnmarshalJSON(text []byte) error {
	d := json.NewDecoder(bytes.NewReader(text))
	d.UseNumber()
	t, err := d.Token()
	if err != nil {
		return err
	}

	switch w := t.(type) {
	case json.Number:
		x, err := w.Int64()
		if err != nil {
			return err
		}
		if x > math.MaxInt32 {
			return fmt.Errorf("enum overflow from JSON %q for %q", text, "DemoType")
		}
		if x < math.MinInt32 {
			return fmt.Errorf("enum underflow from JSON %q for %q", text, "DemoType")
		}
		*v = (DemoType)(x)
		return nil
	case string:
		return v.UnmarshalText([]byte(w))
	default:
		return fmt.Errorf("invalid JSON value %q (%T) to unmarshal into %q", t, t, "DemoType")
	}
}

type Fruit int32

const (
	FruitApple  Fruit = 0
	FruitBanana Fruit = 1
)

// Fruit_Values returns all recognized values of Fruit.
func Fruit_Values() []Fruit {
	return []Fruit{
		FruitApple,
		FruitBanana,
	}
}

// UnmarshalText tries to decode Fruit from a byte slice
// containing its name.
//
//   var v Fruit
//   err := v.UnmarshalText([]byte("APPLE"))
func (v *Fruit) UnmarshalText(value []byte) error {
	switch s := string(value); s {
	case "APPLE":
		*v = FruitApple
		return nil
	case "BANANA":
		*v = FruitBanana
		return nil
	default:
		val, err := strconv.ParseInt(s, 10, 32)
		if err != nil {
			return fmt.Errorf("unknown enum value %q for %q: %v", s, "Fruit", err)
		}
		*v = Fruit(val)
		return nil
	}
}

// MarshalText encodes Fruit to text.
//
// If the enum value is recognized, its name is returned. Otherwise,
// its integer value is returned.
//
// This implements the TextMarshaler interface.
func (v Fruit) MarshalText() ([]byte, error) {
	switch int32(v) {
	case 0:
		return []byte("APPLE"), nil
	case 1:
		return []byte("BANANA"), nil
	}
	return []byte(strconv.FormatInt(int64(v), 10)), nil
}

// MarshalLogObject implements zapcore.ObjectMarshaler, enabling
// fast logging of Fruit.
// Enums are logged as objects, where the value is logged with key "value", and
// if this value's name is known, the name is logged with key "name".
func (v Fruit) MarshalLogObject(enc zapcore.ObjectEncoder) error {
	enc.AddInt32("value", int32(v))
	switch int32(v) {
	case 0:
		enc.AddString("name", "APPLE")
	case 1:
		enc.AddString("name", "BANANA")
	}
	return nil
}

// Ptr returns a pointer to this enum value.
func (v Fruit) Ptr() *Fruit {
	return &v
}

// ToWire translates Fruit into a Thrift-level intermediate
// representation. This intermediate representation may be serialized
// into bytes using a ThriftRW protocol implementation.
//
// Enums are represented as 32-bit integers over the wire.
func (v Fruit) ToWire() (wire.Value, error) {
	return wire.NewValueI32(int32(v)), nil
}

// FromWire deserializes Fruit from its Thrift-level
// representation.
//
//   x, err := binaryProtocol.Decode(reader, wire.TI32)
//   if err != nil {
//     return Fruit(0), err
//   }
//
//   var v Fruit
//   if err := v.FromWire(x); err != nil {
//     return Fruit(0), err
//   }
//   return v, nil
func (v *Fruit) FromWire(w wire.Value) error {
	*v = (Fruit)(w.GetI32())
	return nil
}

// String returns a readable string representation of Fruit.
func (v Fruit) String() string {
	w := int32(v)
	switch w {
	case 0:
		return "APPLE"
	case 1:
		return "BANANA"
	}
	return fmt.Sprintf("Fruit(%d)", w)
}

// Equals returns true if this Fruit value matches the provided
// value.
func (v Fruit) Equals(rhs Fruit) bool {
	return v == rhs
}

// MarshalJSON serializes Fruit into JSON.
//
// If the enum value is recognized, its name is returned. Otherwise,
// its integer value is returned.
//
// This implements json.Marshaler.
func (v Fruit) MarshalJSON() ([]byte, error) {
	switch int32(v) {
	case 0:
		return ([]byte)("\"APPLE\""), nil
	case 1:
		return ([]byte)("\"BANANA\""), nil
	}
	return ([]byte)(strconv.FormatInt(int64(v), 10)), nil
}

// UnmarshalJSON attempts to decode Fruit from its JSON
// representation.
//
// This implementation supports both, numeric and string inputs. If a
// string is provided, it must be a known enum name.
//
// This implements json.Unmarshaler.
func (v *Fruit) UnmarshalJSON(text []byte) error {
	d := json.NewDecoder(bytes.NewReader(text))
	d.UseNumber()
	t, err := d.Token()
	if err != nil {
		return err
	}

	switch w := t.(type) {
	case json.Number:
		x, err := w.Int64()
		if err != nil {
			return err
		}
		if x > math.MaxInt32 {
			return fmt.Errorf("enum overflow from JSON %q for %q", text, "Fruit")
		}
		if x < math.MinInt32 {
			return fmt.Errorf("enum underflow from JSON %q for %q", text, "Fruit")
		}
		*v = (Fruit)(x)
		return nil
	case string:
		return v.UnmarshalText([]byte(w))
	default:
		return fmt.Errorf("invalid JSON value %q (%T) to unmarshal into %q", t, t, "Fruit")
	}
}

type Long int64

// LongPtr returns a pointer to a Long
func (v Long) Ptr() *Long {
	return &v
}

// ToWire translates Long into a Thrift-level intermediate
// representation. This intermediate representation may be serialized
// into bytes using a ThriftRW protocol implementation.
func (v Long) ToWire() (wire.Value, error) {
	x := (int64)(v)
	return wire.NewValueI64(x), error(nil)
}

// String returns a readable string representation of Long.
func (v Long) String() string {
	x := (int64)(v)
	return fmt.Sprint(x)
}

// FromWire deserializes Long from its Thrift-level
// representation. The Thrift-level representation may be obtained
// from a ThriftRW protocol implementation.
func (v *Long) FromWire(w wire.Value) error {
	x, err := w.GetI64(), error(nil)
	*v = (Long)(x)
	return err
}

// Equals returns true if this Long is equal to the provided
// Long.
func (lhs Long) Equals(rhs Long) bool {
	return ((int64)(lhs) == (int64)(rhs))
}

type ParamsStruct struct {
	UserUUID string `json:"-"`
}

// ToWire translates a ParamsStruct struct into a Thrift-level intermediate
// representation. This intermediate representation may be serialized
// into bytes using a ThriftRW protocol implementation.
//
// An error is returned if the struct or any of its fields failed to
// validate.
//
//   x, err := v.ToWire()
//   if err != nil {
//     return err
//   }
//
//   if err := binaryProtocol.Encode(x, writer); err != nil {
//     return err
//   }
func (v *ParamsStruct) ToWire() (wire.Value, error) {
	var (
		fields [1]wire.Field
		i      int = 0
		w      wire.Value
		err    error
	)

	w, err = wire.NewValueString(v.UserUUID), error(nil)
	if err != nil {
		return w, err
	}
	fields[i] = wire.Field{ID: 1, Value: w}
	i++

	return wire.NewValueStruct(wire.Struct{Fields: fields[:i]}), nil
}

// FromWire deserializes a ParamsStruct struct from its Thrift-level
// representation. The Thrift-level representation may be obtained
// from a ThriftRW protocol implementation.
//
// An error is returned if we were unable to build a ParamsStruct struct
// from the provided intermediate representation.
//
//   x, err := binaryProtocol.Decode(reader, wire.TStruct)
//   if err != nil {
//     return nil, err
//   }
//
//   var v ParamsStruct
//   if err := v.FromWire(x); err != nil {
//     return nil, err
//   }
//   return &v, nil
func (v *ParamsStruct) FromWire(w wire.Value) error {
	var err error

	userUUIDIsSet := false

	for _, field := range w.GetStruct().Fields {
		switch field.ID {
		case 1:
			if field.Value.Type() == wire.TBinary {
				v.UserUUID, err = field.Value.GetString(), error(nil)
				if err != nil {
					return err
				}
				userUUIDIsSet = true
			}
		}
	}

	if !userUUIDIsSet {
		return errors.New("field UserUUID of ParamsStruct is required")
	}

	return nil
}

// String returns a readable string representation of a ParamsStruct
// struct.
func (v *ParamsStruct) String() string {
	if v == nil {
		return "<nil>"
	}

	var fields [1]string
	i := 0
	fields[i] = fmt.Sprintf("UserUUID: %v", v.UserUUID)
	i++

	return fmt.Sprintf("ParamsStruct{%v}", strings.Join(fields[:i], ", "))
}

// Equals returns true if all the fields of this ParamsStruct match the
// provided ParamsStruct.
//
// This function performs a deep comparison.
func (v *ParamsStruct) Equals(rhs *ParamsStruct) bool {
	if v == nil {
		return rhs == nil
	} else if rhs == nil {
		return false
	}
	if !(v.UserUUID == rhs.UserUUID) {
		return false
	}

	return true
}

// MarshalLogObject implements zapcore.ObjectMarshaler, enabling
// fast logging of ParamsStruct.
func (v *ParamsStruct) MarshalLogObject(enc zapcore.ObjectEncoder) (err error) {
	if v == nil {
		return nil
	}
	enc.AddString("userUUID", v.UserUUID)
	return err
}

// GetUserUUID returns the value of UserUUID if it is set or its
// zero value if it is unset.
func (v *ParamsStruct) GetUserUUID() (o string) {
	if v != nil {
		o = v.UserUUID
	}
	return
}

type QueryParamsOptsStruct struct {
	Name      string  `json:"name,required"`
	UserUUID  *string `json:"userUUID,omitempty"`
	AuthUUID  *string `json:"authUUID,omitempty"`
	AuthUUID2 *string `json:"authUUID2,omitempty"`
}

// ToWire translates a QueryParamsOptsStruct struct into a Thrift-level intermediate
// representation. This intermediate representation may be serialized
// into bytes using a ThriftRW protocol implementation.
//
// An error is returned if the struct or any of its fields failed to
// validate.
//
//   x, err := v.ToWire()
//   if err != nil {
//     return err
//   }
//
//   if err := binaryProtocol.Encode(x, writer); err != nil {
//     return err
//   }
func (v *QueryParamsOptsStruct) ToWire() (wire.Value, error) {
	var (
		fields [4]wire.Field
		i      int = 0
		w      wire.Value
		err    error
	)

	w, err = wire.NewValueString(v.Name), error(nil)
	if err != nil {
		return w, err
	}
	fields[i] = wire.Field{ID: 1, Value: w}
	i++
	if v.UserUUID != nil {
		w, err = wire.NewValueString(*(v.UserUUID)), error(nil)
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 2, Value: w}
		i++
	}
	if v.AuthUUID != nil {
		w, err = wire.NewValueString(*(v.AuthUUID)), error(nil)
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 3, Value: w}
		i++
	}
	if v.AuthUUID2 != nil {
		w, err = wire.NewValueString(*(v.AuthUUID2)), error(nil)
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 4, Value: w}
		i++
	}

	return wire.NewValueStruct(wire.Struct{Fields: fields[:i]}), nil
}

// FromWire deserializes a QueryParamsOptsStruct struct from its Thrift-level
// representation. The Thrift-level representation may be obtained
// from a ThriftRW protocol implementation.
//
// An error is returned if we were unable to build a QueryParamsOptsStruct struct
// from the provided intermediate representation.
//
//   x, err := binaryProtocol.Decode(reader, wire.TStruct)
//   if err != nil {
//     return nil, err
//   }
//
//   var v QueryParamsOptsStruct
//   if err := v.FromWire(x); err != nil {
//     return nil, err
//   }
//   return &v, nil
func (v *QueryParamsOptsStruct) FromWire(w wire.Value) error {
	var err error

	nameIsSet := false

	for _, field := range w.GetStruct().Fields {
		switch field.ID {
		case 1:
			if field.Value.Type() == wire.TBinary {
				v.Name, err = field.Value.GetString(), error(nil)
				if err != nil {
					return err
				}
				nameIsSet = true
			}
		case 2:
			if field.Value.Type() == wire.TBinary {
				var x string
				x, err = field.Value.GetString(), error(nil)
				v.UserUUID = &x
				if err != nil {
					return err
				}

			}
		case 3:
			if field.Value.Type() == wire.TBinary {
				var x string
				x, err = field.Value.GetString(), error(nil)
				v.AuthUUID = &x
				if err != nil {
					return err
				}

			}
		case 4:
			if field.Value.Type() == wire.TBinary {
				var x string
				x, err = field.Value.GetString(), error(nil)
				v.AuthUUID2 = &x
				if err != nil {
					return err
				}

			}
		}
	}

	if !nameIsSet {
		return errors.New("field Name of QueryParamsOptsStruct is required")
	}

	return nil
}

// String returns a readable string representation of a QueryParamsOptsStruct
// struct.
func (v *QueryParamsOptsStruct) String() string {
	if v == nil {
		return "<nil>"
	}

	var fields [4]string
	i := 0
	fields[i] = fmt.Sprintf("Name: %v", v.Name)
	i++
	if v.UserUUID != nil {
		fields[i] = fmt.Sprintf("UserUUID: %v", *(v.UserUUID))
		i++
	}
	if v.AuthUUID != nil {
		fields[i] = fmt.Sprintf("AuthUUID: %v", *(v.AuthUUID))
		i++
	}
	if v.AuthUUID2 != nil {
		fields[i] = fmt.Sprintf("AuthUUID2: %v", *(v.AuthUUID2))
		i++
	}

	return fmt.Sprintf("QueryParamsOptsStruct{%v}", strings.Join(fields[:i], ", "))
}

func _String_EqualsPtr(lhs, rhs *string) bool {
	if lhs != nil && rhs != nil {

		x := *lhs
		y := *rhs
		return (x == y)
	}
	return lhs == nil && rhs == nil
}

// Equals returns true if all the fields of this QueryParamsOptsStruct match the
// provided QueryParamsOptsStruct.
//
// This function performs a deep comparison.
func (v *QueryParamsOptsStruct) Equals(rhs *QueryParamsOptsStruct) bool {
	if v == nil {
		return rhs == nil
	} else if rhs == nil {
		return false
	}
	if !(v.Name == rhs.Name) {
		return false
	}
	if !_String_EqualsPtr(v.UserUUID, rhs.UserUUID) {
		return false
	}
	if !_String_EqualsPtr(v.AuthUUID, rhs.AuthUUID) {
		return false
	}
	if !_String_EqualsPtr(v.AuthUUID2, rhs.AuthUUID2) {
		return false
	}

	return true
}

// MarshalLogObject implements zapcore.ObjectMarshaler, enabling
// fast logging of QueryParamsOptsStruct.
func (v *QueryParamsOptsStruct) MarshalLogObject(enc zapcore.ObjectEncoder) (err error) {
	if v == nil {
		return nil
	}
	enc.AddString("name", v.Name)
	if v.UserUUID != nil {
		enc.AddString("userUUID", *v.UserUUID)
	}
	if v.AuthUUID != nil {
		enc.AddString("authUUID", *v.AuthUUID)
	}
	if v.AuthUUID2 != nil {
		enc.AddString("authUUID2", *v.AuthUUID2)
	}
	return err
}

// GetName returns the value of Name if it is set or its
// zero value if it is unset.
func (v *QueryParamsOptsStruct) GetName() (o string) {
	if v != nil {
		o = v.Name
	}
	return
}

// GetUserUUID returns the value of UserUUID if it is set or its
// zero value if it is unset.
func (v *QueryParamsOptsStruct) GetUserUUID() (o string) {
	if v != nil && v.UserUUID != nil {
		return *v.UserUUID
	}

	return
}

// IsSetUserUUID returns true if UserUUID is not nil.
func (v *QueryParamsOptsStruct) IsSetUserUUID() bool {
	return v != nil && v.UserUUID != nil
}

// GetAuthUUID returns the value of AuthUUID if it is set or its
// zero value if it is unset.
func (v *QueryParamsOptsStruct) GetAuthUUID() (o string) {
	if v != nil && v.AuthUUID != nil {
		return *v.AuthUUID
	}

	return
}

// IsSetAuthUUID returns true if AuthUUID is not nil.
func (v *QueryParamsOptsStruct) IsSetAuthUUID() bool {
	return v != nil && v.AuthUUID != nil
}

// GetAuthUUID2 returns the value of AuthUUID2 if it is set or its
// zero value if it is unset.
func (v *QueryParamsOptsStruct) GetAuthUUID2() (o string) {
	if v != nil && v.AuthUUID2 != nil {
		return *v.AuthUUID2
	}

	return
}

// IsSetAuthUUID2 returns true if AuthUUID2 is not nil.
func (v *QueryParamsOptsStruct) IsSetAuthUUID2() bool {
	return v != nil && v.AuthUUID2 != nil
}

type QueryParamsStruct struct {
	Name      string   `json:"name,required"`
	UserUUID  *string  `json:"userUUID,omitempty"`
	AuthUUID  *string  `json:"authUUID,omitempty"`
	AuthUUID2 *string  `json:"authUUID2,omitempty"`
	Foo       []string `json:"foo,required"`
}

type _List_String_ValueList []string

func (v _List_String_ValueList) ForEach(f func(wire.Value) error) error {
	for _, x := range v {
		w, err := wire.NewValueString(x), error(nil)
		if err != nil {
			return err
		}
		err = f(w)
		if err != nil {
			return err
		}
	}
	return nil
}

func (v _List_String_ValueList) Size() int {
	return len(v)
}

func (_List_String_ValueList) ValueType() wire.Type {
	return wire.TBinary
}

func (_List_String_ValueList) Close() {}

// ToWire translates a QueryParamsStruct struct into a Thrift-level intermediate
// representation. This intermediate representation may be serialized
// into bytes using a ThriftRW protocol implementation.
//
// An error is returned if the struct or any of its fields failed to
// validate.
//
//   x, err := v.ToWire()
//   if err != nil {
//     return err
//   }
//
//   if err := binaryProtocol.Encode(x, writer); err != nil {
//     return err
//   }
func (v *QueryParamsStruct) ToWire() (wire.Value, error) {
	var (
		fields [5]wire.Field
		i      int = 0
		w      wire.Value
		err    error
	)

	w, err = wire.NewValueString(v.Name), error(nil)
	if err != nil {
		return w, err
	}
	fields[i] = wire.Field{ID: 1, Value: w}
	i++
	if v.UserUUID != nil {
		w, err = wire.NewValueString(*(v.UserUUID)), error(nil)
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 2, Value: w}
		i++
	}
	if v.AuthUUID != nil {
		w, err = wire.NewValueString(*(v.AuthUUID)), error(nil)
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 3, Value: w}
		i++
	}
	if v.AuthUUID2 != nil {
		w, err = wire.NewValueString(*(v.AuthUUID2)), error(nil)
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 4, Value: w}
		i++
	}
	if v.Foo == nil {
		return w, errors.New("field Foo of QueryParamsStruct is required")
	}
	w, err = wire.NewValueList(_List_String_ValueList(v.Foo)), error(nil)
	if err != nil {
		return w, err
	}
	fields[i] = wire.Field{ID: 5, Value: w}
	i++

	return wire.NewValueStruct(wire.Struct{Fields: fields[:i]}), nil
}

func _List_String_Read(l wire.ValueList) ([]string, error) {
	if l.ValueType() != wire.TBinary {
		return nil, nil
	}

	o := make([]string, 0, l.Size())
	err := l.ForEach(func(x wire.Value) error {
		i, err := x.GetString(), error(nil)
		if err != nil {
			return err
		}
		o = append(o, i)
		return nil
	})
	l.Close()
	return o, err
}

// FromWire deserializes a QueryParamsStruct struct from its Thrift-level
// representation. The Thrift-level representation may be obtained
// from a ThriftRW protocol implementation.
//
// An error is returned if we were unable to build a QueryParamsStruct struct
// from the provided intermediate representation.
//
//   x, err := binaryProtocol.Decode(reader, wire.TStruct)
//   if err != nil {
//     return nil, err
//   }
//
//   var v QueryParamsStruct
//   if err := v.FromWire(x); err != nil {
//     return nil, err
//   }
//   return &v, nil
func (v *QueryParamsStruct) FromWire(w wire.Value) error {
	var err error

	nameIsSet := false

	fooIsSet := false

	for _, field := range w.GetStruct().Fields {
		switch field.ID {
		case 1:
			if field.Value.Type() == wire.TBinary {
				v.Name, err = field.Value.GetString(), error(nil)
				if err != nil {
					return err
				}
				nameIsSet = true
			}
		case 2:
			if field.Value.Type() == wire.TBinary {
				var x string
				x, err = field.Value.GetString(), error(nil)
				v.UserUUID = &x
				if err != nil {
					return err
				}

			}
		case 3:
			if field.Value.Type() == wire.TBinary {
				var x string
				x, err = field.Value.GetString(), error(nil)
				v.AuthUUID = &x
				if err != nil {
					return err
				}

			}
		case 4:
			if field.Value.Type() == wire.TBinary {
				var x string
				x, err = field.Value.GetString(), error(nil)
				v.AuthUUID2 = &x
				if err != nil {
					return err
				}

			}
		case 5:
			if field.Value.Type() == wire.TList {
				v.Foo, err = _List_String_Read(field.Value.GetList())
				if err != nil {
					return err
				}
				fooIsSet = true
			}
		}
	}

	if !nameIsSet {
		return errors.New("field Name of QueryParamsStruct is required")
	}

	if !fooIsSet {
		return errors.New("field Foo of QueryParamsStruct is required")
	}

	return nil
}

// String returns a readable string representation of a QueryParamsStruct
// struct.
func (v *QueryParamsStruct) String() string {
	if v == nil {
		return "<nil>"
	}

	var fields [5]string
	i := 0
	fields[i] = fmt.Sprintf("Name: %v", v.Name)
	i++
	if v.UserUUID != nil {
		fields[i] = fmt.Sprintf("UserUUID: %v", *(v.UserUUID))
		i++
	}
	if v.AuthUUID != nil {
		fields[i] = fmt.Sprintf("AuthUUID: %v", *(v.AuthUUID))
		i++
	}
	if v.AuthUUID2 != nil {
		fields[i] = fmt.Sprintf("AuthUUID2: %v", *(v.AuthUUID2))
		i++
	}
	fields[i] = fmt.Sprintf("Foo: %v", v.Foo)
	i++

	return fmt.Sprintf("QueryParamsStruct{%v}", strings.Join(fields[:i], ", "))
}

func _List_String_Equals(lhs, rhs []string) bool {
	if len(lhs) != len(rhs) {
		return false
	}

	for i, lv := range lhs {
		rv := rhs[i]
		if !(lv == rv) {
			return false
		}
	}

	return true
}

// Equals returns true if all the fields of this QueryParamsStruct match the
// provided QueryParamsStruct.
//
// This function performs a deep comparison.
func (v *QueryParamsStruct) Equals(rhs *QueryParamsStruct) bool {
	if v == nil {
		return rhs == nil
	} else if rhs == nil {
		return false
	}
	if !(v.Name == rhs.Name) {
		return false
	}
	if !_String_EqualsPtr(v.UserUUID, rhs.UserUUID) {
		return false
	}
	if !_String_EqualsPtr(v.AuthUUID, rhs.AuthUUID) {
		return false
	}
	if !_String_EqualsPtr(v.AuthUUID2, rhs.AuthUUID2) {
		return false
	}
	if !_List_String_Equals(v.Foo, rhs.Foo) {
		return false
	}

	return true
}

type _List_String_Zapper []string

// MarshalLogArray implements zapcore.ArrayMarshaler, enabling
// fast logging of _List_String_Zapper.
func (l _List_String_Zapper) MarshalLogArray(enc zapcore.ArrayEncoder) (err error) {
	for _, v := range l {
		enc.AppendString(v)
	}
	return err
}

// MarshalLogObject implements zapcore.ObjectMarshaler, enabling
// fast logging of QueryParamsStruct.
func (v *QueryParamsStruct) MarshalLogObject(enc zapcore.ObjectEncoder) (err error) {
	if v == nil {
		return nil
	}
	enc.AddString("name", v.Name)
	if v.UserUUID != nil {
		enc.AddString("userUUID", *v.UserUUID)
	}
	if v.AuthUUID != nil {
		enc.AddString("authUUID", *v.AuthUUID)
	}
	if v.AuthUUID2 != nil {
		enc.AddString("authUUID2", *v.AuthUUID2)
	}
	err = multierr.Append(err, enc.AddArray("foo", (_List_String_Zapper)(v.Foo)))
	return err
}

// GetName returns the value of Name if it is set or its
// zero value if it is unset.
func (v *QueryParamsStruct) GetName() (o string) {
	if v != nil {
		o = v.Name
	}
	return
}

// GetUserUUID returns the value of UserUUID if it is set or its
// zero value if it is unset.
func (v *QueryParamsStruct) GetUserUUID() (o string) {
	if v != nil && v.UserUUID != nil {
		return *v.UserUUID
	}

	return
}

// IsSetUserUUID returns true if UserUUID is not nil.
func (v *QueryParamsStruct) IsSetUserUUID() bool {
	return v != nil && v.UserUUID != nil
}

// GetAuthUUID returns the value of AuthUUID if it is set or its
// zero value if it is unset.
func (v *QueryParamsStruct) GetAuthUUID() (o string) {
	if v != nil && v.AuthUUID != nil {
		return *v.AuthUUID
	}

	return
}

// IsSetAuthUUID returns true if AuthUUID is not nil.
func (v *QueryParamsStruct) IsSetAuthUUID() bool {
	return v != nil && v.AuthUUID != nil
}

// GetAuthUUID2 returns the value of AuthUUID2 if it is set or its
// zero value if it is unset.
func (v *QueryParamsStruct) GetAuthUUID2() (o string) {
	if v != nil && v.AuthUUID2 != nil {
		return *v.AuthUUID2
	}

	return
}

// IsSetAuthUUID2 returns true if AuthUUID2 is not nil.
func (v *QueryParamsStruct) IsSetAuthUUID2() bool {
	return v != nil && v.AuthUUID2 != nil
}

// GetFoo returns the value of Foo if it is set or its
// zero value if it is unset.
func (v *QueryParamsStruct) GetFoo() (o []string) {
	if v != nil {
		o = v.Foo
	}
	return
}

// IsSetFoo returns true if Foo is not nil.
func (v *QueryParamsStruct) IsSetFoo() bool {
	return v != nil && v.Foo != nil
}

type RequestWithDuplicateType struct {
	Request1 *BarRequest `json:"request1,omitempty"`
	Request2 *BarRequest `json:"request2,omitempty"`
}

// ToWire translates a RequestWithDuplicateType struct into a Thrift-level intermediate
// representation. This intermediate representation may be serialized
// into bytes using a ThriftRW protocol implementation.
//
// An error is returned if the struct or any of its fields failed to
// validate.
//
//   x, err := v.ToWire()
//   if err != nil {
//     return err
//   }
//
//   if err := binaryProtocol.Encode(x, writer); err != nil {
//     return err
//   }
func (v *RequestWithDuplicateType) ToWire() (wire.Value, error) {
	var (
		fields [2]wire.Field
		i      int = 0
		w      wire.Value
		err    error
	)

	if v.Request1 != nil {
		w, err = v.Request1.ToWire()
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 1, Value: w}
		i++
	}
	if v.Request2 != nil {
		w, err = v.Request2.ToWire()
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 2, Value: w}
		i++
	}

	return wire.NewValueStruct(wire.Struct{Fields: fields[:i]}), nil
}

func _BarRequest_Read(w wire.Value) (*BarRequest, error) {
	var v BarRequest
	err := v.FromWire(w)
	return &v, err
}

// FromWire deserializes a RequestWithDuplicateType struct from its Thrift-level
// representation. The Thrift-level representation may be obtained
// from a ThriftRW protocol implementation.
//
// An error is returned if we were unable to build a RequestWithDuplicateType struct
// from the provided intermediate representation.
//
//   x, err := binaryProtocol.Decode(reader, wire.TStruct)
//   if err != nil {
//     return nil, err
//   }
//
//   var v RequestWithDuplicateType
//   if err := v.FromWire(x); err != nil {
//     return nil, err
//   }
//   return &v, nil
func (v *RequestWithDuplicateType) FromWire(w wire.Value) error {
	var err error

	for _, field := range w.GetStruct().Fields {
		switch field.ID {
		case 1:
			if field.Value.Type() == wire.TStruct {
				v.Request1, err = _BarRequest_Read(field.Value)
				if err != nil {
					return err
				}

			}
		case 2:
			if field.Value.Type() == wire.TStruct {
				v.Request2, err = _BarRequest_Read(field.Value)
				if err != nil {
					return err
				}

			}
		}
	}

	return nil
}

// String returns a readable string representation of a RequestWithDuplicateType
// struct.
func (v *RequestWithDuplicateType) String() string {
	if v == nil {
		return "<nil>"
	}

	var fields [2]string
	i := 0
	if v.Request1 != nil {
		fields[i] = fmt.Sprintf("Request1: %v", v.Request1)
		i++
	}
	if v.Request2 != nil {
		fields[i] = fmt.Sprintf("Request2: %v", v.Request2)
		i++
	}

	return fmt.Sprintf("RequestWithDuplicateType{%v}", strings.Join(fields[:i], ", "))
}

// Equals returns true if all the fields of this RequestWithDuplicateType match the
// provided RequestWithDuplicateType.
//
// This function performs a deep comparison.
func (v *RequestWithDuplicateType) Equals(rhs *RequestWithDuplicateType) bool {
	if v == nil {
		return rhs == nil
	} else if rhs == nil {
		return false
	}
	if !((v.Request1 == nil && rhs.Request1 == nil) || (v.Request1 != nil && rhs.Request1 != nil && v.Request1.Equals(rhs.Request1))) {
		return false
	}
	if !((v.Request2 == nil && rhs.Request2 == nil) || (v.Request2 != nil && rhs.Request2 != nil && v.Request2.Equals(rhs.Request2))) {
		return false
	}

	return true
}

// MarshalLogObject implements zapcore.ObjectMarshaler, enabling
// fast logging of RequestWithDuplicateType.
func (v *RequestWithDuplicateType) MarshalLogObject(enc zapcore.ObjectEncoder) (err error) {
	if v == nil {
		return nil
	}
	if v.Request1 != nil {
		err = multierr.Append(err, enc.AddObject("request1", v.Request1))
	}
	if v.Request2 != nil {
		err = multierr.Append(err, enc.AddObject("request2", v.Request2))
	}
	return err
}

// GetRequest1 returns the value of Request1 if it is set or its
// zero value if it is unset.
func (v *RequestWithDuplicateType) GetRequest1() (o *BarRequest) {
	if v != nil && v.Request1 != nil {
		return v.Request1
	}

	return
}

// IsSetRequest1 returns true if Request1 is not nil.
func (v *RequestWithDuplicateType) IsSetRequest1() bool {
	return v != nil && v.Request1 != nil
}

// GetRequest2 returns the value of Request2 if it is set or its
// zero value if it is unset.
func (v *RequestWithDuplicateType) GetRequest2() (o *BarRequest) {
	if v != nil && v.Request2 != nil {
		return v.Request2
	}

	return
}

// IsSetRequest2 returns true if Request2 is not nil.
func (v *RequestWithDuplicateType) IsSetRequest2() bool {
	return v != nil && v.Request2 != nil
}

type StringList []string

// ToWire translates StringList into a Thrift-level intermediate
// representation. This intermediate representation may be serialized
// into bytes using a ThriftRW protocol implementation.
func (v StringList) ToWire() (wire.Value, error) {
	x := ([]string)(v)
	return wire.NewValueList(_List_String_ValueList(x)), error(nil)
}

// String returns a readable string representation of StringList.
func (v StringList) String() string {
	x := ([]string)(v)
	return fmt.Sprint(x)
}

// FromWire deserializes StringList from its Thrift-level
// representation. The Thrift-level representation may be obtained
// from a ThriftRW protocol implementation.
func (v *StringList) FromWire(w wire.Value) error {
	x, err := _List_String_Read(w.GetList())
	*v = (StringList)(x)
	return err
}

// Equals returns true if this StringList is equal to the provided
// StringList.
func (lhs StringList) Equals(rhs StringList) bool {
	return _List_String_Equals(([]string)(lhs), ([]string)(rhs))
}

func (v StringList) MarshalLogArray(enc zapcore.ArrayEncoder) error {
	return ((_List_String_Zapper)(([]string)(v))).MarshalLogArray(enc)
}

type Timestamp int64

// TimestampPtr returns a pointer to a Timestamp
func (v Timestamp) Ptr() *Timestamp {
	return &v
}

// ToWire translates Timestamp into a Thrift-level intermediate
// representation. This intermediate representation may be serialized
// into bytes using a ThriftRW protocol implementation.
func (v Timestamp) ToWire() (wire.Value, error) {
	x := (int64)(v)
	return wire.NewValueI64(x), error(nil)
}

// String returns a readable string representation of Timestamp.
func (v Timestamp) String() string {
	x := (int64)(v)
	return fmt.Sprint(x)
}

// FromWire deserializes Timestamp from its Thrift-level
// representation. The Thrift-level representation may be obtained
// from a ThriftRW protocol implementation.
func (v *Timestamp) FromWire(w wire.Value) error {
	x, err := w.GetI64(), error(nil)
	*v = (Timestamp)(x)
	return err
}

// Equals returns true if this Timestamp is equal to the provided
// Timestamp.
func (lhs Timestamp) Equals(rhs Timestamp) bool {
	return ((int64)(lhs) == (int64)(rhs))
}

type UUID string

// UUIDPtr returns a pointer to a UUID
func (v UUID) Ptr() *UUID {
	return &v
}

// ToWire translates UUID into a Thrift-level intermediate
// representation. This intermediate representation may be serialized
// into bytes using a ThriftRW protocol implementation.
func (v UUID) ToWire() (wire.Value, error) {
	x := (string)(v)
	return wire.NewValueString(x), error(nil)
}

// String returns a readable string representation of UUID.
func (v UUID) String() string {
	x := (string)(v)
	return fmt.Sprint(x)
}

// FromWire deserializes UUID from its Thrift-level
// representation. The Thrift-level representation may be obtained
// from a ThriftRW protocol implementation.
func (v *UUID) FromWire(w wire.Value) error {
	x, err := w.GetString(), error(nil)
	*v = (UUID)(x)
	return err
}

// Equals returns true if this UUID is equal to the provided
// UUID.
func (lhs UUID) Equals(rhs UUID) bool {
	return ((string)(lhs) == (string)(rhs))
}

type _List_UUID_ValueList []UUID

func (v _List_UUID_ValueList) ForEach(f func(wire.Value) error) error {
	for _, x := range v {
		w, err := x.ToWire()
		if err != nil {
			return err
		}
		err = f(w)
		if err != nil {
			return err
		}
	}
	return nil
}

func (v _List_UUID_ValueList) Size() int {
	return len(v)
}

func (_List_UUID_ValueList) ValueType() wire.Type {
	return wire.TBinary
}

func (_List_UUID_ValueList) Close() {}

func _List_UUID_Read(l wire.ValueList) ([]UUID, error) {
	if l.ValueType() != wire.TBinary {
		return nil, nil
	}

	o := make([]UUID, 0, l.Size())
	err := l.ForEach(func(x wire.Value) error {
		i, err := _UUID_Read(x)
		if err != nil {
			return err
		}
		o = append(o, i)
		return nil
	})
	l.Close()
	return o, err
}

func _List_UUID_Equals(lhs, rhs []UUID) bool {
	if len(lhs) != len(rhs) {
		return false
	}

	for i, lv := range lhs {
		rv := rhs[i]
		if !(lv == rv) {
			return false
		}
	}

	return true
}

type _List_UUID_Zapper []UUID

// MarshalLogArray implements zapcore.ArrayMarshaler, enabling
// fast logging of _List_UUID_Zapper.
func (l _List_UUID_Zapper) MarshalLogArray(enc zapcore.ArrayEncoder) (err error) {
	for _, v := range l {
		enc.AppendString((string)(v))
	}
	return err
}

type UUIDList []UUID

// ToWire translates UUIDList into a Thrift-level intermediate
// representation. This intermediate representation may be serialized
// into bytes using a ThriftRW protocol implementation.
func (v UUIDList) ToWire() (wire.Value, error) {
	x := ([]UUID)(v)
	return wire.NewValueList(_List_UUID_ValueList(x)), error(nil)
}

// String returns a readable string representation of UUIDList.
func (v UUIDList) String() string {
	x := ([]UUID)(v)
	return fmt.Sprint(x)
}

// FromWire deserializes UUIDList from its Thrift-level
// representation. The Thrift-level representation may be obtained
// from a ThriftRW protocol implementation.
func (v *UUIDList) FromWire(w wire.Value) error {
	x, err := _List_UUID_Read(w.GetList())
	*v = (UUIDList)(x)
	return err
}

// Equals returns true if this UUIDList is equal to the provided
// UUIDList.
func (lhs UUIDList) Equals(rhs UUIDList) bool {
	return _List_UUID_Equals(([]UUID)(lhs), ([]UUID)(rhs))
}

func (v UUIDList) MarshalLogArray(enc zapcore.ArrayEncoder) error {
	return ((_List_UUID_Zapper)(([]UUID)(v))).MarshalLogArray(enc)
}

// Bar_ArgNotStruct_Args represents the arguments for the Bar.argNotStruct function.
//
// The arguments for argNotStruct are sent and received over the wire as this struct.
type Bar_ArgNotStruct_Args struct {
	Request string `json:"request,required"`
}

// ToWire translates a Bar_ArgNotStruct_Args struct into a Thrift-level intermediate
// representation. This intermediate representation may be serialized
// into bytes using a ThriftRW protocol implementation.
//
// An error is returned if the struct or any of its fields failed to
// validate.
//
//   x, err := v.ToWire()
//   if err != nil {
//     return err
//   }
//
//   if err := binaryProtocol.Encode(x, writer); err != nil {
//     return err
//   }
func (v *Bar_ArgNotStruct_Args) ToWire() (wire.Value, error) {
	var (
		fields [1]wire.Field
		i      int = 0
		w      wire.Value
		err    error
	)

	w, err = wire.NewValueString(v.Request), error(nil)
	if err != nil {
		return w, err
	}
	fields[i] = wire.Field{ID: 1, Value: w}
	i++

	return wire.NewValueStruct(wire.Struct{Fields: fields[:i]}), nil
}

// FromWire deserializes a Bar_ArgNotStruct_Args struct from its Thrift-level
// representation. The Thrift-level representation may be obtained
// from a ThriftRW protocol implementation.
//
// An error is returned if we were unable to build a Bar_ArgNotStruct_Args struct
// from the provided intermediate representation.
//
//   x, err := binaryProtocol.Decode(reader, wire.TStruct)
//   if err != nil {
//     return nil, err
//   }
//
//   var v Bar_ArgNotStruct_Args
//   if err := v.FromWire(x); err != nil {
//     return nil, err
//   }
//   return &v, nil
func (v *Bar_ArgNotStruct_Args) FromWire(w wire.Value) error {
	var err error

	requestIsSet := false

	for _, field := range w.GetStruct().Fields {
		switch field.ID {
		case 1:
			if field.Value.Type() == wire.TBinary {
				v.Request, err = field.Value.GetString(), error(nil)
				if err != nil {
					return err
				}
				requestIsSet = true
			}
		}
	}

	if !requestIsSet {
		return errors.New("field Request of Bar_ArgNotStruct_Args is required")
	}

	return nil
}

// String returns a readable string representation of a Bar_ArgNotStruct_Args
// struct.
func (v *Bar_ArgNotStruct_Args) String() string {
	if v == nil {
		return "<nil>"
	}

	var fields [1]string
	i := 0
	fields[i] = fmt.Sprintf("Request: %v", v.Request)
	i++

	return fmt.Sprintf("Bar_ArgNotStruct_Args{%v}", strings.Join(fields[:i], ", "))
}

// Equals returns true if all the fields of this Bar_ArgNotStruct_Args match the
// provided Bar_ArgNotStruct_Args.
//
// This function performs a deep comparison.
func (v *Bar_ArgNotStruct_Args) Equals(rhs *Bar_ArgNotStruct_Args) bool {
	if v == nil {
		return rhs == nil
	} else if rhs == nil {
		return false
	}
	if !(v.Request == rhs.Request) {
		return false
	}

	return true
}

// MarshalLogObject implements zapcore.ObjectMarshaler, enabling
// fast logging of Bar_ArgNotStruct_Args.
func (v *Bar_ArgNotStruct_Args) MarshalLogObject(enc zapcore.ObjectEncoder) (err error) {
	if v == nil {
		return nil
	}
	enc.AddString("request", v.Request)
	return err
}

// GetRequest returns the value of Request if it is set or its
// zero value if it is unset.
func (v *Bar_ArgNotStruct_Args) GetRequest() (o string) {
	if v != nil {
		o = v.Request
	}
	return
}

// MethodName returns the name of the Thrift function as specified in
// the IDL, for which this struct represent the arguments.
//
// This will always be "argNotStruct" for this struct.
func (v *Bar_ArgNotStruct_Args) MethodName() string {
	return "argNotStruct"
}

// EnvelopeType returns the kind of value inside this struct.
//
// This will always be Call for this struct.
func (v *Bar_ArgNotStruct_Args) EnvelopeType() wire.EnvelopeType {
	return wire.Call
}

// Bar_ArgNotStruct_Helper provides functions that aid in handling the
// parameters and return values of the Bar.argNotStruct
// function.
var Bar_ArgNotStruct_Helper = struct {
	// Args accepts the parameters of argNotStruct in-order and returns
	// the arguments struct for the function.
	Args func(
		request string,
	) *Bar_ArgNotStruct_Args

	// IsException returns true if the given error can be thrown
	// by argNotStruct.
	//
	// An error can be thrown by argNotStruct only if the
	// corresponding exception type was mentioned in the 'throws'
	// section for it in the Thrift file.
	IsException func(error) bool

	// WrapResponse returns the result struct for argNotStruct
	// given the error returned by it. The provided error may
	// be nil if argNotStruct did not fail.
	//
	// This allows mapping errors returned by argNotStruct into a
	// serializable result struct. WrapResponse returns a
	// non-nil error if the provided error cannot be thrown by
	// argNotStruct
	//
	//   err := argNotStruct(args)
	//   result, err := Bar_ArgNotStruct_Helper.WrapResponse(err)
	//   if err != nil {
	//     return fmt.Errorf("unexpected error from argNotStruct: %v", err)
	//   }
	//   serialize(result)
	WrapResponse func(error) (*Bar_ArgNotStruct_Result, error)

	// UnwrapResponse takes the result struct for argNotStruct
	// and returns the erorr returned by it (if any).
	//
	// The error is non-nil only if argNotStruct threw an
	// exception.
	//
	//   result := deserialize(bytes)
	//   err := Bar_ArgNotStruct_Helper.UnwrapResponse(result)
	UnwrapResponse func(*Bar_ArgNotStruct_Result) error
}{}

func init() {
	Bar_ArgNotStruct_Helper.Args = func(
		request string,
	) *Bar_ArgNotStruct_Args {
		return &Bar_ArgNotStruct_Args{
			Request: request,
		}
	}

	Bar_ArgNotStruct_Helper.IsException = func(err error) bool {
		switch err.(type) {
		case *BarException:
			return true
		default:
			return false
		}
	}

	Bar_ArgNotStruct_Helper.WrapResponse = func(err error) (*Bar_ArgNotStruct_Result, error) {
		if err == nil {
			return &Bar_ArgNotStruct_Result{}, nil
		}

		switch e := err.(type) {
		case *BarException:
			if e == nil {
				return nil, errors.New("WrapResponse received non-nil error type with nil value for Bar_ArgNotStruct_Result.BarException")
			}
			return &Bar_ArgNotStruct_Result{BarException: e}, nil
		}

		return nil, err
	}
	Bar_ArgNotStruct_Helper.UnwrapResponse = func(result *Bar_ArgNotStruct_Result) (err error) {
		if result.BarException != nil {
			err = result.BarException
			return
		}
		return
	}

}

// Bar_ArgNotStruct_Result represents the result of a Bar.argNotStruct function call.
//
// The result of a argNotStruct execution is sent and received over the wire as this struct.
type Bar_ArgNotStruct_Result struct {
	BarException *BarException `json:"barException,omitempty"`
}

// ToWire translates a Bar_ArgNotStruct_Result struct into a Thrift-level intermediate
// representation. This intermediate representation may be serialized
// into bytes using a ThriftRW protocol implementation.
//
// An error is returned if the struct or any of its fields failed to
// validate.
//
//   x, err := v.ToWire()
//   if err != nil {
//     return err
//   }
//
//   if err := binaryProtocol.Encode(x, writer); err != nil {
//     return err
//   }
func (v *Bar_ArgNotStruct_Result) ToWire() (wire.Value, error) {
	var (
		fields [1]wire.Field
		i      int = 0
		w      wire.Value
		err    error
	)

	if v.BarException != nil {
		w, err = v.BarException.ToWire()
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 1, Value: w}
		i++
	}

	if i > 1 {
		return wire.Value{}, fmt.Errorf("Bar_ArgNotStruct_Result should have at most one field: got %v fields", i)
	}

	return wire.NewValueStruct(wire.Struct{Fields: fields[:i]}), nil
}

func _BarException_Read(w wire.Value) (*BarException, error) {
	var v BarException
	err := v.FromWire(w)
	return &v, err
}

// FromWire deserializes a Bar_ArgNotStruct_Result struct from its Thrift-level
// representation. The Thrift-level representation may be obtained
// from a ThriftRW protocol implementation.
//
// An error is returned if we were unable to build a Bar_ArgNotStruct_Result struct
// from the provided intermediate representation.
//
//   x, err := binaryProtocol.Decode(reader, wire.TStruct)
//   if err != nil {
//     return nil, err
//   }
//
//   var v Bar_ArgNotStruct_Result
//   if err := v.FromWire(x); err != nil {
//     return nil, err
//   }
//   return &v, nil
func (v *Bar_ArgNotStruct_Result) FromWire(w wire.Value) error {
	var err error

	for _, field := range w.GetStruct().Fields {
		switch field.ID {
		case 1:
			if field.Value.Type() == wire.TStruct {
				v.BarException, err = _BarException_Read(field.Value)
				if err != nil {
					return err
				}

			}
		}
	}

	count := 0
	if v.BarException != nil {
		count++
	}
	if count > 1 {
		return fmt.Errorf("Bar_ArgNotStruct_Result should have at most one field: got %v fields", count)
	}

	return nil
}

// String returns a readable string representation of a Bar_ArgNotStruct_Result
// struct.
func (v *Bar_ArgNotStruct_Result) String() string {
	if v == nil {
		return "<nil>"
	}

	var fields [1]string
	i := 0
	if v.BarException != nil {
		fields[i] = fmt.Sprintf("BarException: %v", v.BarException)
		i++
	}

	return fmt.Sprintf("Bar_ArgNotStruct_Result{%v}", strings.Join(fields[:i], ", "))
}

// Equals returns true if all the fields of this Bar_ArgNotStruct_Result match the
// provided Bar_ArgNotStruct_Result.
//
// This function performs a deep comparison.
func (v *Bar_ArgNotStruct_Result) Equals(rhs *Bar_ArgNotStruct_Result) bool {
	if v == nil {
		return rhs == nil
	} else if rhs == nil {
		return false
	}
	if !((v.BarException == nil && rhs.BarException == nil) || (v.BarException != nil && rhs.BarException != nil && v.BarException.Equals(rhs.BarException))) {
		return false
	}

	return true
}

// MarshalLogObject implements zapcore.ObjectMarshaler, enabling
// fast logging of Bar_ArgNotStruct_Result.
func (v *Bar_ArgNotStruct_Result) MarshalLogObject(enc zapcore.ObjectEncoder) (err error) {
	if v == nil {
		return nil
	}
	if v.BarException != nil {
		err = multierr.Append(err, enc.AddObject("barException", v.BarException))
	}
	return err
}

// GetBarException returns the value of BarException if it is set or its
// zero value if it is unset.
func (v *Bar_ArgNotStruct_Result) GetBarException() (o *BarException) {
	if v != nil && v.BarException != nil {
		return v.BarException
	}

	return
}

// IsSetBarException returns true if BarException is not nil.
func (v *Bar_ArgNotStruct_Result) IsSetBarException() bool {
	return v != nil && v.BarException != nil
}

// MethodName returns the name of the Thrift function as specified in
// the IDL, for which this struct represent the result.
//
// This will always be "argNotStruct" for this struct.
func (v *Bar_ArgNotStruct_Result) MethodName() string {
	return "argNotStruct"
}

// EnvelopeType returns the kind of value inside this struct.
//
// This will always be Reply for this struct.
func (v *Bar_ArgNotStruct_Result) EnvelopeType() wire.EnvelopeType {
	return wire.Reply
}

// Bar_ArgWithHeaders_Args represents the arguments for the Bar.argWithHeaders function.
//
// The arguments for argWithHeaders are sent and received over the wire as this struct.
type Bar_ArgWithHeaders_Args struct {
	Name     string  `json:"name,required"`
	UserUUID *string `json:"-"`
}

// ToWire translates a Bar_ArgWithHeaders_Args struct into a Thrift-level intermediate
// representation. This intermediate representation may be serialized
// into bytes using a ThriftRW protocol implementation.
//
// An error is returned if the struct or any of its fields failed to
// validate.
//
//   x, err := v.ToWire()
//   if err != nil {
//     return err
//   }
//
//   if err := binaryProtocol.Encode(x, writer); err != nil {
//     return err
//   }
func (v *Bar_ArgWithHeaders_Args) ToWire() (wire.Value, error) {
	var (
		fields [2]wire.Field
		i      int = 0
		w      wire.Value
		err    error
	)

	w, err = wire.NewValueString(v.Name), error(nil)
	if err != nil {
		return w, err
	}
	fields[i] = wire.Field{ID: 1, Value: w}
	i++
	if v.UserUUID != nil {
		w, err = wire.NewValueString(*(v.UserUUID)), error(nil)
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 2, Value: w}
		i++
	}

	return wire.NewValueStruct(wire.Struct{Fields: fields[:i]}), nil
}

// FromWire deserializes a Bar_ArgWithHeaders_Args struct from its Thrift-level
// representation. The Thrift-level representation may be obtained
// from a ThriftRW protocol implementation.
//
// An error is returned if we were unable to build a Bar_ArgWithHeaders_Args struct
// from the provided intermediate representation.
//
//   x, err := binaryProtocol.Decode(reader, wire.TStruct)
//   if err != nil {
//     return nil, err
//   }
//
//   var v Bar_ArgWithHeaders_Args
//   if err := v.FromWire(x); err != nil {
//     return nil, err
//   }
//   return &v, nil
func (v *Bar_ArgWithHeaders_Args) FromWire(w wire.Value) error {
	var err error

	nameIsSet := false

	for _, field := range w.GetStruct().Fields {
		switch field.ID {
		case 1:
			if field.Value.Type() == wire.TBinary {
				v.Name, err = field.Value.GetString(), error(nil)
				if err != nil {
					return err
				}
				nameIsSet = true
			}
		case 2:
			if field.Value.Type() == wire.TBinary {
				var x string
				x, err = field.Value.GetString(), error(nil)
				v.UserUUID = &x
				if err != nil {
					return err
				}

			}
		}
	}

	if !nameIsSet {
		return errors.New("field Name of Bar_ArgWithHeaders_Args is required")
	}

	return nil
}

// String returns a readable string representation of a Bar_ArgWithHeaders_Args
// struct.
func (v *Bar_ArgWithHeaders_Args) String() string {
	if v == nil {
		return "<nil>"
	}

	var fields [2]string
	i := 0
	fields[i] = fmt.Sprintf("Name: %v", v.Name)
	i++
	if v.UserUUID != nil {
		fields[i] = fmt.Sprintf("UserUUID: %v", *(v.UserUUID))
		i++
	}

	return fmt.Sprintf("Bar_ArgWithHeaders_Args{%v}", strings.Join(fields[:i], ", "))
}

// Equals returns true if all the fields of this Bar_ArgWithHeaders_Args match the
// provided Bar_ArgWithHeaders_Args.
//
// This function performs a deep comparison.
func (v *Bar_ArgWithHeaders_Args) Equals(rhs *Bar_ArgWithHeaders_Args) bool {
	if v == nil {
		return rhs == nil
	} else if rhs == nil {
		return false
	}
	if !(v.Name == rhs.Name) {
		return false
	}
	if !_String_EqualsPtr(v.UserUUID, rhs.UserUUID) {
		return false
	}

	return true
}

// MarshalLogObject implements zapcore.ObjectMarshaler, enabling
// fast logging of Bar_ArgWithHeaders_Args.
func (v *Bar_ArgWithHeaders_Args) MarshalLogObject(enc zapcore.ObjectEncoder) (err error) {
	if v == nil {
		return nil
	}
	enc.AddString("name", v.Name)
	if v.UserUUID != nil {
		enc.AddString("userUUID", *v.UserUUID)
	}
	return err
}

// GetName returns the value of Name if it is set or its
// zero value if it is unset.
func (v *Bar_ArgWithHeaders_Args) GetName() (o string) {
	if v != nil {
		o = v.Name
	}
	return
}

// GetUserUUID returns the value of UserUUID if it is set or its
// zero value if it is unset.
func (v *Bar_ArgWithHeaders_Args) GetUserUUID() (o string) {
	if v != nil && v.UserUUID != nil {
		return *v.UserUUID
	}

	return
}

// IsSetUserUUID returns true if UserUUID is not nil.
func (v *Bar_ArgWithHeaders_Args) IsSetUserUUID() bool {
	return v != nil && v.UserUUID != nil
}

// MethodName returns the name of the Thrift function as specified in
// the IDL, for which this struct represent the arguments.
//
// This will always be "argWithHeaders" for this struct.
func (v *Bar_ArgWithHeaders_Args) MethodName() string {
	return "argWithHeaders"
}

// EnvelopeType returns the kind of value inside this struct.
//
// This will always be Call for this struct.
func (v *Bar_ArgWithHeaders_Args) EnvelopeType() wire.EnvelopeType {
	return wire.Call
}

// Bar_ArgWithHeaders_Helper provides functions that aid in handling the
// parameters and return values of the Bar.argWithHeaders
// function.
var Bar_ArgWithHeaders_Helper = struct {
	// Args accepts the parameters of argWithHeaders in-order and returns
	// the arguments struct for the function.
	Args func(
		name string,
		userUUID *string,
	) *Bar_ArgWithHeaders_Args

	// IsException returns true if the given error can be thrown
	// by argWithHeaders.
	//
	// An error can be thrown by argWithHeaders only if the
	// corresponding exception type was mentioned in the 'throws'
	// section for it in the Thrift file.
	IsException func(error) bool

	// WrapResponse returns the result struct for argWithHeaders
	// given its return value and error.
	//
	// This allows mapping values and errors returned by
	// argWithHeaders into a serializable result struct.
	// WrapResponse returns a non-nil error if the provided
	// error cannot be thrown by argWithHeaders
	//
	//   value, err := argWithHeaders(args)
	//   result, err := Bar_ArgWithHeaders_Helper.WrapResponse(value, err)
	//   if err != nil {
	//     return fmt.Errorf("unexpected error from argWithHeaders: %v", err)
	//   }
	//   serialize(result)
	WrapResponse func(*BarResponse, error) (*Bar_ArgWithHeaders_Result, error)

	// UnwrapResponse takes the result struct for argWithHeaders
	// and returns the value or error returned by it.
	//
	// The error is non-nil only if argWithHeaders threw an
	// exception.
	//
	//   result := deserialize(bytes)
	//   value, err := Bar_ArgWithHeaders_Helper.UnwrapResponse(result)
	UnwrapResponse func(*Bar_ArgWithHeaders_Result) (*BarResponse, error)
}{}

func init() {
	Bar_ArgWithHeaders_Helper.Args = func(
		name string,
		userUUID *string,
	) *Bar_ArgWithHeaders_Args {
		return &Bar_ArgWithHeaders_Args{
			Name:     name,
			UserUUID: userUUID,
		}
	}

	Bar_ArgWithHeaders_Helper.IsException = func(err error) bool {
		switch err.(type) {
		default:
			return false
		}
	}

	Bar_ArgWithHeaders_Helper.WrapResponse = func(success *BarResponse, err error) (*Bar_ArgWithHeaders_Result, error) {
		if err == nil {
			return &Bar_ArgWithHeaders_Result{Success: success}, nil
		}

		return nil, err
	}
	Bar_ArgWithHeaders_Helper.UnwrapResponse = func(result *Bar_ArgWithHeaders_Result) (success *BarResponse, err error) {

		if result.Success != nil {
			success = result.Success
			return
		}

		err = errors.New("expected a non-void result")
		return
	}

}

// Bar_ArgWithHeaders_Result represents the result of a Bar.argWithHeaders function call.
//
// The result of a argWithHeaders execution is sent and received over the wire as this struct.
//
// Success is set only if the function did not throw an exception.
type Bar_ArgWithHeaders_Result struct {
	// Value returned by argWithHeaders after a successful execution.
	Success *BarResponse `json:"success,omitempty"`
}

// ToWire translates a Bar_ArgWithHeaders_Result struct into a Thrift-level intermediate
// representation. This intermediate representation may be serialized
// into bytes using a ThriftRW protocol implementation.
//
// An error is returned if the struct or any of its fields failed to
// validate.
//
//   x, err := v.ToWire()
//   if err != nil {
//     return err
//   }
//
//   if err := binaryProtocol.Encode(x, writer); err != nil {
//     return err
//   }
func (v *Bar_ArgWithHeaders_Result) ToWire() (wire.Value, error) {
	var (
		fields [1]wire.Field
		i      int = 0
		w      wire.Value
		err    error
	)

	if v.Success != nil {
		w, err = v.Success.ToWire()
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 0, Value: w}
		i++
	}

	if i != 1 {
		return wire.Value{}, fmt.Errorf("Bar_ArgWithHeaders_Result should have exactly one field: got %v fields", i)
	}

	return wire.NewValueStruct(wire.Struct{Fields: fields[:i]}), nil
}

// FromWire deserializes a Bar_ArgWithHeaders_Result struct from its Thrift-level
// representation. The Thrift-level representation may be obtained
// from a ThriftRW protocol implementation.
//
// An error is returned if we were unable to build a Bar_ArgWithHeaders_Result struct
// from the provided intermediate representation.
//
//   x, err := binaryProtocol.Decode(reader, wire.TStruct)
//   if err != nil {
//     return nil, err
//   }
//
//   var v Bar_ArgWithHeaders_Result
//   if err := v.FromWire(x); err != nil {
//     return nil, err
//   }
//   return &v, nil
func (v *Bar_ArgWithHeaders_Result) FromWire(w wire.Value) error {
	var err error

	for _, field := range w.GetStruct().Fields {
		switch field.ID {
		case 0:
			if field.Value.Type() == wire.TStruct {
				v.Success, err = _BarResponse_Read(field.Value)
				if err != nil {
					return err
				}

			}
		}
	}

	count := 0
	if v.Success != nil {
		count++
	}
	if count != 1 {
		return fmt.Errorf("Bar_ArgWithHeaders_Result should have exactly one field: got %v fields", count)
	}

	return nil
}

// String returns a readable string representation of a Bar_ArgWithHeaders_Result
// struct.
func (v *Bar_ArgWithHeaders_Result) String() string {
	if v == nil {
		return "<nil>"
	}

	var fields [1]string
	i := 0
	if v.Success != nil {
		fields[i] = fmt.Sprintf("Success: %v", v.Success)
		i++
	}

	return fmt.Sprintf("Bar_ArgWithHeaders_Result{%v}", strings.Join(fields[:i], ", "))
}

// Equals returns true if all the fields of this Bar_ArgWithHeaders_Result match the
// provided Bar_ArgWithHeaders_Result.
//
// This function performs a deep comparison.
func (v *Bar_ArgWithHeaders_Result) Equals(rhs *Bar_ArgWithHeaders_Result) bool {
	if v == nil {
		return rhs == nil
	} else if rhs == nil {
		return false
	}
	if !((v.Success == nil && rhs.Success == nil) || (v.Success != nil && rhs.Success != nil && v.Success.Equals(rhs.Success))) {
		return false
	}

	return true
}

// MarshalLogObject implements zapcore.ObjectMarshaler, enabling
// fast logging of Bar_ArgWithHeaders_Result.
func (v *Bar_ArgWithHeaders_Result) MarshalLogObject(enc zapcore.ObjectEncoder) (err error) {
	if v == nil {
		return nil
	}
	if v.Success != nil {
		err = multierr.Append(err, enc.AddObject("success", v.Success))
	}
	return err
}

// GetSuccess returns the value of Success if it is set or its
// zero value if it is unset.
func (v *Bar_ArgWithHeaders_Result) GetSuccess() (o *BarResponse) {
	if v != nil && v.Success != nil {
		return v.Success
	}

	return
}

// IsSetSuccess returns true if Success is not nil.
func (v *Bar_ArgWithHeaders_Result) IsSetSuccess() bool {
	return v != nil && v.Success != nil
}

// MethodName returns the name of the Thrift function as specified in
// the IDL, for which this struct represent the result.
//
// This will always be "argWithHeaders" for this struct.
func (v *Bar_ArgWithHeaders_Result) MethodName() string {
	return "argWithHeaders"
}

// EnvelopeType returns the kind of value inside this struct.
//
// This will always be Reply for this struct.
func (v *Bar_ArgWithHeaders_Result) EnvelopeType() wire.EnvelopeType {
	return wire.Reply
}

// Bar_ArgWithManyQueryParams_Args represents the arguments for the Bar.argWithManyQueryParams function.
//
// The arguments for argWithManyQueryParams are sent and received over the wire as this struct.
type Bar_ArgWithManyQueryParams_Args struct {
	AStr            string     `json:"aStr,required"`
	AnOptStr        *string    `json:"anOptStr,omitempty"`
	ABool           bool       `json:"aBool,required"`
	AnOptBool       *bool      `json:"anOptBool,omitempty"`
	AInt8           int8       `json:"aInt8,required"`
	AnOptInt8       *int8      `json:"anOptInt8,omitempty"`
	AInt16          int16      `json:"aInt16,required"`
	AnOptInt16      *int16     `json:"anOptInt16,omitempty"`
	AInt32          int32      `json:"aInt32,required"`
	AnOptInt32      *int32     `json:"anOptInt32,omitempty"`
	AInt64          int64      `json:"aInt64,required"`
	AnOptInt64      *int64     `json:"anOptInt64,omitempty"`
	AFloat64        float64    `json:"aFloat64,required"`
	AnOptFloat64    *float64   `json:"anOptFloat64,omitempty"`
	AUUID           UUID       `json:"aUUID,required"`
	AnOptUUID       *UUID      `json:"anOptUUID,omitempty"`
	AListUUID       []UUID     `json:"aListUUID,required"`
	AnOptListUUID   []UUID     `json:"anOptListUUID,omitempty"`
	AStringList     StringList `json:"aStringList,required"`
	AnOptStringList StringList `json:"anOptStringList,omitempty"`
	AUUIDList       UUIDList   `json:"aUUIDList,required"`
	AnOptUUIDList   UUIDList   `json:"anOptUUIDList,omitempty"`
	ATs             Timestamp  `json:"aTs,required"`
	AnOptTs         *Timestamp `json:"anOptTs,omitempty"`
	AReqDemo        DemoType   `json:"aReqDemo,required"`
	AnOptFruit      *Fruit     `json:"anOptFruit,omitempty"`
	AReqFruits      []Fruit    `json:"aReqFruits,required"`
	AnOptDemos      []DemoType `json:"anOptDemos,omitempty"`
}

type _List_Fruit_ValueList []Fruit

func (v _List_Fruit_ValueList) ForEach(f func(wire.Value) error) error {
	for _, x := range v {
		w, err := x.ToWire()
		if err != nil {
			return err
		}
		err = f(w)
		if err != nil {
			return err
		}
	}
	return nil
}

func (v _List_Fruit_ValueList) Size() int {
	return len(v)
}

func (_List_Fruit_ValueList) ValueType() wire.Type {
	return wire.TI32
}

func (_List_Fruit_ValueList) Close() {}

type _List_DemoType_ValueList []DemoType

func (v _List_DemoType_ValueList) ForEach(f func(wire.Value) error) error {
	for _, x := range v {
		w, err := x.ToWire()
		if err != nil {
			return err
		}
		err = f(w)
		if err != nil {
			return err
		}
	}
	return nil
}

func (v _List_DemoType_ValueList) Size() int {
	return len(v)
}

func (_List_DemoType_ValueList) ValueType() wire.Type {
	return wire.TI32
}

func (_List_DemoType_ValueList) Close() {}

// ToWire translates a Bar_ArgWithManyQueryParams_Args struct into a Thrift-level intermediate
// representation. This intermediate representation may be serialized
// into bytes using a ThriftRW protocol implementation.
//
// An error is returned if the struct or any of its fields failed to
// validate.
//
//   x, err := v.ToWire()
//   if err != nil {
//     return err
//   }
//
//   if err := binaryProtocol.Encode(x, writer); err != nil {
//     return err
//   }
func (v *Bar_ArgWithManyQueryParams_Args) ToWire() (wire.Value, error) {
	var (
		fields [28]wire.Field
		i      int = 0
		w      wire.Value
		err    error
	)

	w, err = wire.NewValueString(v.AStr), error(nil)
	if err != nil {
		return w, err
	}
	fields[i] = wire.Field{ID: 1, Value: w}
	i++
	if v.AnOptStr != nil {
		w, err = wire.NewValueString(*(v.AnOptStr)), error(nil)
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 2, Value: w}
		i++
	}

	w, err = wire.NewValueBool(v.ABool), error(nil)
	if err != nil {
		return w, err
	}
	fields[i] = wire.Field{ID: 3, Value: w}
	i++
	if v.AnOptBool != nil {
		w, err = wire.NewValueBool(*(v.AnOptBool)), error(nil)
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 4, Value: w}
		i++
	}

	w, err = wire.NewValueI8(v.AInt8), error(nil)
	if err != nil {
		return w, err
	}
	fields[i] = wire.Field{ID: 5, Value: w}
	i++
	if v.AnOptInt8 != nil {
		w, err = wire.NewValueI8(*(v.AnOptInt8)), error(nil)
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 6, Value: w}
		i++
	}

	w, err = wire.NewValueI16(v.AInt16), error(nil)
	if err != nil {
		return w, err
	}
	fields[i] = wire.Field{ID: 7, Value: w}
	i++
	if v.AnOptInt16 != nil {
		w, err = wire.NewValueI16(*(v.AnOptInt16)), error(nil)
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 8, Value: w}
		i++
	}

	w, err = wire.NewValueI32(v.AInt32), error(nil)
	if err != nil {
		return w, err
	}
	fields[i] = wire.Field{ID: 9, Value: w}
	i++
	if v.AnOptInt32 != nil {
		w, err = wire.NewValueI32(*(v.AnOptInt32)), error(nil)
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 10, Value: w}
		i++
	}

	w, err = wire.NewValueI64(v.AInt64), error(nil)
	if err != nil {
		return w, err
	}
	fields[i] = wire.Field{ID: 11, Value: w}
	i++
	if v.AnOptInt64 != nil {
		w, err = wire.NewValueI64(*(v.AnOptInt64)), error(nil)
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 12, Value: w}
		i++
	}

	w, err = wire.NewValueDouble(v.AFloat64), error(nil)
	if err != nil {
		return w, err
	}
	fields[i] = wire.Field{ID: 13, Value: w}
	i++
	if v.AnOptFloat64 != nil {
		w, err = wire.NewValueDouble(*(v.AnOptFloat64)), error(nil)
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 14, Value: w}
		i++
	}

	w, err = v.AUUID.ToWire()
	if err != nil {
		return w, err
	}
	fields[i] = wire.Field{ID: 15, Value: w}
	i++
	if v.AnOptUUID != nil {
		w, err = v.AnOptUUID.ToWire()
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 16, Value: w}
		i++
	}
	if v.AListUUID == nil {
		return w, errors.New("field AListUUID of Bar_ArgWithManyQueryParams_Args is required")
	}
	w, err = wire.NewValueList(_List_UUID_ValueList(v.AListUUID)), error(nil)
	if err != nil {
		return w, err
	}
	fields[i] = wire.Field{ID: 17, Value: w}
	i++
	if v.AnOptListUUID != nil {
		w, err = wire.NewValueList(_List_UUID_ValueList(v.AnOptListUUID)), error(nil)
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 18, Value: w}
		i++
	}
	if v.AStringList == nil {
		return w, errors.New("field AStringList of Bar_ArgWithManyQueryParams_Args is required")
	}
	w, err = v.AStringList.ToWire()
	if err != nil {
		return w, err
	}
	fields[i] = wire.Field{ID: 19, Value: w}
	i++
	if v.AnOptStringList != nil {
		w, err = v.AnOptStringList.ToWire()
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 20, Value: w}
		i++
	}
	if v.AUUIDList == nil {
		return w, errors.New("field AUUIDList of Bar_ArgWithManyQueryParams_Args is required")
	}
	w, err = v.AUUIDList.ToWire()
	if err != nil {
		return w, err
	}
	fields[i] = wire.Field{ID: 21, Value: w}
	i++
	if v.AnOptUUIDList != nil {
		w, err = v.AnOptUUIDList.ToWire()
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 22, Value: w}
		i++
	}

	w, err = v.ATs.ToWire()
	if err != nil {
		return w, err
	}
	fields[i] = wire.Field{ID: 23, Value: w}
	i++
	if v.AnOptTs != nil {
		w, err = v.AnOptTs.ToWire()
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 24, Value: w}
		i++
	}

	w, err = v.AReqDemo.ToWire()
	if err != nil {
		return w, err
	}
	fields[i] = wire.Field{ID: 25, Value: w}
	i++
	if v.AnOptFruit != nil {
		w, err = v.AnOptFruit.ToWire()
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 26, Value: w}
		i++
	}
	if v.AReqFruits == nil {
		return w, errors.New("field AReqFruits of Bar_ArgWithManyQueryParams_Args is required")
	}
	w, err = wire.NewValueList(_List_Fruit_ValueList(v.AReqFruits)), error(nil)
	if err != nil {
		return w, err
	}
	fields[i] = wire.Field{ID: 27, Value: w}
	i++
	if v.AnOptDemos != nil {
		w, err = wire.NewValueList(_List_DemoType_ValueList(v.AnOptDemos)), error(nil)
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 28, Value: w}
		i++
	}

	return wire.NewValueStruct(wire.Struct{Fields: fields[:i]}), nil
}

func _StringList_Read(w wire.Value) (StringList, error) {
	var x StringList
	err := x.FromWire(w)
	return x, err
}

func _UUIDList_Read(w wire.Value) (UUIDList, error) {
	var x UUIDList
	err := x.FromWire(w)
	return x, err
}

func _DemoType_Read(w wire.Value) (DemoType, error) {
	var v DemoType
	err := v.FromWire(w)
	return v, err
}

func _List_Fruit_Read(l wire.ValueList) ([]Fruit, error) {
	if l.ValueType() != wire.TI32 {
		return nil, nil
	}

	o := make([]Fruit, 0, l.Size())
	err := l.ForEach(func(x wire.Value) error {
		i, err := _Fruit_Read(x)
		if err != nil {
			return err
		}
		o = append(o, i)
		return nil
	})
	l.Close()
	return o, err
}

func _List_DemoType_Read(l wire.ValueList) ([]DemoType, error) {
	if l.ValueType() != wire.TI32 {
		return nil, nil
	}

	o := make([]DemoType, 0, l.Size())
	err := l.ForEach(func(x wire.Value) error {
		i, err := _DemoType_Read(x)
		if err != nil {
			return err
		}
		o = append(o, i)
		return nil
	})
	l.Close()
	return o, err
}

// FromWire deserializes a Bar_ArgWithManyQueryParams_Args struct from its Thrift-level
// representation. The Thrift-level representation may be obtained
// from a ThriftRW protocol implementation.
//
// An error is returned if we were unable to build a Bar_ArgWithManyQueryParams_Args struct
// from the provided intermediate representation.
//
//   x, err := binaryProtocol.Decode(reader, wire.TStruct)
//   if err != nil {
//     return nil, err
//   }
//
//   var v Bar_ArgWithManyQueryParams_Args
//   if err := v.FromWire(x); err != nil {
//     return nil, err
//   }
//   return &v, nil
func (v *Bar_ArgWithManyQueryParams_Args) FromWire(w wire.Value) error {
	var err error

	aStrIsSet := false

	aBoolIsSet := false

	aInt8IsSet := false

	aInt16IsSet := false

	aInt32IsSet := false

	aInt64IsSet := false

	aFloat64IsSet := false

	aUUIDIsSet := false

	aListUUIDIsSet := false

	aStringListIsSet := false

	aUUIDListIsSet := false

	aTsIsSet := false

	aReqDemoIsSet := false

	aReqFruitsIsSet := false

	for _, field := range w.GetStruct().Fields {
		switch field.ID {
		case 1:
			if field.Value.Type() == wire.TBinary {
				v.AStr, err = field.Value.GetString(), error(nil)
				if err != nil {
					return err
				}
				aStrIsSet = true
			}
		case 2:
			if field.Value.Type() == wire.TBinary {
				var x string
				x, err = field.Value.GetString(), error(nil)
				v.AnOptStr = &x
				if err != nil {
					return err
				}

			}
		case 3:
			if field.Value.Type() == wire.TBool {
				v.ABool, err = field.Value.GetBool(), error(nil)
				if err != nil {
					return err
				}
				aBoolIsSet = true
			}
		case 4:
			if field.Value.Type() == wire.TBool {
				var x bool
				x, err = field.Value.GetBool(), error(nil)
				v.AnOptBool = &x
				if err != nil {
					return err
				}

			}
		case 5:
			if field.Value.Type() == wire.TI8 {
				v.AInt8, err = field.Value.GetI8(), error(nil)
				if err != nil {
					return err
				}
				aInt8IsSet = true
			}
		case 6:
			if field.Value.Type() == wire.TI8 {
				var x int8
				x, err = field.Value.GetI8(), error(nil)
				v.AnOptInt8 = &x
				if err != nil {
					return err
				}

			}
		case 7:
			if field.Value.Type() == wire.TI16 {
				v.AInt16, err = field.Value.GetI16(), error(nil)
				if err != nil {
					return err
				}
				aInt16IsSet = true
			}
		case 8:
			if field.Value.Type() == wire.TI16 {
				var x int16
				x, err = field.Value.GetI16(), error(nil)
				v.AnOptInt16 = &x
				if err != nil {
					return err
				}

			}
		case 9:
			if field.Value.Type() == wire.TI32 {
				v.AInt32, err = field.Value.GetI32(), error(nil)
				if err != nil {
					return err
				}
				aInt32IsSet = true
			}
		case 10:
			if field.Value.Type() == wire.TI32 {
				var x int32
				x, err = field.Value.GetI32(), error(nil)
				v.AnOptInt32 = &x
				if err != nil {
					return err
				}

			}
		case 11:
			if field.Value.Type() == wire.TI64 {
				v.AInt64, err = field.Value.GetI64(), error(nil)
				if err != nil {
					return err
				}
				aInt64IsSet = true
			}
		case 12:
			if field.Value.Type() == wire.TI64 {
				var x int64
				x, err = field.Value.GetI64(), error(nil)
				v.AnOptInt64 = &x
				if err != nil {
					return err
				}

			}
		case 13:
			if field.Value.Type() == wire.TDouble {
				v.AFloat64, err = field.Value.GetDouble(), error(nil)
				if err != nil {
					return err
				}
				aFloat64IsSet = true
			}
		case 14:
			if field.Value.Type() == wire.TDouble {
				var x float64
				x, err = field.Value.GetDouble(), error(nil)
				v.AnOptFloat64 = &x
				if err != nil {
					return err
				}

			}
		case 15:
			if field.Value.Type() == wire.TBinary {
				v.AUUID, err = _UUID_Read(field.Value)
				if err != nil {
					return err
				}
				aUUIDIsSet = true
			}
		case 16:
			if field.Value.Type() == wire.TBinary {
				var x UUID
				x, err = _UUID_Read(field.Value)
				v.AnOptUUID = &x
				if err != nil {
					return err
				}

			}
		case 17:
			if field.Value.Type() == wire.TList {
				v.AListUUID, err = _List_UUID_Read(field.Value.GetList())
				if err != nil {
					return err
				}
				aListUUIDIsSet = true
			}
		case 18:
			if field.Value.Type() == wire.TList {
				v.AnOptListUUID, err = _List_UUID_Read(field.Value.GetList())
				if err != nil {
					return err
				}

			}
		case 19:
			if field.Value.Type() == wire.TList {
				v.AStringList, err = _StringList_Read(field.Value)
				if err != nil {
					return err
				}
				aStringListIsSet = true
			}
		case 20:
			if field.Value.Type() == wire.TList {
				v.AnOptStringList, err = _StringList_Read(field.Value)
				if err != nil {
					return err
				}

			}
		case 21:
			if field.Value.Type() == wire.TList {
				v.AUUIDList, err = _UUIDList_Read(field.Value)
				if err != nil {
					return err
				}
				aUUIDListIsSet = true
			}
		case 22:
			if field.Value.Type() == wire.TList {
				v.AnOptUUIDList, err = _UUIDList_Read(field.Value)
				if err != nil {
					return err
				}

			}
		case 23:
			if field.Value.Type() == wire.TI64 {
				v.ATs, err = _Timestamp_Read(field.Value)
				if err != nil {
					return err
				}
				aTsIsSet = true
			}
		case 24:
			if field.Value.Type() == wire.TI64 {
				var x Timestamp
				x, err = _Timestamp_Read(field.Value)
				v.AnOptTs = &x
				if err != nil {
					return err
				}

			}
		case 25:
			if field.Value.Type() == wire.TI32 {
				v.AReqDemo, err = _DemoType_Read(field.Value)
				if err != nil {
					return err
				}
				aReqDemoIsSet = true
			}
		case 26:
			if field.Value.Type() == wire.TI32 {
				var x Fruit
				x, err = _Fruit_Read(field.Value)
				v.AnOptFruit = &x
				if err != nil {
					return err
				}

			}
		case 27:
			if field.Value.Type() == wire.TList {
				v.AReqFruits, err = _List_Fruit_Read(field.Value.GetList())
				if err != nil {
					return err
				}
				aReqFruitsIsSet = true
			}
		case 28:
			if field.Value.Type() == wire.TList {
				v.AnOptDemos, err = _List_DemoType_Read(field.Value.GetList())
				if err != nil {
					return err
				}

			}
		}
	}

	if !aStrIsSet {
		return errors.New("field AStr of Bar_ArgWithManyQueryParams_Args is required")
	}

	if !aBoolIsSet {
		return errors.New("field ABool of Bar_ArgWithManyQueryParams_Args is required")
	}

	if !aInt8IsSet {
		return errors.New("field AInt8 of Bar_ArgWithManyQueryParams_Args is required")
	}

	if !aInt16IsSet {
		return errors.New("field AInt16 of Bar_ArgWithManyQueryParams_Args is required")
	}

	if !aInt32IsSet {
		return errors.New("field AInt32 of Bar_ArgWithManyQueryParams_Args is required")
	}

	if !aInt64IsSet {
		return errors.New("field AInt64 of Bar_ArgWithManyQueryParams_Args is required")
	}

	if !aFloat64IsSet {
		return errors.New("field AFloat64 of Bar_ArgWithManyQueryParams_Args is required")
	}

	if !aUUIDIsSet {
		return errors.New("field AUUID of Bar_ArgWithManyQueryParams_Args is required")
	}

	if !aListUUIDIsSet {
		return errors.New("field AListUUID of Bar_ArgWithManyQueryParams_Args is required")
	}

	if !aStringListIsSet {
		return errors.New("field AStringList of Bar_ArgWithManyQueryParams_Args is required")
	}

	if !aUUIDListIsSet {
		return errors.New("field AUUIDList of Bar_ArgWithManyQueryParams_Args is required")
	}

	if !aTsIsSet {
		return errors.New("field ATs of Bar_ArgWithManyQueryParams_Args is required")
	}

	if !aReqDemoIsSet {
		return errors.New("field AReqDemo of Bar_ArgWithManyQueryParams_Args is required")
	}

	if !aReqFruitsIsSet {
		return errors.New("field AReqFruits of Bar_ArgWithManyQueryParams_Args is required")
	}

	return nil
}

// String returns a readable string representation of a Bar_ArgWithManyQueryParams_Args
// struct.
func (v *Bar_ArgWithManyQueryParams_Args) String() string {
	if v == nil {
		return "<nil>"
	}

	var fields [28]string
	i := 0
	fields[i] = fmt.Sprintf("AStr: %v", v.AStr)
	i++
	if v.AnOptStr != nil {
		fields[i] = fmt.Sprintf("AnOptStr: %v", *(v.AnOptStr))
		i++
	}
	fields[i] = fmt.Sprintf("ABool: %v", v.ABool)
	i++
	if v.AnOptBool != nil {
		fields[i] = fmt.Sprintf("AnOptBool: %v", *(v.AnOptBool))
		i++
	}
	fields[i] = fmt.Sprintf("AInt8: %v", v.AInt8)
	i++
	if v.AnOptInt8 != nil {
		fields[i] = fmt.Sprintf("AnOptInt8: %v", *(v.AnOptInt8))
		i++
	}
	fields[i] = fmt.Sprintf("AInt16: %v", v.AInt16)
	i++
	if v.AnOptInt16 != nil {
		fields[i] = fmt.Sprintf("AnOptInt16: %v", *(v.AnOptInt16))
		i++
	}
	fields[i] = fmt.Sprintf("AInt32: %v", v.AInt32)
	i++
	if v.AnOptInt32 != nil {
		fields[i] = fmt.Sprintf("AnOptInt32: %v", *(v.AnOptInt32))
		i++
	}
	fields[i] = fmt.Sprintf("AInt64: %v", v.AInt64)
	i++
	if v.AnOptInt64 != nil {
		fields[i] = fmt.Sprintf("AnOptInt64: %v", *(v.AnOptInt64))
		i++
	}
	fields[i] = fmt.Sprintf("AFloat64: %v", v.AFloat64)
	i++
	if v.AnOptFloat64 != nil {
		fields[i] = fmt.Sprintf("AnOptFloat64: %v", *(v.AnOptFloat64))
		i++
	}
	fields[i] = fmt.Sprintf("AUUID: %v", v.AUUID)
	i++
	if v.AnOptUUID != nil {
		fields[i] = fmt.Sprintf("AnOptUUID: %v", *(v.AnOptUUID))
		i++
	}
	fields[i] = fmt.Sprintf("AListUUID: %v", v.AListUUID)
	i++
	if v.AnOptListUUID != nil {
		fields[i] = fmt.Sprintf("AnOptListUUID: %v", v.AnOptListUUID)
		i++
	}
	fields[i] = fmt.Sprintf("AStringList: %v", v.AStringList)
	i++
	if v.AnOptStringList != nil {
		fields[i] = fmt.Sprintf("AnOptStringList: %v", v.AnOptStringList)
		i++
	}
	fields[i] = fmt.Sprintf("AUUIDList: %v", v.AUUIDList)
	i++
	if v.AnOptUUIDList != nil {
		fields[i] = fmt.Sprintf("AnOptUUIDList: %v", v.AnOptUUIDList)
		i++
	}
	fields[i] = fmt.Sprintf("ATs: %v", v.ATs)
	i++
	if v.AnOptTs != nil {
		fields[i] = fmt.Sprintf("AnOptTs: %v", *(v.AnOptTs))
		i++
	}
	fields[i] = fmt.Sprintf("AReqDemo: %v", v.AReqDemo)
	i++
	if v.AnOptFruit != nil {
		fields[i] = fmt.Sprintf("AnOptFruit: %v", *(v.AnOptFruit))
		i++
	}
	fields[i] = fmt.Sprintf("AReqFruits: %v", v.AReqFruits)
	i++
	if v.AnOptDemos != nil {
		fields[i] = fmt.Sprintf("AnOptDemos: %v", v.AnOptDemos)
		i++
	}

	return fmt.Sprintf("Bar_ArgWithManyQueryParams_Args{%v}", strings.Join(fields[:i], ", "))
}

func _Bool_EqualsPtr(lhs, rhs *bool) bool {
	if lhs != nil && rhs != nil {

		x := *lhs
		y := *rhs
		return (x == y)
	}
	return lhs == nil && rhs == nil
}

func _Byte_EqualsPtr(lhs, rhs *int8) bool {
	if lhs != nil && rhs != nil {

		x := *lhs
		y := *rhs
		return (x == y)
	}
	return lhs == nil && rhs == nil
}

func _I16_EqualsPtr(lhs, rhs *int16) bool {
	if lhs != nil && rhs != nil {

		x := *lhs
		y := *rhs
		return (x == y)
	}
	return lhs == nil && rhs == nil
}

func _I32_EqualsPtr(lhs, rhs *int32) bool {
	if lhs != nil && rhs != nil {

		x := *lhs
		y := *rhs
		return (x == y)
	}
	return lhs == nil && rhs == nil
}

func _I64_EqualsPtr(lhs, rhs *int64) bool {
	if lhs != nil && rhs != nil {

		x := *lhs
		y := *rhs
		return (x == y)
	}
	return lhs == nil && rhs == nil
}

func _Double_EqualsPtr(lhs, rhs *float64) bool {
	if lhs != nil && rhs != nil {

		x := *lhs
		y := *rhs
		return (x == y)
	}
	return lhs == nil && rhs == nil
}

func _UUID_EqualsPtr(lhs, rhs *UUID) bool {
	if lhs != nil && rhs != nil {

		x := *lhs
		y := *rhs
		return (x == y)
	}
	return lhs == nil && rhs == nil
}

func _Timestamp_EqualsPtr(lhs, rhs *Timestamp) bool {
	if lhs != nil && rhs != nil {

		x := *lhs
		y := *rhs
		return (x == y)
	}
	return lhs == nil && rhs == nil
}

func _Fruit_EqualsPtr(lhs, rhs *Fruit) bool {
	if lhs != nil && rhs != nil {

		x := *lhs
		y := *rhs
		return x.Equals(y)
	}
	return lhs == nil && rhs == nil
}

func _List_Fruit_Equals(lhs, rhs []Fruit) bool {
	if len(lhs) != len(rhs) {
		return false
	}

	for i, lv := range lhs {
		rv := rhs[i]
		if !lv.Equals(rv) {
			return false
		}
	}

	return true
}

func _List_DemoType_Equals(lhs, rhs []DemoType) bool {
	if len(lhs) != len(rhs) {
		return false
	}

	for i, lv := range lhs {
		rv := rhs[i]
		if !lv.Equals(rv) {
			return false
		}
	}

	return true
}

// Equals returns true if all the fields of this Bar_ArgWithManyQueryParams_Args match the
// provided Bar_ArgWithManyQueryParams_Args.
//
// This function performs a deep comparison.
func (v *Bar_ArgWithManyQueryParams_Args) Equals(rhs *Bar_ArgWithManyQueryParams_Args) bool {
	if v == nil {
		return rhs == nil
	} else if rhs == nil {
		return false
	}
	if !(v.AStr == rhs.AStr) {
		return false
	}
	if !_String_EqualsPtr(v.AnOptStr, rhs.AnOptStr) {
		return false
	}
	if !(v.ABool == rhs.ABool) {
		return false
	}
	if !_Bool_EqualsPtr(v.AnOptBool, rhs.AnOptBool) {
		return false
	}
	if !(v.AInt8 == rhs.AInt8) {
		return false
	}
	if !_Byte_EqualsPtr(v.AnOptInt8, rhs.AnOptInt8) {
		return false
	}
	if !(v.AInt16 == rhs.AInt16) {
		return false
	}
	if !_I16_EqualsPtr(v.AnOptInt16, rhs.AnOptInt16) {
		return false
	}
	if !(v.AInt32 == rhs.AInt32) {
		return false
	}
	if !_I32_EqualsPtr(v.AnOptInt32, rhs.AnOptInt32) {
		return false
	}
	if !(v.AInt64 == rhs.AInt64) {
		return false
	}
	if !_I64_EqualsPtr(v.AnOptInt64, rhs.AnOptInt64) {
		return false
	}
	if !(v.AFloat64 == rhs.AFloat64) {
		return false
	}
	if !_Double_EqualsPtr(v.AnOptFloat64, rhs.AnOptFloat64) {
		return false
	}
	if !(v.AUUID == rhs.AUUID) {
		return false
	}
	if !_UUID_EqualsPtr(v.AnOptUUID, rhs.AnOptUUID) {
		return false
	}
	if !_List_UUID_Equals(v.AListUUID, rhs.AListUUID) {
		return false
	}
	if !((v.AnOptListUUID == nil && rhs.AnOptListUUID == nil) || (v.AnOptListUUID != nil && rhs.AnOptListUUID != nil && _List_UUID_Equals(v.AnOptListUUID, rhs.AnOptListUUID))) {
		return false
	}
	if !v.AStringList.Equals(rhs.AStringList) {
		return false
	}
	if !((v.AnOptStringList == nil && rhs.AnOptStringList == nil) || (v.AnOptStringList != nil && rhs.AnOptStringList != nil && v.AnOptStringList.Equals(rhs.AnOptStringList))) {
		return false
	}
	if !v.AUUIDList.Equals(rhs.AUUIDList) {
		return false
	}
	if !((v.AnOptUUIDList == nil && rhs.AnOptUUIDList == nil) || (v.AnOptUUIDList != nil && rhs.AnOptUUIDList != nil && v.AnOptUUIDList.Equals(rhs.AnOptUUIDList))) {
		return false
	}
	if !(v.ATs == rhs.ATs) {
		return false
	}
	if !_Timestamp_EqualsPtr(v.AnOptTs, rhs.AnOptTs) {
		return false
	}
	if !v.AReqDemo.Equals(rhs.AReqDemo) {
		return false
	}
	if !_Fruit_EqualsPtr(v.AnOptFruit, rhs.AnOptFruit) {
		return false
	}
	if !_List_Fruit_Equals(v.AReqFruits, rhs.AReqFruits) {
		return false
	}
	if !((v.AnOptDemos == nil && rhs.AnOptDemos == nil) || (v.AnOptDemos != nil && rhs.AnOptDemos != nil && _List_DemoType_Equals(v.AnOptDemos, rhs.AnOptDemos))) {
		return false
	}

	return true
}

type _List_Fruit_Zapper []Fruit

// MarshalLogArray implements zapcore.ArrayMarshaler, enabling
// fast logging of _List_Fruit_Zapper.
func (l _List_Fruit_Zapper) MarshalLogArray(enc zapcore.ArrayEncoder) (err error) {
	for _, v := range l {
		err = multierr.Append(err, enc.AppendObject(v))
	}
	return err
}

type _List_DemoType_Zapper []DemoType

// MarshalLogArray implements zapcore.ArrayMarshaler, enabling
// fast logging of _List_DemoType_Zapper.
func (l _List_DemoType_Zapper) MarshalLogArray(enc zapcore.ArrayEncoder) (err error) {
	for _, v := range l {
		err = multierr.Append(err, enc.AppendObject(v))
	}
	return err
}

// MarshalLogObject implements zapcore.ObjectMarshaler, enabling
// fast logging of Bar_ArgWithManyQueryParams_Args.
func (v *Bar_ArgWithManyQueryParams_Args) MarshalLogObject(enc zapcore.ObjectEncoder) (err error) {
	if v == nil {
		return nil
	}
	enc.AddString("aStr", v.AStr)
	if v.AnOptStr != nil {
		enc.AddString("anOptStr", *v.AnOptStr)
	}
	enc.AddBool("aBool", v.ABool)
	if v.AnOptBool != nil {
		enc.AddBool("anOptBool", *v.AnOptBool)
	}
	enc.AddInt8("aInt8", v.AInt8)
	if v.AnOptInt8 != nil {
		enc.AddInt8("anOptInt8", *v.AnOptInt8)
	}
	enc.AddInt16("aInt16", v.AInt16)
	if v.AnOptInt16 != nil {
		enc.AddInt16("anOptInt16", *v.AnOptInt16)
	}
	enc.AddInt32("aInt32", v.AInt32)
	if v.AnOptInt32 != nil {
		enc.AddInt32("anOptInt32", *v.AnOptInt32)
	}
	enc.AddInt64("aInt64", v.AInt64)
	if v.AnOptInt64 != nil {
		enc.AddInt64("anOptInt64", *v.AnOptInt64)
	}
	enc.AddFloat64("aFloat64", v.AFloat64)
	if v.AnOptFloat64 != nil {
		enc.AddFloat64("anOptFloat64", *v.AnOptFloat64)
	}
	enc.AddString("aUUID", (string)(v.AUUID))
	if v.AnOptUUID != nil {
		enc.AddString("anOptUUID", (string)(*v.AnOptUUID))
	}
	err = multierr.Append(err, enc.AddArray("aListUUID", (_List_UUID_Zapper)(v.AListUUID)))
	if v.AnOptListUUID != nil {
		err = multierr.Append(err, enc.AddArray("anOptListUUID", (_List_UUID_Zapper)(v.AnOptListUUID)))
	}
	err = multierr.Append(err, enc.AddArray("aStringList", (_List_String_Zapper)(([]string)(v.AStringList))))
	if v.AnOptStringList != nil {
		err = multierr.Append(err, enc.AddArray("anOptStringList", (_List_String_Zapper)(([]string)(v.AnOptStringList))))
	}
	err = multierr.Append(err, enc.AddArray("aUUIDList", (_List_UUID_Zapper)(([]UUID)(v.AUUIDList))))
	if v.AnOptUUIDList != nil {
		err = multierr.Append(err, enc.AddArray("anOptUUIDList", (_List_UUID_Zapper)(([]UUID)(v.AnOptUUIDList))))
	}
	enc.AddInt64("aTs", (int64)(v.ATs))
	if v.AnOptTs != nil {
		enc.AddInt64("anOptTs", (int64)(*v.AnOptTs))
	}
	err = multierr.Append(err, enc.AddObject("aReqDemo", v.AReqDemo))
	if v.AnOptFruit != nil {
		err = multierr.Append(err, enc.AddObject("anOptFruit", *v.AnOptFruit))
	}
	err = multierr.Append(err, enc.AddArray("aReqFruits", (_List_Fruit_Zapper)(v.AReqFruits)))
	if v.AnOptDemos != nil {
		err = multierr.Append(err, enc.AddArray("anOptDemos", (_List_DemoType_Zapper)(v.AnOptDemos)))
	}
	return err
}

// GetAStr returns the value of AStr if it is set or its
// zero value if it is unset.
func (v *Bar_ArgWithManyQueryParams_Args) GetAStr() (o string) {
	if v != nil {
		o = v.AStr
	}
	return
}

// GetAnOptStr returns the value of AnOptStr if it is set or its
// zero value if it is unset.
func (v *Bar_ArgWithManyQueryParams_Args) GetAnOptStr() (o string) {
	if v != nil && v.AnOptStr != nil {
		return *v.AnOptStr
	}

	return
}

// IsSetAnOptStr returns true if AnOptStr is not nil.
func (v *Bar_ArgWithManyQueryParams_Args) IsSetAnOptStr() bool {
	return v != nil && v.AnOptStr != nil
}

// GetABool returns the value of ABool if it is set or its
// zero value if it is unset.
func (v *Bar_ArgWithManyQueryParams_Args) GetABool() (o bool) {
	if v != nil {
		o = v.ABool
	}
	return
}

// GetAnOptBool returns the value of AnOptBool if it is set or its
// zero value if it is unset.
func (v *Bar_ArgWithManyQueryParams_Args) GetAnOptBool() (o bool) {
	if v != nil && v.AnOptBool != nil {
		return *v.AnOptBool
	}

	return
}

// IsSetAnOptBool returns true if AnOptBool is not nil.
func (v *Bar_ArgWithManyQueryParams_Args) IsSetAnOptBool() bool {
	return v != nil && v.AnOptBool != nil
}

// GetAInt8 returns the value of AInt8 if it is set or its
// zero value if it is unset.
func (v *Bar_ArgWithManyQueryParams_Args) GetAInt8() (o int8) {
	if v != nil {
		o = v.AInt8
	}
	return
}

// GetAnOptInt8 returns the value of AnOptInt8 if it is set or its
// zero value if it is unset.
func (v *Bar_ArgWithManyQueryParams_Args) GetAnOptInt8() (o int8) {
	if v != nil && v.AnOptInt8 != nil {
		return *v.AnOptInt8
	}

	return
}

// IsSetAnOptInt8 returns true if AnOptInt8 is not nil.
func (v *Bar_ArgWithManyQueryParams_Args) IsSetAnOptInt8() bool {
	return v != nil && v.AnOptInt8 != nil
}

// GetAInt16 returns the value of AInt16 if it is set or its
// zero value if it is unset.
func (v *Bar_ArgWithManyQueryParams_Args) GetAInt16() (o int16) {
	if v != nil {
		o = v.AInt16
	}
	return
}

// GetAnOptInt16 returns the value of AnOptInt16 if it is set or its
// zero value if it is unset.
func (v *Bar_ArgWithManyQueryParams_Args) GetAnOptInt16() (o int16) {
	if v != nil && v.AnOptInt16 != nil {
		return *v.AnOptInt16
	}

	return
}

// IsSetAnOptInt16 returns true if AnOptInt16 is not nil.
func (v *Bar_ArgWithManyQueryParams_Args) IsSetAnOptInt16() bool {
	return v != nil && v.AnOptInt16 != nil
}

// GetAInt32 returns the value of AInt32 if it is set or its
// zero value if it is unset.
func (v *Bar_ArgWithManyQueryParams_Args) GetAInt32() (o int32) {
	if v != nil {
		o = v.AInt32
	}
	return
}

// GetAnOptInt32 returns the value of AnOptInt32 if it is set or its
// zero value if it is unset.
func (v *Bar_ArgWithManyQueryParams_Args) GetAnOptInt32() (o int32) {
	if v != nil && v.AnOptInt32 != nil {
		return *v.AnOptInt32
	}

	return
}

// IsSetAnOptInt32 returns true if AnOptInt32 is not nil.
func (v *Bar_ArgWithManyQueryParams_Args) IsSetAnOptInt32() bool {
	return v != nil && v.AnOptInt32 != nil
}

// GetAInt64 returns the value of AInt64 if it is set or its
// zero value if it is unset.
func (v *Bar_ArgWithManyQueryParams_Args) GetAInt64() (o int64) {
	if v != nil {
		o = v.AInt64
	}
	return
}

// GetAnOptInt64 returns the value of AnOptInt64 if it is set or its
// zero value if it is unset.
func (v *Bar_ArgWithManyQueryParams_Args) GetAnOptInt64() (o int64) {
	if v != nil && v.AnOptInt64 != nil {
		return *v.AnOptInt64
	}

	return
}

// IsSetAnOptInt64 returns true if AnOptInt64 is not nil.
func (v *Bar_ArgWithManyQueryParams_Args) IsSetAnOptInt64() bool {
	return v != nil && v.AnOptInt64 != nil
}

// GetAFloat64 returns the value of AFloat64 if it is set or its
// zero value if it is unset.
func (v *Bar_ArgWithManyQueryParams_Args) GetAFloat64() (o float64) {
	if v != nil {
		o = v.AFloat64
	}
	return
}

// GetAnOptFloat64 returns the value of AnOptFloat64 if it is set or its
// zero value if it is unset.
func (v *Bar_ArgWithManyQueryParams_Args) GetAnOptFloat64() (o float64) {
	if v != nil && v.AnOptFloat64 != nil {
		return *v.AnOptFloat64
	}

	return
}

// IsSetAnOptFloat64 returns true if AnOptFloat64 is not nil.
func (v *Bar_ArgWithManyQueryParams_Args) IsSetAnOptFloat64() bool {
	return v != nil && v.AnOptFloat64 != nil
}

// GetAUUID returns the value of AUUID if it is set or its
// zero value if it is unset.
func (v *Bar_ArgWithManyQueryParams_Args) GetAUUID() (o UUID) {
	if v != nil {
		o = v.AUUID
	}
	return
}

// GetAnOptUUID returns the value of AnOptUUID if it is set or its
// zero value if it is unset.
func (v *Bar_ArgWithManyQueryParams_Args) GetAnOptUUID() (o UUID) {
	if v != nil && v.AnOptUUID != nil {
		return *v.AnOptUUID
	}

	return
}

// IsSetAnOptUUID returns true if AnOptUUID is not nil.
func (v *Bar_ArgWithManyQueryParams_Args) IsSetAnOptUUID() bool {
	return v != nil && v.AnOptUUID != nil
}

// GetAListUUID returns the value of AListUUID if it is set or its
// zero value if it is unset.
func (v *Bar_ArgWithManyQueryParams_Args) GetAListUUID() (o []UUID) {
	if v != nil {
		o = v.AListUUID
	}
	return
}

// IsSetAListUUID returns true if AListUUID is not nil.
func (v *Bar_ArgWithManyQueryParams_Args) IsSetAListUUID() bool {
	return v != nil && v.AListUUID != nil
}

// GetAnOptListUUID returns the value of AnOptListUUID if it is set or its
// zero value if it is unset.
func (v *Bar_ArgWithManyQueryParams_Args) GetAnOptListUUID() (o []UUID) {
	if v != nil && v.AnOptListUUID != nil {
		return v.AnOptListUUID
	}

	return
}

// IsSetAnOptListUUID returns true if AnOptListUUID is not nil.
func (v *Bar_ArgWithManyQueryParams_Args) IsSetAnOptListUUID() bool {
	return v != nil && v.AnOptListUUID != nil
}

// GetAStringList returns the value of AStringList if it is set or its
// zero value if it is unset.
func (v *Bar_ArgWithManyQueryParams_Args) GetAStringList() (o StringList) {
	if v != nil {
		o = v.AStringList
	}
	return
}

// IsSetAStringList returns true if AStringList is not nil.
func (v *Bar_ArgWithManyQueryParams_Args) IsSetAStringList() bool {
	return v != nil && v.AStringList != nil
}

// GetAnOptStringList returns the value of AnOptStringList if it is set or its
// zero value if it is unset.
func (v *Bar_ArgWithManyQueryParams_Args) GetAnOptStringList() (o StringList) {
	if v != nil && v.AnOptStringList != nil {
		return v.AnOptStringList
	}

	return
}

// IsSetAnOptStringList returns true if AnOptStringList is not nil.
func (v *Bar_ArgWithManyQueryParams_Args) IsSetAnOptStringList() bool {
	return v != nil && v.AnOptStringList != nil
}

// GetAUUIDList returns the value of AUUIDList if it is set or its
// zero value if it is unset.
func (v *Bar_ArgWithManyQueryParams_Args) GetAUUIDList() (o UUIDList) {
	if v != nil {
		o = v.AUUIDList
	}
	return
}

// IsSetAUUIDList returns true if AUUIDList is not nil.
func (v *Bar_ArgWithManyQueryParams_Args) IsSetAUUIDList() bool {
	return v != nil && v.AUUIDList != nil
}

// GetAnOptUUIDList returns the value of AnOptUUIDList if it is set or its
// zero value if it is unset.
func (v *Bar_ArgWithManyQueryParams_Args) GetAnOptUUIDList() (o UUIDList) {
	if v != nil && v.AnOptUUIDList != nil {
		return v.AnOptUUIDList
	}

	return
}

// IsSetAnOptUUIDList returns true if AnOptUUIDList is not nil.
func (v *Bar_ArgWithManyQueryParams_Args) IsSetAnOptUUIDList() bool {
	return v != nil && v.AnOptUUIDList != nil
}

// GetATs returns the value of ATs if it is set or its
// zero value if it is unset.
func (v *Bar_ArgWithManyQueryParams_Args) GetATs() (o Timestamp) {
	if v != nil {
		o = v.ATs
	}
	return
}

// GetAnOptTs returns the value of AnOptTs if it is set or its
// zero value if it is unset.
func (v *Bar_ArgWithManyQueryParams_Args) GetAnOptTs() (o Timestamp) {
	if v != nil && v.AnOptTs != nil {
		return *v.AnOptTs
	}

	return
}

// IsSetAnOptTs returns true if AnOptTs is not nil.
func (v *Bar_ArgWithManyQueryParams_Args) IsSetAnOptTs() bool {
	return v != nil && v.AnOptTs != nil
}

// GetAReqDemo returns the value of AReqDemo if it is set or its
// zero value if it is unset.
func (v *Bar_ArgWithManyQueryParams_Args) GetAReqDemo() (o DemoType) {
	if v != nil {
		o = v.AReqDemo
	}
	return
}

// GetAnOptFruit returns the value of AnOptFruit if it is set or its
// zero value if it is unset.
func (v *Bar_ArgWithManyQueryParams_Args) GetAnOptFruit() (o Fruit) {
	if v != nil && v.AnOptFruit != nil {
		return *v.AnOptFruit
	}

	return
}

// IsSetAnOptFruit returns true if AnOptFruit is not nil.
func (v *Bar_ArgWithManyQueryParams_Args) IsSetAnOptFruit() bool {
	return v != nil && v.AnOptFruit != nil
}

// GetAReqFruits returns the value of AReqFruits if it is set or its
// zero value if it is unset.
func (v *Bar_ArgWithManyQueryParams_Args) GetAReqFruits() (o []Fruit) {
	if v != nil {
		o = v.AReqFruits
	}
	return
}

// IsSetAReqFruits returns true if AReqFruits is not nil.
func (v *Bar_ArgWithManyQueryParams_Args) IsSetAReqFruits() bool {
	return v != nil && v.AReqFruits != nil
}

// GetAnOptDemos returns the value of AnOptDemos if it is set or its
// zero value if it is unset.
func (v *Bar_ArgWithManyQueryParams_Args) GetAnOptDemos() (o []DemoType) {
	if v != nil && v.AnOptDemos != nil {
		return v.AnOptDemos
	}

	return
}

// IsSetAnOptDemos returns true if AnOptDemos is not nil.
func (v *Bar_ArgWithManyQueryParams_Args) IsSetAnOptDemos() bool {
	return v != nil && v.AnOptDemos != nil
}

// MethodName returns the name of the Thrift function as specified in
// the IDL, for which this struct represent the arguments.
//
// This will always be "argWithManyQueryParams" for this struct.
func (v *Bar_ArgWithManyQueryParams_Args) MethodName() string {
	return "argWithManyQueryParams"
}

// EnvelopeType returns the kind of value inside this struct.
//
// This will always be Call for this struct.
func (v *Bar_ArgWithManyQueryParams_Args) EnvelopeType() wire.EnvelopeType {
	return wire.Call
}

// Bar_ArgWithManyQueryParams_Helper provides functions that aid in handling the
// parameters and return values of the Bar.argWithManyQueryParams
// function.
var Bar_ArgWithManyQueryParams_Helper = struct {
	// Args accepts the parameters of argWithManyQueryParams in-order and returns
	// the arguments struct for the function.
	Args func(
		aStr string,
		anOptStr *string,
		aBool bool,
		anOptBool *bool,
		aInt8 int8,
		anOptInt8 *int8,
		aInt16 int16,
		anOptInt16 *int16,
		aInt32 int32,
		anOptInt32 *int32,
		aInt64 int64,
		anOptInt64 *int64,
		aFloat64 float64,
		anOptFloat64 *float64,
		aUUID UUID,
		anOptUUID *UUID,
		aListUUID []UUID,
		anOptListUUID []UUID,
		aStringList StringList,
		anOptStringList StringList,
		aUUIDList UUIDList,
		anOptUUIDList UUIDList,
		aTs Timestamp,
		anOptTs *Timestamp,
		aReqDemo DemoType,
		anOptFruit *Fruit,
		aReqFruits []Fruit,
		anOptDemos []DemoType,
	) *Bar_ArgWithManyQueryParams_Args

	// IsException returns true if the given error can be thrown
	// by argWithManyQueryParams.
	//
	// An error can be thrown by argWithManyQueryParams only if the
	// corresponding exception type was mentioned in the 'throws'
	// section for it in the Thrift file.
	IsException func(error) bool

	// WrapResponse returns the result struct for argWithManyQueryParams
	// given its return value and error.
	//
	// This allows mapping values and errors returned by
	// argWithManyQueryParams into a serializable result struct.
	// WrapResponse returns a non-nil error if the provided
	// error cannot be thrown by argWithManyQueryParams
	//
	//   value, err := argWithManyQueryParams(args)
	//   result, err := Bar_ArgWithManyQueryParams_Helper.WrapResponse(value, err)
	//   if err != nil {
	//     return fmt.Errorf("unexpected error from argWithManyQueryParams: %v", err)
	//   }
	//   serialize(result)
	WrapResponse func(*BarResponse, error) (*Bar_ArgWithManyQueryParams_Result, error)

	// UnwrapResponse takes the result struct for argWithManyQueryParams
	// and returns the value or error returned by it.
	//
	// The error is non-nil only if argWithManyQueryParams threw an
	// exception.
	//
	//   result := deserialize(bytes)
	//   value, err := Bar_ArgWithManyQueryParams_Helper.UnwrapResponse(result)
	UnwrapResponse func(*Bar_ArgWithManyQueryParams_Result) (*BarResponse, error)
}{}

func init() {
	Bar_ArgWithManyQueryParams_Helper.Args = func(
		aStr string,
		anOptStr *string,
		aBool bool,
		anOptBool *bool,
		aInt8 int8,
		anOptInt8 *int8,
		aInt16 int16,
		anOptInt16 *int16,
		aInt32 int32,
		anOptInt32 *int32,
		aInt64 int64,
		anOptInt64 *int64,
		aFloat64 float64,
		anOptFloat64 *float64,
		aUUID UUID,
		anOptUUID *UUID,
		aListUUID []UUID,
		anOptListUUID []UUID,
		aStringList StringList,
		anOptStringList StringList,
		aUUIDList UUIDList,
		anOptUUIDList UUIDList,
		aTs Timestamp,
		anOptTs *Timestamp,
		aReqDemo DemoType,
		anOptFruit *Fruit,
		aReqFruits []Fruit,
		anOptDemos []DemoType,
	) *Bar_ArgWithManyQueryParams_Args {
		return &Bar_ArgWithManyQueryParams_Args{
			AStr:            aStr,
			AnOptStr:        anOptStr,
			ABool:           aBool,
			AnOptBool:       anOptBool,
			AInt8:           aInt8,
			AnOptInt8:       anOptInt8,
			AInt16:          aInt16,
			AnOptInt16:      anOptInt16,
			AInt32:          aInt32,
			AnOptInt32:      anOptInt32,
			AInt64:          aInt64,
			AnOptInt64:      anOptInt64,
			AFloat64:        aFloat64,
			AnOptFloat64:    anOptFloat64,
			AUUID:           aUUID,
			AnOptUUID:       anOptUUID,
			AListUUID:       aListUUID,
			AnOptListUUID:   anOptListUUID,
			AStringList:     aStringList,
			AnOptStringList: anOptStringList,
			AUUIDList:       aUUIDList,
			AnOptUUIDList:   anOptUUIDList,
			ATs:             aTs,
			AnOptTs:         anOptTs,
			AReqDemo:        aReqDemo,
			AnOptFruit:      anOptFruit,
			AReqFruits:      aReqFruits,
			AnOptDemos:      anOptDemos,
		}
	}

	Bar_ArgWithManyQueryParams_Helper.IsException = func(err error) bool {
		switch err.(type) {
		default:
			return false
		}
	}

	Bar_ArgWithManyQueryParams_Helper.WrapResponse = func(success *BarResponse, err error) (*Bar_ArgWithManyQueryParams_Result, error) {
		if err == nil {
			return &Bar_ArgWithManyQueryParams_Result{Success: success}, nil
		}

		return nil, err
	}
	Bar_ArgWithManyQueryParams_Helper.UnwrapResponse = func(result *Bar_ArgWithManyQueryParams_Result) (success *BarResponse, err error) {

		if result.Success != nil {
			success = result.Success
			return
		}

		err = errors.New("expected a non-void result")
		return
	}

}

// Bar_ArgWithManyQueryParams_Result represents the result of a Bar.argWithManyQueryParams function call.
//
// The result of a argWithManyQueryParams execution is sent and received over the wire as this struct.
//
// Success is set only if the function did not throw an exception.
type Bar_ArgWithManyQueryParams_Result struct {
	// Value returned by argWithManyQueryParams after a successful execution.
	Success *BarResponse `json:"success,omitempty"`
}

// ToWire translates a Bar_ArgWithManyQueryParams_Result struct into a Thrift-level intermediate
// representation. This intermediate representation may be serialized
// into bytes using a ThriftRW protocol implementation.
//
// An error is returned if the struct or any of its fields failed to
// validate.
//
//   x, err := v.ToWire()
//   if err != nil {
//     return err
//   }
//
//   if err := binaryProtocol.Encode(x, writer); err != nil {
//     return err
//   }
func (v *Bar_ArgWithManyQueryParams_Result) ToWire() (wire.Value, error) {
	var (
		fields [1]wire.Field
		i      int = 0
		w      wire.Value
		err    error
	)

	if v.Success != nil {
		w, err = v.Success.ToWire()
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 0, Value: w}
		i++
	}

	if i != 1 {
		return wire.Value{}, fmt.Errorf("Bar_ArgWithManyQueryParams_Result should have exactly one field: got %v fields", i)
	}

	return wire.NewValueStruct(wire.Struct{Fields: fields[:i]}), nil
}

// FromWire deserializes a Bar_ArgWithManyQueryParams_Result struct from its Thrift-level
// representation. The Thrift-level representation may be obtained
// from a ThriftRW protocol implementation.
//
// An error is returned if we were unable to build a Bar_ArgWithManyQueryParams_Result struct
// from the provided intermediate representation.
//
//   x, err := binaryProtocol.Decode(reader, wire.TStruct)
//   if err != nil {
//     return nil, err
//   }
//
//   var v Bar_ArgWithManyQueryParams_Result
//   if err := v.FromWire(x); err != nil {
//     return nil, err
//   }
//   return &v, nil
func (v *Bar_ArgWithManyQueryParams_Result) FromWire(w wire.Value) error {
	var err error

	for _, field := range w.GetStruct().Fields {
		switch field.ID {
		case 0:
			if field.Value.Type() == wire.TStruct {
				v.Success, err = _BarResponse_Read(field.Value)
				if err != nil {
					return err
				}

			}
		}
	}

	count := 0
	if v.Success != nil {
		count++
	}
	if count != 1 {
		return fmt.Errorf("Bar_ArgWithManyQueryParams_Result should have exactly one field: got %v fields", count)
	}

	return nil
}

// String returns a readable string representation of a Bar_ArgWithManyQueryParams_Result
// struct.
func (v *Bar_ArgWithManyQueryParams_Result) String() string {
	if v == nil {
		return "<nil>"
	}

	var fields [1]string
	i := 0
	if v.Success != nil {
		fields[i] = fmt.Sprintf("Success: %v", v.Success)
		i++
	}

	return fmt.Sprintf("Bar_ArgWithManyQueryParams_Result{%v}", strings.Join(fields[:i], ", "))
}

// Equals returns true if all the fields of this Bar_ArgWithManyQueryParams_Result match the
// provided Bar_ArgWithManyQueryParams_Result.
//
// This function performs a deep comparison.
func (v *Bar_ArgWithManyQueryParams_Result) Equals(rhs *Bar_ArgWithManyQueryParams_Result) bool {
	if v == nil {
		return rhs == nil
	} else if rhs == nil {
		return false
	}
	if !((v.Success == nil && rhs.Success == nil) || (v.Success != nil && rhs.Success != nil && v.Success.Equals(rhs.Success))) {
		return false
	}

	return true
}

// MarshalLogObject implements zapcore.ObjectMarshaler, enabling
// fast logging of Bar_ArgWithManyQueryParams_Result.
func (v *Bar_ArgWithManyQueryParams_Result) MarshalLogObject(enc zapcore.ObjectEncoder) (err error) {
	if v == nil {
		return nil
	}
	if v.Success != nil {
		err = multierr.Append(err, enc.AddObject("success", v.Success))
	}
	return err
}

// GetSuccess returns the value of Success if it is set or its
// zero value if it is unset.
func (v *Bar_ArgWithManyQueryParams_Result) GetSuccess() (o *BarResponse) {
	if v != nil && v.Success != nil {
		return v.Success
	}

	return
}

// IsSetSuccess returns true if Success is not nil.
func (v *Bar_ArgWithManyQueryParams_Result) IsSetSuccess() bool {
	return v != nil && v.Success != nil
}

// MethodName returns the name of the Thrift function as specified in
// the IDL, for which this struct represent the result.
//
// This will always be "argWithManyQueryParams" for this struct.
func (v *Bar_ArgWithManyQueryParams_Result) MethodName() string {
	return "argWithManyQueryParams"
}

// EnvelopeType returns the kind of value inside this struct.
//
// This will always be Reply for this struct.
func (v *Bar_ArgWithManyQueryParams_Result) EnvelopeType() wire.EnvelopeType {
	return wire.Reply
}

// Bar_ArgWithNearDupQueryParams_Args represents the arguments for the Bar.argWithNearDupQueryParams function.
//
// The arguments for argWithNearDupQueryParams are sent and received over the wire as this struct.
type Bar_ArgWithNearDupQueryParams_Args struct {
	One   string  `json:"one,required"`
	Two   *int32  `json:"two,omitempty"`
	Three *string `json:"three,omitempty"`
	Four  *string `json:"four,omitempty"`
}

// ToWire translates a Bar_ArgWithNearDupQueryParams_Args struct into a Thrift-level intermediate
// representation. This intermediate representation may be serialized
// into bytes using a ThriftRW protocol implementation.
//
// An error is returned if the struct or any of its fields failed to
// validate.
//
//   x, err := v.ToWire()
//   if err != nil {
//     return err
//   }
//
//   if err := binaryProtocol.Encode(x, writer); err != nil {
//     return err
//   }
func (v *Bar_ArgWithNearDupQueryParams_Args) ToWire() (wire.Value, error) {
	var (
		fields [4]wire.Field
		i      int = 0
		w      wire.Value
		err    error
	)

	w, err = wire.NewValueString(v.One), error(nil)
	if err != nil {
		return w, err
	}
	fields[i] = wire.Field{ID: 1, Value: w}
	i++
	if v.Two != nil {
		w, err = wire.NewValueI32(*(v.Two)), error(nil)
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 2, Value: w}
		i++
	}
	if v.Three != nil {
		w, err = wire.NewValueString(*(v.Three)), error(nil)
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 3, Value: w}
		i++
	}
	if v.Four != nil {
		w, err = wire.NewValueString(*(v.Four)), error(nil)
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 4, Value: w}
		i++
	}

	return wire.NewValueStruct(wire.Struct{Fields: fields[:i]}), nil
}

// FromWire deserializes a Bar_ArgWithNearDupQueryParams_Args struct from its Thrift-level
// representation. The Thrift-level representation may be obtained
// from a ThriftRW protocol implementation.
//
// An error is returned if we were unable to build a Bar_ArgWithNearDupQueryParams_Args struct
// from the provided intermediate representation.
//
//   x, err := binaryProtocol.Decode(reader, wire.TStruct)
//   if err != nil {
//     return nil, err
//   }
//
//   var v Bar_ArgWithNearDupQueryParams_Args
//   if err := v.FromWire(x); err != nil {
//     return nil, err
//   }
//   return &v, nil
func (v *Bar_ArgWithNearDupQueryParams_Args) FromWire(w wire.Value) error {
	var err error

	oneIsSet := false

	for _, field := range w.GetStruct().Fields {
		switch field.ID {
		case 1:
			if field.Value.Type() == wire.TBinary {
				v.One, err = field.Value.GetString(), error(nil)
				if err != nil {
					return err
				}
				oneIsSet = true
			}
		case 2:
			if field.Value.Type() == wire.TI32 {
				var x int32
				x, err = field.Value.GetI32(), error(nil)
				v.Two = &x
				if err != nil {
					return err
				}

			}
		case 3:
			if field.Value.Type() == wire.TBinary {
				var x string
				x, err = field.Value.GetString(), error(nil)
				v.Three = &x
				if err != nil {
					return err
				}

			}
		case 4:
			if field.Value.Type() == wire.TBinary {
				var x string
				x, err = field.Value.GetString(), error(nil)
				v.Four = &x
				if err != nil {
					return err
				}

			}
		}
	}

	if !oneIsSet {
		return errors.New("field One of Bar_ArgWithNearDupQueryParams_Args is required")
	}

	return nil
}

// String returns a readable string representation of a Bar_ArgWithNearDupQueryParams_Args
// struct.
func (v *Bar_ArgWithNearDupQueryParams_Args) String() string {
	if v == nil {
		return "<nil>"
	}

	var fields [4]string
	i := 0
	fields[i] = fmt.Sprintf("One: %v", v.One)
	i++
	if v.Two != nil {
		fields[i] = fmt.Sprintf("Two: %v", *(v.Two))
		i++
	}
	if v.Three != nil {
		fields[i] = fmt.Sprintf("Three: %v", *(v.Three))
		i++
	}
	if v.Four != nil {
		fields[i] = fmt.Sprintf("Four: %v", *(v.Four))
		i++
	}

	return fmt.Sprintf("Bar_ArgWithNearDupQueryParams_Args{%v}", strings.Join(fields[:i], ", "))
}

// Equals returns true if all the fields of this Bar_ArgWithNearDupQueryParams_Args match the
// provided Bar_ArgWithNearDupQueryParams_Args.
//
// This function performs a deep comparison.
func (v *Bar_ArgWithNearDupQueryParams_Args) Equals(rhs *Bar_ArgWithNearDupQueryParams_Args) bool {
	if v == nil {
		return rhs == nil
	} else if rhs == nil {
		return false
	}
	if !(v.One == rhs.One) {
		return false
	}
	if !_I32_EqualsPtr(v.Two, rhs.Two) {
		return false
	}
	if !_String_EqualsPtr(v.Three, rhs.Three) {
		return false
	}
	if !_String_EqualsPtr(v.Four, rhs.Four) {
		return false
	}

	return true
}

// MarshalLogObject implements zapcore.ObjectMarshaler, enabling
// fast logging of Bar_ArgWithNearDupQueryParams_Args.
func (v *Bar_ArgWithNearDupQueryParams_Args) MarshalLogObject(enc zapcore.ObjectEncoder) (err error) {
	if v == nil {
		return nil
	}
	enc.AddString("one", v.One)
	if v.Two != nil {
		enc.AddInt32("two", *v.Two)
	}
	if v.Three != nil {
		enc.AddString("three", *v.Three)
	}
	if v.Four != nil {
		enc.AddString("four", *v.Four)
	}
	return err
}

// GetOne returns the value of One if it is set or its
// zero value if it is unset.
func (v *Bar_ArgWithNearDupQueryParams_Args) GetOne() (o string) {
	if v != nil {
		o = v.One
	}
	return
}

// GetTwo returns the value of Two if it is set or its
// zero value if it is unset.
func (v *Bar_ArgWithNearDupQueryParams_Args) GetTwo() (o int32) {
	if v != nil && v.Two != nil {
		return *v.Two
	}

	return
}

// IsSetTwo returns true if Two is not nil.
func (v *Bar_ArgWithNearDupQueryParams_Args) IsSetTwo() bool {
	return v != nil && v.Two != nil
}

// GetThree returns the value of Three if it is set or its
// zero value if it is unset.
func (v *Bar_ArgWithNearDupQueryParams_Args) GetThree() (o string) {
	if v != nil && v.Three != nil {
		return *v.Three
	}

	return
}

// IsSetThree returns true if Three is not nil.
func (v *Bar_ArgWithNearDupQueryParams_Args) IsSetThree() bool {
	return v != nil && v.Three != nil
}

// GetFour returns the value of Four if it is set or its
// zero value if it is unset.
func (v *Bar_ArgWithNearDupQueryParams_Args) GetFour() (o string) {
	if v != nil && v.Four != nil {
		return *v.Four
	}

	return
}

// IsSetFour returns true if Four is not nil.
func (v *Bar_ArgWithNearDupQueryParams_Args) IsSetFour() bool {
	return v != nil && v.Four != nil
}

// MethodName returns the name of the Thrift function as specified in
// the IDL, for which this struct represent the arguments.
//
// This will always be "argWithNearDupQueryParams" for this struct.
func (v *Bar_ArgWithNearDupQueryParams_Args) MethodName() string {
	return "argWithNearDupQueryParams"
}

// EnvelopeType returns the kind of value inside this struct.
//
// This will always be Call for this struct.
func (v *Bar_ArgWithNearDupQueryParams_Args) EnvelopeType() wire.EnvelopeType {
	return wire.Call
}

// Bar_ArgWithNearDupQueryParams_Helper provides functions that aid in handling the
// parameters and return values of the Bar.argWithNearDupQueryParams
// function.
var Bar_ArgWithNearDupQueryParams_Helper = struct {
	// Args accepts the parameters of argWithNearDupQueryParams in-order and returns
	// the arguments struct for the function.
	Args func(
		one string,
		two *int32,
		three *string,
		four *string,
	) *Bar_ArgWithNearDupQueryParams_Args

	// IsException returns true if the given error can be thrown
	// by argWithNearDupQueryParams.
	//
	// An error can be thrown by argWithNearDupQueryParams only if the
	// corresponding exception type was mentioned in the 'throws'
	// section for it in the Thrift file.
	IsException func(error) bool

	// WrapResponse returns the result struct for argWithNearDupQueryParams
	// given its return value and error.
	//
	// This allows mapping values and errors returned by
	// argWithNearDupQueryParams into a serializable result struct.
	// WrapResponse returns a non-nil error if the provided
	// error cannot be thrown by argWithNearDupQueryParams
	//
	//   value, err := argWithNearDupQueryParams(args)
	//   result, err := Bar_ArgWithNearDupQueryParams_Helper.WrapResponse(value, err)
	//   if err != nil {
	//     return fmt.Errorf("unexpected error from argWithNearDupQueryParams: %v", err)
	//   }
	//   serialize(result)
	WrapResponse func(*BarResponse, error) (*Bar_ArgWithNearDupQueryParams_Result, error)

	// UnwrapResponse takes the result struct for argWithNearDupQueryParams
	// and returns the value or error returned by it.
	//
	// The error is non-nil only if argWithNearDupQueryParams threw an
	// exception.
	//
	//   result := deserialize(bytes)
	//   value, err := Bar_ArgWithNearDupQueryParams_Helper.UnwrapResponse(result)
	UnwrapResponse func(*Bar_ArgWithNearDupQueryParams_Result) (*BarResponse, error)
}{}

func init() {
	Bar_ArgWithNearDupQueryParams_Helper.Args = func(
		one string,
		two *int32,
		three *string,
		four *string,
	) *Bar_ArgWithNearDupQueryParams_Args {
		return &Bar_ArgWithNearDupQueryParams_Args{
			One:   one,
			Two:   two,
			Three: three,
			Four:  four,
		}
	}

	Bar_ArgWithNearDupQueryParams_Helper.IsException = func(err error) bool {
		switch err.(type) {
		default:
			return false
		}
	}

	Bar_ArgWithNearDupQueryParams_Helper.WrapResponse = func(success *BarResponse, err error) (*Bar_ArgWithNearDupQueryParams_Result, error) {
		if err == nil {
			return &Bar_ArgWithNearDupQueryParams_Result{Success: success}, nil
		}

		return nil, err
	}
	Bar_ArgWithNearDupQueryParams_Helper.UnwrapResponse = func(result *Bar_ArgWithNearDupQueryParams_Result) (success *BarResponse, err error) {

		if result.Success != nil {
			success = result.Success
			return
		}

		err = errors.New("expected a non-void result")
		return
	}

}

// Bar_ArgWithNearDupQueryParams_Result represents the result of a Bar.argWithNearDupQueryParams function call.
//
// The result of a argWithNearDupQueryParams execution is sent and received over the wire as this struct.
//
// Success is set only if the function did not throw an exception.
type Bar_ArgWithNearDupQueryParams_Result struct {
	// Value returned by argWithNearDupQueryParams after a successful execution.
	Success *BarResponse `json:"success,omitempty"`
}

// ToWire translates a Bar_ArgWithNearDupQueryParams_Result struct into a Thrift-level intermediate
// representation. This intermediate representation may be serialized
// into bytes using a ThriftRW protocol implementation.
//
// An error is returned if the struct or any of its fields failed to
// validate.
//
//   x, err := v.ToWire()
//   if err != nil {
//     return err
//   }
//
//   if err := binaryProtocol.Encode(x, writer); err != nil {
//     return err
//   }
func (v *Bar_ArgWithNearDupQueryParams_Result) ToWire() (wire.Value, error) {
	var (
		fields [1]wire.Field
		i      int = 0
		w      wire.Value
		err    error
	)

	if v.Success != nil {
		w, err = v.Success.ToWire()
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 0, Value: w}
		i++
	}

	if i != 1 {
		return wire.Value{}, fmt.Errorf("Bar_ArgWithNearDupQueryParams_Result should have exactly one field: got %v fields", i)
	}

	return wire.NewValueStruct(wire.Struct{Fields: fields[:i]}), nil
}

// FromWire deserializes a Bar_ArgWithNearDupQueryParams_Result struct from its Thrift-level
// representation. The Thrift-level representation may be obtained
// from a ThriftRW protocol implementation.
//
// An error is returned if we were unable to build a Bar_ArgWithNearDupQueryParams_Result struct
// from the provided intermediate representation.
//
//   x, err := binaryProtocol.Decode(reader, wire.TStruct)
//   if err != nil {
//     return nil, err
//   }
//
//   var v Bar_ArgWithNearDupQueryParams_Result
//   if err := v.FromWire(x); err != nil {
//     return nil, err
//   }
//   return &v, nil
func (v *Bar_ArgWithNearDupQueryParams_Result) FromWire(w wire.Value) error {
	var err error

	for _, field := range w.GetStruct().Fields {
		switch field.ID {
		case 0:
			if field.Value.Type() == wire.TStruct {
				v.Success, err = _BarResponse_Read(field.Value)
				if err != nil {
					return err
				}

			}
		}
	}

	count := 0
	if v.Success != nil {
		count++
	}
	if count != 1 {
		return fmt.Errorf("Bar_ArgWithNearDupQueryParams_Result should have exactly one field: got %v fields", count)
	}

	return nil
}

// String returns a readable string representation of a Bar_ArgWithNearDupQueryParams_Result
// struct.
func (v *Bar_ArgWithNearDupQueryParams_Result) String() string {
	if v == nil {
		return "<nil>"
	}

	var fields [1]string
	i := 0
	if v.Success != nil {
		fields[i] = fmt.Sprintf("Success: %v", v.Success)
		i++
	}

	return fmt.Sprintf("Bar_ArgWithNearDupQueryParams_Result{%v}", strings.Join(fields[:i], ", "))
}

// Equals returns true if all the fields of this Bar_ArgWithNearDupQueryParams_Result match the
// provided Bar_ArgWithNearDupQueryParams_Result.
//
// This function performs a deep comparison.
func (v *Bar_ArgWithNearDupQueryParams_Result) Equals(rhs *Bar_ArgWithNearDupQueryParams_Result) bool {
	if v == nil {
		return rhs == nil
	} else if rhs == nil {
		return false
	}
	if !((v.Success == nil && rhs.Success == nil) || (v.Success != nil && rhs.Success != nil && v.Success.Equals(rhs.Success))) {
		return false
	}

	return true
}

// MarshalLogObject implements zapcore.ObjectMarshaler, enabling
// fast logging of Bar_ArgWithNearDupQueryParams_Result.
func (v *Bar_ArgWithNearDupQueryParams_Result) MarshalLogObject(enc zapcore.ObjectEncoder) (err error) {
	if v == nil {
		return nil
	}
	if v.Success != nil {
		err = multierr.Append(err, enc.AddObject("success", v.Success))
	}
	return err
}

// GetSuccess returns the value of Success if it is set or its
// zero value if it is unset.
func (v *Bar_ArgWithNearDupQueryParams_Result) GetSuccess() (o *BarResponse) {
	if v != nil && v.Success != nil {
		return v.Success
	}

	return
}

// IsSetSuccess returns true if Success is not nil.
func (v *Bar_ArgWithNearDupQueryParams_Result) IsSetSuccess() bool {
	return v != nil && v.Success != nil
}

// MethodName returns the name of the Thrift function as specified in
// the IDL, for which this struct represent the result.
//
// This will always be "argWithNearDupQueryParams" for this struct.
func (v *Bar_ArgWithNearDupQueryParams_Result) MethodName() string {
	return "argWithNearDupQueryParams"
}

// EnvelopeType returns the kind of value inside this struct.
//
// This will always be Reply for this struct.
func (v *Bar_ArgWithNearDupQueryParams_Result) EnvelopeType() wire.EnvelopeType {
	return wire.Reply
}

// Bar_ArgWithNestedQueryParams_Args represents the arguments for the Bar.argWithNestedQueryParams function.
//
// The arguments for argWithNestedQueryParams are sent and received over the wire as this struct.
type Bar_ArgWithNestedQueryParams_Args struct {
	Request *QueryParamsStruct     `json:"request,required"`
	Opt     *QueryParamsOptsStruct `json:"opt,omitempty"`
}

// ToWire translates a Bar_ArgWithNestedQueryParams_Args struct into a Thrift-level intermediate
// representation. This intermediate representation may be serialized
// into bytes using a ThriftRW protocol implementation.
//
// An error is returned if the struct or any of its fields failed to
// validate.
//
//   x, err := v.ToWire()
//   if err != nil {
//     return err
//   }
//
//   if err := binaryProtocol.Encode(x, writer); err != nil {
//     return err
//   }
func (v *Bar_ArgWithNestedQueryParams_Args) ToWire() (wire.Value, error) {
	var (
		fields [2]wire.Field
		i      int = 0
		w      wire.Value
		err    error
	)

	if v.Request == nil {
		return w, errors.New("field Request of Bar_ArgWithNestedQueryParams_Args is required")
	}
	w, err = v.Request.ToWire()
	if err != nil {
		return w, err
	}
	fields[i] = wire.Field{ID: 1, Value: w}
	i++
	if v.Opt != nil {
		w, err = v.Opt.ToWire()
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 2, Value: w}
		i++
	}

	return wire.NewValueStruct(wire.Struct{Fields: fields[:i]}), nil
}

func _QueryParamsStruct_Read(w wire.Value) (*QueryParamsStruct, error) {
	var v QueryParamsStruct
	err := v.FromWire(w)
	return &v, err
}

func _QueryParamsOptsStruct_Read(w wire.Value) (*QueryParamsOptsStruct, error) {
	var v QueryParamsOptsStruct
	err := v.FromWire(w)
	return &v, err
}

// FromWire deserializes a Bar_ArgWithNestedQueryParams_Args struct from its Thrift-level
// representation. The Thrift-level representation may be obtained
// from a ThriftRW protocol implementation.
//
// An error is returned if we were unable to build a Bar_ArgWithNestedQueryParams_Args struct
// from the provided intermediate representation.
//
//   x, err := binaryProtocol.Decode(reader, wire.TStruct)
//   if err != nil {
//     return nil, err
//   }
//
//   var v Bar_ArgWithNestedQueryParams_Args
//   if err := v.FromWire(x); err != nil {
//     return nil, err
//   }
//   return &v, nil
func (v *Bar_ArgWithNestedQueryParams_Args) FromWire(w wire.Value) error {
	var err error

	requestIsSet := false

	for _, field := range w.GetStruct().Fields {
		switch field.ID {
		case 1:
			if field.Value.Type() == wire.TStruct {
				v.Request, err = _QueryParamsStruct_Read(field.Value)
				if err != nil {
					return err
				}
				requestIsSet = true
			}
		case 2:
			if field.Value.Type() == wire.TStruct {
				v.Opt, err = _QueryParamsOptsStruct_Read(field.Value)
				if err != nil {
					return err
				}

			}
		}
	}

	if !requestIsSet {
		return errors.New("field Request of Bar_ArgWithNestedQueryParams_Args is required")
	}

	return nil
}

// String returns a readable string representation of a Bar_ArgWithNestedQueryParams_Args
// struct.
func (v *Bar_ArgWithNestedQueryParams_Args) String() string {
	if v == nil {
		return "<nil>"
	}

	var fields [2]string
	i := 0
	fields[i] = fmt.Sprintf("Request: %v", v.Request)
	i++
	if v.Opt != nil {
		fields[i] = fmt.Sprintf("Opt: %v", v.Opt)
		i++
	}

	return fmt.Sprintf("Bar_ArgWithNestedQueryParams_Args{%v}", strings.Join(fields[:i], ", "))
}

// Equals returns true if all the fields of this Bar_ArgWithNestedQueryParams_Args match the
// provided Bar_ArgWithNestedQueryParams_Args.
//
// This function performs a deep comparison.
func (v *Bar_ArgWithNestedQueryParams_Args) Equals(rhs *Bar_ArgWithNestedQueryParams_Args) bool {
	if v == nil {
		return rhs == nil
	} else if rhs == nil {
		return false
	}
	if !v.Request.Equals(rhs.Request) {
		return false
	}
	if !((v.Opt == nil && rhs.Opt == nil) || (v.Opt != nil && rhs.Opt != nil && v.Opt.Equals(rhs.Opt))) {
		return false
	}

	return true
}

// MarshalLogObject implements zapcore.ObjectMarshaler, enabling
// fast logging of Bar_ArgWithNestedQueryParams_Args.
func (v *Bar_ArgWithNestedQueryParams_Args) MarshalLogObject(enc zapcore.ObjectEncoder) (err error) {
	if v == nil {
		return nil
	}
	err = multierr.Append(err, enc.AddObject("request", v.Request))
	if v.Opt != nil {
		err = multierr.Append(err, enc.AddObject("opt", v.Opt))
	}
	return err
}

// GetRequest returns the value of Request if it is set or its
// zero value if it is unset.
func (v *Bar_ArgWithNestedQueryParams_Args) GetRequest() (o *QueryParamsStruct) {
	if v != nil {
		o = v.Request
	}
	return
}

// IsSetRequest returns true if Request is not nil.
func (v *Bar_ArgWithNestedQueryParams_Args) IsSetRequest() bool {
	return v != nil && v.Request != nil
}

// GetOpt returns the value of Opt if it is set or its
// zero value if it is unset.
func (v *Bar_ArgWithNestedQueryParams_Args) GetOpt() (o *QueryParamsOptsStruct) {
	if v != nil && v.Opt != nil {
		return v.Opt
	}

	return
}

// IsSetOpt returns true if Opt is not nil.
func (v *Bar_ArgWithNestedQueryParams_Args) IsSetOpt() bool {
	return v != nil && v.Opt != nil
}

// MethodName returns the name of the Thrift function as specified in
// the IDL, for which this struct represent the arguments.
//
// This will always be "argWithNestedQueryParams" for this struct.
func (v *Bar_ArgWithNestedQueryParams_Args) MethodName() string {
	return "argWithNestedQueryParams"
}

// EnvelopeType returns the kind of value inside this struct.
//
// This will always be Call for this struct.
func (v *Bar_ArgWithNestedQueryParams_Args) EnvelopeType() wire.EnvelopeType {
	return wire.Call
}

// Bar_ArgWithNestedQueryParams_Helper provides functions that aid in handling the
// parameters and return values of the Bar.argWithNestedQueryParams
// function.
var Bar_ArgWithNestedQueryParams_Helper = struct {
	// Args accepts the parameters of argWithNestedQueryParams in-order and returns
	// the arguments struct for the function.
	Args func(
		request *QueryParamsStruct,
		opt *QueryParamsOptsStruct,
	) *Bar_ArgWithNestedQueryParams_Args

	// IsException returns true if the given error can be thrown
	// by argWithNestedQueryParams.
	//
	// An error can be thrown by argWithNestedQueryParams only if the
	// corresponding exception type was mentioned in the 'throws'
	// section for it in the Thrift file.
	IsException func(error) bool

	// WrapResponse returns the result struct for argWithNestedQueryParams
	// given its return value and error.
	//
	// This allows mapping values and errors returned by
	// argWithNestedQueryParams into a serializable result struct.
	// WrapResponse returns a non-nil error if the provided
	// error cannot be thrown by argWithNestedQueryParams
	//
	//   value, err := argWithNestedQueryParams(args)
	//   result, err := Bar_ArgWithNestedQueryParams_Helper.WrapResponse(value, err)
	//   if err != nil {
	//     return fmt.Errorf("unexpected error from argWithNestedQueryParams: %v", err)
	//   }
	//   serialize(result)
	WrapResponse func(*BarResponse, error) (*Bar_ArgWithNestedQueryParams_Result, error)

	// UnwrapResponse takes the result struct for argWithNestedQueryParams
	// and returns the value or error returned by it.
	//
	// The error is non-nil only if argWithNestedQueryParams threw an
	// exception.
	//
	//   result := deserialize(bytes)
	//   value, err := Bar_ArgWithNestedQueryParams_Helper.UnwrapResponse(result)
	UnwrapResponse func(*Bar_ArgWithNestedQueryParams_Result) (*BarResponse, error)
}{}

func init() {
	Bar_ArgWithNestedQueryParams_Helper.Args = func(
		request *QueryParamsStruct,
		opt *QueryParamsOptsStruct,
	) *Bar_ArgWithNestedQueryParams_Args {
		return &Bar_ArgWithNestedQueryParams_Args{
			Request: request,
			Opt:     opt,
		}
	}

	Bar_ArgWithNestedQueryParams_Helper.IsException = func(err error) bool {
		switch err.(type) {
		default:
			return false
		}
	}

	Bar_ArgWithNestedQueryParams_Helper.WrapResponse = func(success *BarResponse, err error) (*Bar_ArgWithNestedQueryParams_Result, error) {
		if err == nil {
			return &Bar_ArgWithNestedQueryParams_Result{Success: success}, nil
		}

		return nil, err
	}
	Bar_ArgWithNestedQueryParams_Helper.UnwrapResponse = func(result *Bar_ArgWithNestedQueryParams_Result) (success *BarResponse, err error) {

		if result.Success != nil {
			success = result.Success
			return
		}

		err = errors.New("expected a non-void result")
		return
	}

}

// Bar_ArgWithNestedQueryParams_Result represents the result of a Bar.argWithNestedQueryParams function call.
//
// The result of a argWithNestedQueryParams execution is sent and received over the wire as this struct.
//
// Success is set only if the function did not throw an exception.
type Bar_ArgWithNestedQueryParams_Result struct {
	// Value returned by argWithNestedQueryParams after a successful execution.
	Success *BarResponse `json:"success,omitempty"`
}

// ToWire translates a Bar_ArgWithNestedQueryParams_Result struct into a Thrift-level intermediate
// representation. This intermediate representation may be serialized
// into bytes using a ThriftRW protocol implementation.
//
// An error is returned if the struct or any of its fields failed to
// validate.
//
//   x, err := v.ToWire()
//   if err != nil {
//     return err
//   }
//
//   if err := binaryProtocol.Encode(x, writer); err != nil {
//     return err
//   }
func (v *Bar_ArgWithNestedQueryParams_Result) ToWire() (wire.Value, error) {
	var (
		fields [1]wire.Field
		i      int = 0
		w      wire.Value
		err    error
	)

	if v.Success != nil {
		w, err = v.Success.ToWire()
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 0, Value: w}
		i++
	}

	if i != 1 {
		return wire.Value{}, fmt.Errorf("Bar_ArgWithNestedQueryParams_Result should have exactly one field: got %v fields", i)
	}

	return wire.NewValueStruct(wire.Struct{Fields: fields[:i]}), nil
}

// FromWire deserializes a Bar_ArgWithNestedQueryParams_Result struct from its Thrift-level
// representation. The Thrift-level representation may be obtained
// from a ThriftRW protocol implementation.
//
// An error is returned if we were unable to build a Bar_ArgWithNestedQueryParams_Result struct
// from the provided intermediate representation.
//
//   x, err := binaryProtocol.Decode(reader, wire.TStruct)
//   if err != nil {
//     return nil, err
//   }
//
//   var v Bar_ArgWithNestedQueryParams_Result
//   if err := v.FromWire(x); err != nil {
//     return nil, err
//   }
//   return &v, nil
func (v *Bar_ArgWithNestedQueryParams_Result) FromWire(w wire.Value) error {
	var err error

	for _, field := range w.GetStruct().Fields {
		switch field.ID {
		case 0:
			if field.Value.Type() == wire.TStruct {
				v.Success, err = _BarResponse_Read(field.Value)
				if err != nil {
					return err
				}

			}
		}
	}

	count := 0
	if v.Success != nil {
		count++
	}
	if count != 1 {
		return fmt.Errorf("Bar_ArgWithNestedQueryParams_Result should have exactly one field: got %v fields", count)
	}

	return nil
}

// String returns a readable string representation of a Bar_ArgWithNestedQueryParams_Result
// struct.
func (v *Bar_ArgWithNestedQueryParams_Result) String() string {
	if v == nil {
		return "<nil>"
	}

	var fields [1]string
	i := 0
	if v.Success != nil {
		fields[i] = fmt.Sprintf("Success: %v", v.Success)
		i++
	}

	return fmt.Sprintf("Bar_ArgWithNestedQueryParams_Result{%v}", strings.Join(fields[:i], ", "))
}

// Equals returns true if all the fields of this Bar_ArgWithNestedQueryParams_Result match the
// provided Bar_ArgWithNestedQueryParams_Result.
//
// This function performs a deep comparison.
func (v *Bar_ArgWithNestedQueryParams_Result) Equals(rhs *Bar_ArgWithNestedQueryParams_Result) bool {
	if v == nil {
		return rhs == nil
	} else if rhs == nil {
		return false
	}
	if !((v.Success == nil && rhs.Success == nil) || (v.Success != nil && rhs.Success != nil && v.Success.Equals(rhs.Success))) {
		return false
	}

	return true
}

// MarshalLogObject implements zapcore.ObjectMarshaler, enabling
// fast logging of Bar_ArgWithNestedQueryParams_Result.
func (v *Bar_ArgWithNestedQueryParams_Result) MarshalLogObject(enc zapcore.ObjectEncoder) (err error) {
	if v == nil {
		return nil
	}
	if v.Success != nil {
		err = multierr.Append(err, enc.AddObject("success", v.Success))
	}
	return err
}

// GetSuccess returns the value of Success if it is set or its
// zero value if it is unset.
func (v *Bar_ArgWithNestedQueryParams_Result) GetSuccess() (o *BarResponse) {
	if v != nil && v.Success != nil {
		return v.Success
	}

	return
}

// IsSetSuccess returns true if Success is not nil.
func (v *Bar_ArgWithNestedQueryParams_Result) IsSetSuccess() bool {
	return v != nil && v.Success != nil
}

// MethodName returns the name of the Thrift function as specified in
// the IDL, for which this struct represent the result.
//
// This will always be "argWithNestedQueryParams" for this struct.
func (v *Bar_ArgWithNestedQueryParams_Result) MethodName() string {
	return "argWithNestedQueryParams"
}

// EnvelopeType returns the kind of value inside this struct.
//
// This will always be Reply for this struct.
func (v *Bar_ArgWithNestedQueryParams_Result) EnvelopeType() wire.EnvelopeType {
	return wire.Reply
}

// Bar_ArgWithParams_Args represents the arguments for the Bar.argWithParams function.
//
// The arguments for argWithParams are sent and received over the wire as this struct.
type Bar_ArgWithParams_Args struct {
	UUID   string        `json:"-"`
	Params *ParamsStruct `json:"params,omitempty"`
}

// ToWire translates a Bar_ArgWithParams_Args struct into a Thrift-level intermediate
// representation. This intermediate representation may be serialized
// into bytes using a ThriftRW protocol implementation.
//
// An error is returned if the struct or any of its fields failed to
// validate.
//
//   x, err := v.ToWire()
//   if err != nil {
//     return err
//   }
//
//   if err := binaryProtocol.Encode(x, writer); err != nil {
//     return err
//   }
func (v *Bar_ArgWithParams_Args) ToWire() (wire.Value, error) {
	var (
		fields [2]wire.Field
		i      int = 0
		w      wire.Value
		err    error
	)

	w, err = wire.NewValueString(v.UUID), error(nil)
	if err != nil {
		return w, err
	}
	fields[i] = wire.Field{ID: 1, Value: w}
	i++
	if v.Params != nil {
		w, err = v.Params.ToWire()
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 2, Value: w}
		i++
	}

	return wire.NewValueStruct(wire.Struct{Fields: fields[:i]}), nil
}

func _ParamsStruct_Read(w wire.Value) (*ParamsStruct, error) {
	var v ParamsStruct
	err := v.FromWire(w)
	return &v, err
}

// FromWire deserializes a Bar_ArgWithParams_Args struct from its Thrift-level
// representation. The Thrift-level representation may be obtained
// from a ThriftRW protocol implementation.
//
// An error is returned if we were unable to build a Bar_ArgWithParams_Args struct
// from the provided intermediate representation.
//
//   x, err := binaryProtocol.Decode(reader, wire.TStruct)
//   if err != nil {
//     return nil, err
//   }
//
//   var v Bar_ArgWithParams_Args
//   if err := v.FromWire(x); err != nil {
//     return nil, err
//   }
//   return &v, nil
func (v *Bar_ArgWithParams_Args) FromWire(w wire.Value) error {
	var err error

	uuidIsSet := false

	for _, field := range w.GetStruct().Fields {
		switch field.ID {
		case 1:
			if field.Value.Type() == wire.TBinary {
				v.UUID, err = field.Value.GetString(), error(nil)
				if err != nil {
					return err
				}
				uuidIsSet = true
			}
		case 2:
			if field.Value.Type() == wire.TStruct {
				v.Params, err = _ParamsStruct_Read(field.Value)
				if err != nil {
					return err
				}

			}
		}
	}

	if !uuidIsSet {
		return errors.New("field UUID of Bar_ArgWithParams_Args is required")
	}

	return nil
}

// String returns a readable string representation of a Bar_ArgWithParams_Args
// struct.
func (v *Bar_ArgWithParams_Args) String() string {
	if v == nil {
		return "<nil>"
	}

	var fields [2]string
	i := 0
	fields[i] = fmt.Sprintf("UUID: %v", v.UUID)
	i++
	if v.Params != nil {
		fields[i] = fmt.Sprintf("Params: %v", v.Params)
		i++
	}

	return fmt.Sprintf("Bar_ArgWithParams_Args{%v}", strings.Join(fields[:i], ", "))
}

// Equals returns true if all the fields of this Bar_ArgWithParams_Args match the
// provided Bar_ArgWithParams_Args.
//
// This function performs a deep comparison.
func (v *Bar_ArgWithParams_Args) Equals(rhs *Bar_ArgWithParams_Args) bool {
	if v == nil {
		return rhs == nil
	} else if rhs == nil {
		return false
	}
	if !(v.UUID == rhs.UUID) {
		return false
	}
	if !((v.Params == nil && rhs.Params == nil) || (v.Params != nil && rhs.Params != nil && v.Params.Equals(rhs.Params))) {
		return false
	}

	return true
}

// MarshalLogObject implements zapcore.ObjectMarshaler, enabling
// fast logging of Bar_ArgWithParams_Args.
func (v *Bar_ArgWithParams_Args) MarshalLogObject(enc zapcore.ObjectEncoder) (err error) {
	if v == nil {
		return nil
	}
	enc.AddString("uuid", v.UUID)
	if v.Params != nil {
		err = multierr.Append(err, enc.AddObject("params", v.Params))
	}
	return err
}

// GetUUID returns the value of UUID if it is set or its
// zero value if it is unset.
func (v *Bar_ArgWithParams_Args) GetUUID() (o string) {
	if v != nil {
		o = v.UUID
	}
	return
}

// GetParams returns the value of Params if it is set or its
// zero value if it is unset.
func (v *Bar_ArgWithParams_Args) GetParams() (o *ParamsStruct) {
	if v != nil && v.Params != nil {
		return v.Params
	}

	return
}

// IsSetParams returns true if Params is not nil.
func (v *Bar_ArgWithParams_Args) IsSetParams() bool {
	return v != nil && v.Params != nil
}

// MethodName returns the name of the Thrift function as specified in
// the IDL, for which this struct represent the arguments.
//
// This will always be "argWithParams" for this struct.
func (v *Bar_ArgWithParams_Args) MethodName() string {
	return "argWithParams"
}

// EnvelopeType returns the kind of value inside this struct.
//
// This will always be Call for this struct.
func (v *Bar_ArgWithParams_Args) EnvelopeType() wire.EnvelopeType {
	return wire.Call
}

// Bar_ArgWithParams_Helper provides functions that aid in handling the
// parameters and return values of the Bar.argWithParams
// function.
var Bar_ArgWithParams_Helper = struct {
	// Args accepts the parameters of argWithParams in-order and returns
	// the arguments struct for the function.
	Args func(
		uuid string,
		params *ParamsStruct,
	) *Bar_ArgWithParams_Args

	// IsException returns true if the given error can be thrown
	// by argWithParams.
	//
	// An error can be thrown by argWithParams only if the
	// corresponding exception type was mentioned in the 'throws'
	// section for it in the Thrift file.
	IsException func(error) bool

	// WrapResponse returns the result struct for argWithParams
	// given its return value and error.
	//
	// This allows mapping values and errors returned by
	// argWithParams into a serializable result struct.
	// WrapResponse returns a non-nil error if the provided
	// error cannot be thrown by argWithParams
	//
	//   value, err := argWithParams(args)
	//   result, err := Bar_ArgWithParams_Helper.WrapResponse(value, err)
	//   if err != nil {
	//     return fmt.Errorf("unexpected error from argWithParams: %v", err)
	//   }
	//   serialize(result)
	WrapResponse func(*BarResponse, error) (*Bar_ArgWithParams_Result, error)

	// UnwrapResponse takes the result struct for argWithParams
	// and returns the value or error returned by it.
	//
	// The error is non-nil only if argWithParams threw an
	// exception.
	//
	//   result := deserialize(bytes)
	//   value, err := Bar_ArgWithParams_Helper.UnwrapResponse(result)
	UnwrapResponse func(*Bar_ArgWithParams_Result) (*BarResponse, error)
}{}

func init() {
	Bar_ArgWithParams_Helper.Args = func(
		uuid string,
		params *ParamsStruct,
	) *Bar_ArgWithParams_Args {
		return &Bar_ArgWithParams_Args{
			UUID:   uuid,
			Params: params,
		}
	}

	Bar_ArgWithParams_Helper.IsException = func(err error) bool {
		switch err.(type) {
		default:
			return false
		}
	}

	Bar_ArgWithParams_Helper.WrapResponse = func(success *BarResponse, err error) (*Bar_ArgWithParams_Result, error) {
		if err == nil {
			return &Bar_ArgWithParams_Result{Success: success}, nil
		}

		return nil, err
	}
	Bar_ArgWithParams_Helper.UnwrapResponse = func(result *Bar_ArgWithParams_Result) (success *BarResponse, err error) {

		if result.Success != nil {
			success = result.Success
			return
		}

		err = errors.New("expected a non-void result")
		return
	}

}

// Bar_ArgWithParams_Result represents the result of a Bar.argWithParams function call.
//
// The result of a argWithParams execution is sent and received over the wire as this struct.
//
// Success is set only if the function did not throw an exception.
type Bar_ArgWithParams_Result struct {
	// Value returned by argWithParams after a successful execution.
	Success *BarResponse `json:"success,omitempty"`
}

// ToWire translates a Bar_ArgWithParams_Result struct into a Thrift-level intermediate
// representation. This intermediate representation may be serialized
// into bytes using a ThriftRW protocol implementation.
//
// An error is returned if the struct or any of its fields failed to
// validate.
//
//   x, err := v.ToWire()
//   if err != nil {
//     return err
//   }
//
//   if err := binaryProtocol.Encode(x, writer); err != nil {
//     return err
//   }
func (v *Bar_ArgWithParams_Result) ToWire() (wire.Value, error) {
	var (
		fields [1]wire.Field
		i      int = 0
		w      wire.Value
		err    error
	)

	if v.Success != nil {
		w, err = v.Success.ToWire()
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 0, Value: w}
		i++
	}

	if i != 1 {
		return wire.Value{}, fmt.Errorf("Bar_ArgWithParams_Result should have exactly one field: got %v fields", i)
	}

	return wire.NewValueStruct(wire.Struct{Fields: fields[:i]}), nil
}

// FromWire deserializes a Bar_ArgWithParams_Result struct from its Thrift-level
// representation. The Thrift-level representation may be obtained
// from a ThriftRW protocol implementation.
//
// An error is returned if we were unable to build a Bar_ArgWithParams_Result struct
// from the provided intermediate representation.
//
//   x, err := binaryProtocol.Decode(reader, wire.TStruct)
//   if err != nil {
//     return nil, err
//   }
//
//   var v Bar_ArgWithParams_Result
//   if err := v.FromWire(x); err != nil {
//     return nil, err
//   }
//   return &v, nil
func (v *Bar_ArgWithParams_Result) FromWire(w wire.Value) error {
	var err error

	for _, field := range w.GetStruct().Fields {
		switch field.ID {
		case 0:
			if field.Value.Type() == wire.TStruct {
				v.Success, err = _BarResponse_Read(field.Value)
				if err != nil {
					return err
				}

			}
		}
	}

	count := 0
	if v.Success != nil {
		count++
	}
	if count != 1 {
		return fmt.Errorf("Bar_ArgWithParams_Result should have exactly one field: got %v fields", count)
	}

	return nil
}

// String returns a readable string representation of a Bar_ArgWithParams_Result
// struct.
func (v *Bar_ArgWithParams_Result) String() string {
	if v == nil {
		return "<nil>"
	}

	var fields [1]string
	i := 0
	if v.Success != nil {
		fields[i] = fmt.Sprintf("Success: %v", v.Success)
		i++
	}

	return fmt.Sprintf("Bar_ArgWithParams_Result{%v}", strings.Join(fields[:i], ", "))
}

// Equals returns true if all the fields of this Bar_ArgWithParams_Result match the
// provided Bar_ArgWithParams_Result.
//
// This function performs a deep comparison.
func (v *Bar_ArgWithParams_Result) Equals(rhs *Bar_ArgWithParams_Result) bool {
	if v == nil {
		return rhs == nil
	} else if rhs == nil {
		return false
	}
	if !((v.Success == nil && rhs.Success == nil) || (v.Success != nil && rhs.Success != nil && v.Success.Equals(rhs.Success))) {
		return false
	}

	return true
}

// MarshalLogObject implements zapcore.ObjectMarshaler, enabling
// fast logging of Bar_ArgWithParams_Result.
func (v *Bar_ArgWithParams_Result) MarshalLogObject(enc zapcore.ObjectEncoder) (err error) {
	if v == nil {
		return nil
	}
	if v.Success != nil {
		err = multierr.Append(err, enc.AddObject("success", v.Success))
	}
	return err
}

// GetSuccess returns the value of Success if it is set or its
// zero value if it is unset.
func (v *Bar_ArgWithParams_Result) GetSuccess() (o *BarResponse) {
	if v != nil && v.Success != nil {
		return v.Success
	}

	return
}

// IsSetSuccess returns true if Success is not nil.
func (v *Bar_ArgWithParams_Result) IsSetSuccess() bool {
	return v != nil && v.Success != nil
}

// MethodName returns the name of the Thrift function as specified in
// the IDL, for which this struct represent the result.
//
// This will always be "argWithParams" for this struct.
func (v *Bar_ArgWithParams_Result) MethodName() string {
	return "argWithParams"
}

// EnvelopeType returns the kind of value inside this struct.
//
// This will always be Reply for this struct.
func (v *Bar_ArgWithParams_Result) EnvelopeType() wire.EnvelopeType {
	return wire.Reply
}

// Bar_ArgWithParamsAndDuplicateFields_Args represents the arguments for the Bar.argWithParamsAndDuplicateFields function.
//
// The arguments for argWithParamsAndDuplicateFields are sent and received over the wire as this struct.
type Bar_ArgWithParamsAndDuplicateFields_Args struct {
	Request    *RequestWithDuplicateType `json:"request,required"`
	EntityUUID string                    `json:"entityUUID,required"`
}

// ToWire translates a Bar_ArgWithParamsAndDuplicateFields_Args struct into a Thrift-level intermediate
// representation. This intermediate representation may be serialized
// into bytes using a ThriftRW protocol implementation.
//
// An error is returned if the struct or any of its fields failed to
// validate.
//
//   x, err := v.ToWire()
//   if err != nil {
//     return err
//   }
//
//   if err := binaryProtocol.Encode(x, writer); err != nil {
//     return err
//   }
func (v *Bar_ArgWithParamsAndDuplicateFields_Args) ToWire() (wire.Value, error) {
	var (
		fields [2]wire.Field
		i      int = 0
		w      wire.Value
		err    error
	)

	if v.Request == nil {
		return w, errors.New("field Request of Bar_ArgWithParamsAndDuplicateFields_Args is required")
	}
	w, err = v.Request.ToWire()
	if err != nil {
		return w, err
	}
	fields[i] = wire.Field{ID: 1, Value: w}
	i++

	w, err = wire.NewValueString(v.EntityUUID), error(nil)
	if err != nil {
		return w, err
	}
	fields[i] = wire.Field{ID: 2, Value: w}
	i++

	return wire.NewValueStruct(wire.Struct{Fields: fields[:i]}), nil
}

func _RequestWithDuplicateType_Read(w wire.Value) (*RequestWithDuplicateType, error) {
	var v RequestWithDuplicateType
	err := v.FromWire(w)
	return &v, err
}

// FromWire deserializes a Bar_ArgWithParamsAndDuplicateFields_Args struct from its Thrift-level
// representation. The Thrift-level representation may be obtained
// from a ThriftRW protocol implementation.
//
// An error is returned if we were unable to build a Bar_ArgWithParamsAndDuplicateFields_Args struct
// from the provided intermediate representation.
//
//   x, err := binaryProtocol.Decode(reader, wire.TStruct)
//   if err != nil {
//     return nil, err
//   }
//
//   var v Bar_ArgWithParamsAndDuplicateFields_Args
//   if err := v.FromWire(x); err != nil {
//     return nil, err
//   }
//   return &v, nil
func (v *Bar_ArgWithParamsAndDuplicateFields_Args) FromWire(w wire.Value) error {
	var err error

	requestIsSet := false
	entityUUIDIsSet := false

	for _, field := range w.GetStruct().Fields {
		switch field.ID {
		case 1:
			if field.Value.Type() == wire.TStruct {
				v.Request, err = _RequestWithDuplicateType_Read(field.Value)
				if err != nil {
					return err
				}
				requestIsSet = true
			}
		case 2:
			if field.Value.Type() == wire.TBinary {
				v.EntityUUID, err = field.Value.GetString(), error(nil)
				if err != nil {
					return err
				}
				entityUUIDIsSet = true
			}
		}
	}

	if !requestIsSet {
		return errors.New("field Request of Bar_ArgWithParamsAndDuplicateFields_Args is required")
	}

	if !entityUUIDIsSet {
		return errors.New("field EntityUUID of Bar_ArgWithParamsAndDuplicateFields_Args is required")
	}

	return nil
}

// String returns a readable string representation of a Bar_ArgWithParamsAndDuplicateFields_Args
// struct.
func (v *Bar_ArgWithParamsAndDuplicateFields_Args) String() string {
	if v == nil {
		return "<nil>"
	}

	var fields [2]string
	i := 0
	fields[i] = fmt.Sprintf("Request: %v", v.Request)
	i++
	fields[i] = fmt.Sprintf("EntityUUID: %v", v.EntityUUID)
	i++

	return fmt.Sprintf("Bar_ArgWithParamsAndDuplicateFields_Args{%v}", strings.Join(fields[:i], ", "))
}

// Equals returns true if all the fields of this Bar_ArgWithParamsAndDuplicateFields_Args match the
// provided Bar_ArgWithParamsAndDuplicateFields_Args.
//
// This function performs a deep comparison.
func (v *Bar_ArgWithParamsAndDuplicateFields_Args) Equals(rhs *Bar_ArgWithParamsAndDuplicateFields_Args) bool {
	if v == nil {
		return rhs == nil
	} else if rhs == nil {
		return false
	}
	if !v.Request.Equals(rhs.Request) {
		return false
	}
	if !(v.EntityUUID == rhs.EntityUUID) {
		return false
	}

	return true
}

// MarshalLogObject implements zapcore.ObjectMarshaler, enabling
// fast logging of Bar_ArgWithParamsAndDuplicateFields_Args.
func (v *Bar_ArgWithParamsAndDuplicateFields_Args) MarshalLogObject(enc zapcore.ObjectEncoder) (err error) {
	if v == nil {
		return nil
	}
	err = multierr.Append(err, enc.AddObject("request", v.Request))
	enc.AddString("entityUUID", v.EntityUUID)
	return err
}

// GetRequest returns the value of Request if it is set or its
// zero value if it is unset.
func (v *Bar_ArgWithParamsAndDuplicateFields_Args) GetRequest() (o *RequestWithDuplicateType) {
	if v != nil {
		o = v.Request
	}
	return
}

// IsSetRequest returns true if Request is not nil.
func (v *Bar_ArgWithParamsAndDuplicateFields_Args) IsSetRequest() bool {
	return v != nil && v.Request != nil
}

// GetEntityUUID returns the value of EntityUUID if it is set or its
// zero value if it is unset.
func (v *Bar_ArgWithParamsAndDuplicateFields_Args) GetEntityUUID() (o string) {
	if v != nil {
		o = v.EntityUUID
	}
	return
}

// MethodName returns the name of the Thrift function as specified in
// the IDL, for which this struct represent the arguments.
//
// This will always be "argWithParamsAndDuplicateFields" for this struct.
func (v *Bar_ArgWithParamsAndDuplicateFields_Args) MethodName() string {
	return "argWithParamsAndDuplicateFields"
}

// EnvelopeType returns the kind of value inside this struct.
//
// This will always be Call for this struct.
func (v *Bar_ArgWithParamsAndDuplicateFields_Args) EnvelopeType() wire.EnvelopeType {
	return wire.Call
}

// Bar_ArgWithParamsAndDuplicateFields_Helper provides functions that aid in handling the
// parameters and return values of the Bar.argWithParamsAndDuplicateFields
// function.
var Bar_ArgWithParamsAndDuplicateFields_Helper = struct {
	// Args accepts the parameters of argWithParamsAndDuplicateFields in-order and returns
	// the arguments struct for the function.
	Args func(
		request *RequestWithDuplicateType,
		entityUUID string,
	) *Bar_ArgWithParamsAndDuplicateFields_Args

	// IsException returns true if the given error can be thrown
	// by argWithParamsAndDuplicateFields.
	//
	// An error can be thrown by argWithParamsAndDuplicateFields only if the
	// corresponding exception type was mentioned in the 'throws'
	// section for it in the Thrift file.
	IsException func(error) bool

	// WrapResponse returns the result struct for argWithParamsAndDuplicateFields
	// given its return value and error.
	//
	// This allows mapping values and errors returned by
	// argWithParamsAndDuplicateFields into a serializable result struct.
	// WrapResponse returns a non-nil error if the provided
	// error cannot be thrown by argWithParamsAndDuplicateFields
	//
	//   value, err := argWithParamsAndDuplicateFields(args)
	//   result, err := Bar_ArgWithParamsAndDuplicateFields_Helper.WrapResponse(value, err)
	//   if err != nil {
	//     return fmt.Errorf("unexpected error from argWithParamsAndDuplicateFields: %v", err)
	//   }
	//   serialize(result)
	WrapResponse func(*BarResponse, error) (*Bar_ArgWithParamsAndDuplicateFields_Result, error)

	// UnwrapResponse takes the result struct for argWithParamsAndDuplicateFields
	// and returns the value or error returned by it.
	//
	// The error is non-nil only if argWithParamsAndDuplicateFields threw an
	// exception.
	//
	//   result := deserialize(bytes)
	//   value, err := Bar_ArgWithParamsAndDuplicateFields_Helper.UnwrapResponse(result)
	UnwrapResponse func(*Bar_ArgWithParamsAndDuplicateFields_Result) (*BarResponse, error)
}{}

func init() {
	Bar_ArgWithParamsAndDuplicateFields_Helper.Args = func(
		request *RequestWithDuplicateType,
		entityUUID string,
	) *Bar_ArgWithParamsAndDuplicateFields_Args {
		return &Bar_ArgWithParamsAndDuplicateFields_Args{
			Request:    request,
			EntityUUID: entityUUID,
		}
	}

	Bar_ArgWithParamsAndDuplicateFields_Helper.IsException = func(err error) bool {
		switch err.(type) {
		default:
			return false
		}
	}

	Bar_ArgWithParamsAndDuplicateFields_Helper.WrapResponse = func(success *BarResponse, err error) (*Bar_ArgWithParamsAndDuplicateFields_Result, error) {
		if err == nil {
			return &Bar_ArgWithParamsAndDuplicateFields_Result{Success: success}, nil
		}

		return nil, err
	}
	Bar_ArgWithParamsAndDuplicateFields_Helper.UnwrapResponse = func(result *Bar_ArgWithParamsAndDuplicateFields_Result) (success *BarResponse, err error) {

		if result.Success != nil {
			success = result.Success
			return
		}

		err = errors.New("expected a non-void result")
		return
	}

}

// Bar_ArgWithParamsAndDuplicateFields_Result represents the result of a Bar.argWithParamsAndDuplicateFields function call.
//
// The result of a argWithParamsAndDuplicateFields execution is sent and received over the wire as this struct.
//
// Success is set only if the function did not throw an exception.
type Bar_ArgWithParamsAndDuplicateFields_Result struct {
	// Value returned by argWithParamsAndDuplicateFields after a successful execution.
	Success *BarResponse `json:"success,omitempty"`
}

// ToWire translates a Bar_ArgWithParamsAndDuplicateFields_Result struct into a Thrift-level intermediate
// representation. This intermediate representation may be serialized
// into bytes using a ThriftRW protocol implementation.
//
// An error is returned if the struct or any of its fields failed to
// validate.
//
//   x, err := v.ToWire()
//   if err != nil {
//     return err
//   }
//
//   if err := binaryProtocol.Encode(x, writer); err != nil {
//     return err
//   }
func (v *Bar_ArgWithParamsAndDuplicateFields_Result) ToWire() (wire.Value, error) {
	var (
		fields [1]wire.Field
		i      int = 0
		w      wire.Value
		err    error
	)

	if v.Success != nil {
		w, err = v.Success.ToWire()
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 0, Value: w}
		i++
	}

	if i != 1 {
		return wire.Value{}, fmt.Errorf("Bar_ArgWithParamsAndDuplicateFields_Result should have exactly one field: got %v fields", i)
	}

	return wire.NewValueStruct(wire.Struct{Fields: fields[:i]}), nil
}

// FromWire deserializes a Bar_ArgWithParamsAndDuplicateFields_Result struct from its Thrift-level
// representation. The Thrift-level representation may be obtained
// from a ThriftRW protocol implementation.
//
// An error is returned if we were unable to build a Bar_ArgWithParamsAndDuplicateFields_Result struct
// from the provided intermediate representation.
//
//   x, err := binaryProtocol.Decode(reader, wire.TStruct)
//   if err != nil {
//     return nil, err
//   }
//
//   var v Bar_ArgWithParamsAndDuplicateFields_Result
//   if err := v.FromWire(x); err != nil {
//     return nil, err
//   }
//   return &v, nil
func (v *Bar_ArgWithParamsAndDuplicateFields_Result) FromWire(w wire.Value) error {
	var err error

	for _, field := range w.GetStruct().Fields {
		switch field.ID {
		case 0:
			if field.Value.Type() == wire.TStruct {
				v.Success, err = _BarResponse_Read(field.Value)
				if err != nil {
					return err
				}

			}
		}
	}

	count := 0
	if v.Success != nil {
		count++
	}
	if count != 1 {
		return fmt.Errorf("Bar_ArgWithParamsAndDuplicateFields_Result should have exactly one field: got %v fields", count)
	}

	return nil
}

// String returns a readable string representation of a Bar_ArgWithParamsAndDuplicateFields_Result
// struct.
func (v *Bar_ArgWithParamsAndDuplicateFields_Result) String() string {
	if v == nil {
		return "<nil>"
	}

	var fields [1]string
	i := 0
	if v.Success != nil {
		fields[i] = fmt.Sprintf("Success: %v", v.Success)
		i++
	}

	return fmt.Sprintf("Bar_ArgWithParamsAndDuplicateFields_Result{%v}", strings.Join(fields[:i], ", "))
}

// Equals returns true if all the fields of this Bar_ArgWithParamsAndDuplicateFields_Result match the
// provided Bar_ArgWithParamsAndDuplicateFields_Result.
//
// This function performs a deep comparison.
func (v *Bar_ArgWithParamsAndDuplicateFields_Result) Equals(rhs *Bar_ArgWithParamsAndDuplicateFields_Result) bool {
	if v == nil {
		return rhs == nil
	} else if rhs == nil {
		return false
	}
	if !((v.Success == nil && rhs.Success == nil) || (v.Success != nil && rhs.Success != nil && v.Success.Equals(rhs.Success))) {
		return false
	}

	return true
}

// MarshalLogObject implements zapcore.ObjectMarshaler, enabling
// fast logging of Bar_ArgWithParamsAndDuplicateFields_Result.
func (v *Bar_ArgWithParamsAndDuplicateFields_Result) MarshalLogObject(enc zapcore.ObjectEncoder) (err error) {
	if v == nil {
		return nil
	}
	if v.Success != nil {
		err = multierr.Append(err, enc.AddObject("success", v.Success))
	}
	return err
}

// GetSuccess returns the value of Success if it is set or its
// zero value if it is unset.
func (v *Bar_ArgWithParamsAndDuplicateFields_Result) GetSuccess() (o *BarResponse) {
	if v != nil && v.Success != nil {
		return v.Success
	}

	return
}

// IsSetSuccess returns true if Success is not nil.
func (v *Bar_ArgWithParamsAndDuplicateFields_Result) IsSetSuccess() bool {
	return v != nil && v.Success != nil
}

// MethodName returns the name of the Thrift function as specified in
// the IDL, for which this struct represent the result.
//
// This will always be "argWithParamsAndDuplicateFields" for this struct.
func (v *Bar_ArgWithParamsAndDuplicateFields_Result) MethodName() string {
	return "argWithParamsAndDuplicateFields"
}

// EnvelopeType returns the kind of value inside this struct.
//
// This will always be Reply for this struct.
func (v *Bar_ArgWithParamsAndDuplicateFields_Result) EnvelopeType() wire.EnvelopeType {
	return wire.Reply
}

// Bar_ArgWithQueryHeader_Args represents the arguments for the Bar.argWithQueryHeader function.
//
// The arguments for argWithQueryHeader are sent and received over the wire as this struct.
type Bar_ArgWithQueryHeader_Args struct {
	UserUUID *string `json:"userUUID,omitempty"`
}

// ToWire translates a Bar_ArgWithQueryHeader_Args struct into a Thrift-level intermediate
// representation. This intermediate representation may be serialized
// into bytes using a ThriftRW protocol implementation.
//
// An error is returned if the struct or any of its fields failed to
// validate.
//
//   x, err := v.ToWire()
//   if err != nil {
//     return err
//   }
//
//   if err := binaryProtocol.Encode(x, writer); err != nil {
//     return err
//   }
func (v *Bar_ArgWithQueryHeader_Args) ToWire() (wire.Value, error) {
	var (
		fields [1]wire.Field
		i      int = 0
		w      wire.Value
		err    error
	)

	if v.UserUUID != nil {
		w, err = wire.NewValueString(*(v.UserUUID)), error(nil)
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 1, Value: w}
		i++
	}

	return wire.NewValueStruct(wire.Struct{Fields: fields[:i]}), nil
}

// FromWire deserializes a Bar_ArgWithQueryHeader_Args struct from its Thrift-level
// representation. The Thrift-level representation may be obtained
// from a ThriftRW protocol implementation.
//
// An error is returned if we were unable to build a Bar_ArgWithQueryHeader_Args struct
// from the provided intermediate representation.
//
//   x, err := binaryProtocol.Decode(reader, wire.TStruct)
//   if err != nil {
//     return nil, err
//   }
//
//   var v Bar_ArgWithQueryHeader_Args
//   if err := v.FromWire(x); err != nil {
//     return nil, err
//   }
//   return &v, nil
func (v *Bar_ArgWithQueryHeader_Args) FromWire(w wire.Value) error {
	var err error

	for _, field := range w.GetStruct().Fields {
		switch field.ID {
		case 1:
			if field.Value.Type() == wire.TBinary {
				var x string
				x, err = field.Value.GetString(), error(nil)
				v.UserUUID = &x
				if err != nil {
					return err
				}

			}
		}
	}

	return nil
}

// String returns a readable string representation of a Bar_ArgWithQueryHeader_Args
// struct.
func (v *Bar_ArgWithQueryHeader_Args) String() string {
	if v == nil {
		return "<nil>"
	}

	var fields [1]string
	i := 0
	if v.UserUUID != nil {
		fields[i] = fmt.Sprintf("UserUUID: %v", *(v.UserUUID))
		i++
	}

	return fmt.Sprintf("Bar_ArgWithQueryHeader_Args{%v}", strings.Join(fields[:i], ", "))
}

// Equals returns true if all the fields of this Bar_ArgWithQueryHeader_Args match the
// provided Bar_ArgWithQueryHeader_Args.
//
// This function performs a deep comparison.
func (v *Bar_ArgWithQueryHeader_Args) Equals(rhs *Bar_ArgWithQueryHeader_Args) bool {
	if v == nil {
		return rhs == nil
	} else if rhs == nil {
		return false
	}
	if !_String_EqualsPtr(v.UserUUID, rhs.UserUUID) {
		return false
	}

	return true
}

// MarshalLogObject implements zapcore.ObjectMarshaler, enabling
// fast logging of Bar_ArgWithQueryHeader_Args.
func (v *Bar_ArgWithQueryHeader_Args) MarshalLogObject(enc zapcore.ObjectEncoder) (err error) {
	if v == nil {
		return nil
	}
	if v.UserUUID != nil {
		enc.AddString("userUUID", *v.UserUUID)
	}
	return err
}

// GetUserUUID returns the value of UserUUID if it is set or its
// zero value if it is unset.
func (v *Bar_ArgWithQueryHeader_Args) GetUserUUID() (o string) {
	if v != nil && v.UserUUID != nil {
		return *v.UserUUID
	}

	return
}

// IsSetUserUUID returns true if UserUUID is not nil.
func (v *Bar_ArgWithQueryHeader_Args) IsSetUserUUID() bool {
	return v != nil && v.UserUUID != nil
}

// MethodName returns the name of the Thrift function as specified in
// the IDL, for which this struct represent the arguments.
//
// This will always be "argWithQueryHeader" for this struct.
func (v *Bar_ArgWithQueryHeader_Args) MethodName() string {
	return "argWithQueryHeader"
}

// EnvelopeType returns the kind of value inside this struct.
//
// This will always be Call for this struct.
func (v *Bar_ArgWithQueryHeader_Args) EnvelopeType() wire.EnvelopeType {
	return wire.Call
}

// Bar_ArgWithQueryHeader_Helper provides functions that aid in handling the
// parameters and return values of the Bar.argWithQueryHeader
// function.
var Bar_ArgWithQueryHeader_Helper = struct {
	// Args accepts the parameters of argWithQueryHeader in-order and returns
	// the arguments struct for the function.
	Args func(
		userUUID *string,
	) *Bar_ArgWithQueryHeader_Args

	// IsException returns true if the given error can be thrown
	// by argWithQueryHeader.
	//
	// An error can be thrown by argWithQueryHeader only if the
	// corresponding exception type was mentioned in the 'throws'
	// section for it in the Thrift file.
	IsException func(error) bool

	// WrapResponse returns the result struct for argWithQueryHeader
	// given its return value and error.
	//
	// This allows mapping values and errors returned by
	// argWithQueryHeader into a serializable result struct.
	// WrapResponse returns a non-nil error if the provided
	// error cannot be thrown by argWithQueryHeader
	//
	//   value, err := argWithQueryHeader(args)
	//   result, err := Bar_ArgWithQueryHeader_Helper.WrapResponse(value, err)
	//   if err != nil {
	//     return fmt.Errorf("unexpected error from argWithQueryHeader: %v", err)
	//   }
	//   serialize(result)
	WrapResponse func(*BarResponse, error) (*Bar_ArgWithQueryHeader_Result, error)

	// UnwrapResponse takes the result struct for argWithQueryHeader
	// and returns the value or error returned by it.
	//
	// The error is non-nil only if argWithQueryHeader threw an
	// exception.
	//
	//   result := deserialize(bytes)
	//   value, err := Bar_ArgWithQueryHeader_Helper.UnwrapResponse(result)
	UnwrapResponse func(*Bar_ArgWithQueryHeader_Result) (*BarResponse, error)
}{}

func init() {
	Bar_ArgWithQueryHeader_Helper.Args = func(
		userUUID *string,
	) *Bar_ArgWithQueryHeader_Args {
		return &Bar_ArgWithQueryHeader_Args{
			UserUUID: userUUID,
		}
	}

	Bar_ArgWithQueryHeader_Helper.IsException = func(err error) bool {
		switch err.(type) {
		default:
			return false
		}
	}

	Bar_ArgWithQueryHeader_Helper.WrapResponse = func(success *BarResponse, err error) (*Bar_ArgWithQueryHeader_Result, error) {
		if err == nil {
			return &Bar_ArgWithQueryHeader_Result{Success: success}, nil
		}

		return nil, err
	}
	Bar_ArgWithQueryHeader_Helper.UnwrapResponse = func(result *Bar_ArgWithQueryHeader_Result) (success *BarResponse, err error) {

		if result.Success != nil {
			success = result.Success
			return
		}

		err = errors.New("expected a non-void result")
		return
	}

}

// Bar_ArgWithQueryHeader_Result represents the result of a Bar.argWithQueryHeader function call.
//
// The result of a argWithQueryHeader execution is sent and received over the wire as this struct.
//
// Success is set only if the function did not throw an exception.
type Bar_ArgWithQueryHeader_Result struct {
	// Value returned by argWithQueryHeader after a successful execution.
	Success *BarResponse `json:"success,omitempty"`
}

// ToWire translates a Bar_ArgWithQueryHeader_Result struct into a Thrift-level intermediate
// representation. This intermediate representation may be serialized
// into bytes using a ThriftRW protocol implementation.
//
// An error is returned if the struct or any of its fields failed to
// validate.
//
//   x, err := v.ToWire()
//   if err != nil {
//     return err
//   }
//
//   if err := binaryProtocol.Encode(x, writer); err != nil {
//     return err
//   }
func (v *Bar_ArgWithQueryHeader_Result) ToWire() (wire.Value, error) {
	var (
		fields [1]wire.Field
		i      int = 0
		w      wire.Value
		err    error
	)

	if v.Success != nil {
		w, err = v.Success.ToWire()
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 0, Value: w}
		i++
	}

	if i != 1 {
		return wire.Value{}, fmt.Errorf("Bar_ArgWithQueryHeader_Result should have exactly one field: got %v fields", i)
	}

	return wire.NewValueStruct(wire.Struct{Fields: fields[:i]}), nil
}

// FromWire deserializes a Bar_ArgWithQueryHeader_Result struct from its Thrift-level
// representation. The Thrift-level representation may be obtained
// from a ThriftRW protocol implementation.
//
// An error is returned if we were unable to build a Bar_ArgWithQueryHeader_Result struct
// from the provided intermediate representation.
//
//   x, err := binaryProtocol.Decode(reader, wire.TStruct)
//   if err != nil {
//     return nil, err
//   }
//
//   var v Bar_ArgWithQueryHeader_Result
//   if err := v.FromWire(x); err != nil {
//     return nil, err
//   }
//   return &v, nil
func (v *Bar_ArgWithQueryHeader_Result) FromWire(w wire.Value) error {
	var err error

	for _, field := range w.GetStruct().Fields {
		switch field.ID {
		case 0:
			if field.Value.Type() == wire.TStruct {
				v.Success, err = _BarResponse_Read(field.Value)
				if err != nil {
					return err
				}

			}
		}
	}

	count := 0
	if v.Success != nil {
		count++
	}
	if count != 1 {
		return fmt.Errorf("Bar_ArgWithQueryHeader_Result should have exactly one field: got %v fields", count)
	}

	return nil
}

// String returns a readable string representation of a Bar_ArgWithQueryHeader_Result
// struct.
func (v *Bar_ArgWithQueryHeader_Result) String() string {
	if v == nil {
		return "<nil>"
	}

	var fields [1]string
	i := 0
	if v.Success != nil {
		fields[i] = fmt.Sprintf("Success: %v", v.Success)
		i++
	}

	return fmt.Sprintf("Bar_ArgWithQueryHeader_Result{%v}", strings.Join(fields[:i], ", "))
}

// Equals returns true if all the fields of this Bar_ArgWithQueryHeader_Result match the
// provided Bar_ArgWithQueryHeader_Result.
//
// This function performs a deep comparison.
func (v *Bar_ArgWithQueryHeader_Result) Equals(rhs *Bar_ArgWithQueryHeader_Result) bool {
	if v == nil {
		return rhs == nil
	} else if rhs == nil {
		return false
	}
	if !((v.Success == nil && rhs.Success == nil) || (v.Success != nil && rhs.Success != nil && v.Success.Equals(rhs.Success))) {
		return false
	}

	return true
}

// MarshalLogObject implements zapcore.ObjectMarshaler, enabling
// fast logging of Bar_ArgWithQueryHeader_Result.
func (v *Bar_ArgWithQueryHeader_Result) MarshalLogObject(enc zapcore.ObjectEncoder) (err error) {
	if v == nil {
		return nil
	}
	if v.Success != nil {
		err = multierr.Append(err, enc.AddObject("success", v.Success))
	}
	return err
}

// GetSuccess returns the value of Success if it is set or its
// zero value if it is unset.
func (v *Bar_ArgWithQueryHeader_Result) GetSuccess() (o *BarResponse) {
	if v != nil && v.Success != nil {
		return v.Success
	}

	return
}

// IsSetSuccess returns true if Success is not nil.
func (v *Bar_ArgWithQueryHeader_Result) IsSetSuccess() bool {
	return v != nil && v.Success != nil
}

// MethodName returns the name of the Thrift function as specified in
// the IDL, for which this struct represent the result.
//
// This will always be "argWithQueryHeader" for this struct.
func (v *Bar_ArgWithQueryHeader_Result) MethodName() string {
	return "argWithQueryHeader"
}

// EnvelopeType returns the kind of value inside this struct.
//
// This will always be Reply for this struct.
func (v *Bar_ArgWithQueryHeader_Result) EnvelopeType() wire.EnvelopeType {
	return wire.Reply
}

// Bar_ArgWithQueryParams_Args represents the arguments for the Bar.argWithQueryParams function.
//
// The arguments for argWithQueryParams are sent and received over the wire as this struct.
type Bar_ArgWithQueryParams_Args struct {
	Name     string   `json:"name,required"`
	UserUUID *string  `json:"userUUID,omitempty"`
	Foo      []string `json:"foo,omitempty"`
	Bar      []int8   `json:"bar,required"`
}

type _List_Byte_ValueList []int8

func (v _List_Byte_ValueList) ForEach(f func(wire.Value) error) error {
	for _, x := range v {
		w, err := wire.NewValueI8(x), error(nil)
		if err != nil {
			return err
		}
		err = f(w)
		if err != nil {
			return err
		}
	}
	return nil
}

func (v _List_Byte_ValueList) Size() int {
	return len(v)
}

func (_List_Byte_ValueList) ValueType() wire.Type {
	return wire.TI8
}

func (_List_Byte_ValueList) Close() {}

// ToWire translates a Bar_ArgWithQueryParams_Args struct into a Thrift-level intermediate
// representation. This intermediate representation may be serialized
// into bytes using a ThriftRW protocol implementation.
//
// An error is returned if the struct or any of its fields failed to
// validate.
//
//   x, err := v.ToWire()
//   if err != nil {
//     return err
//   }
//
//   if err := binaryProtocol.Encode(x, writer); err != nil {
//     return err
//   }
func (v *Bar_ArgWithQueryParams_Args) ToWire() (wire.Value, error) {
	var (
		fields [4]wire.Field
		i      int = 0
		w      wire.Value
		err    error
	)

	w, err = wire.NewValueString(v.Name), error(nil)
	if err != nil {
		return w, err
	}
	fields[i] = wire.Field{ID: 1, Value: w}
	i++
	if v.UserUUID != nil {
		w, err = wire.NewValueString(*(v.UserUUID)), error(nil)
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 2, Value: w}
		i++
	}
	if v.Foo != nil {
		w, err = wire.NewValueList(_List_String_ValueList(v.Foo)), error(nil)
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 3, Value: w}
		i++
	}
	if v.Bar == nil {
		return w, errors.New("field Bar of Bar_ArgWithQueryParams_Args is required")
	}
	w, err = wire.NewValueList(_List_Byte_ValueList(v.Bar)), error(nil)
	if err != nil {
		return w, err
	}
	fields[i] = wire.Field{ID: 4, Value: w}
	i++

	return wire.NewValueStruct(wire.Struct{Fields: fields[:i]}), nil
}

func _List_Byte_Read(l wire.ValueList) ([]int8, error) {
	if l.ValueType() != wire.TI8 {
		return nil, nil
	}

	o := make([]int8, 0, l.Size())
	err := l.ForEach(func(x wire.Value) error {
		i, err := x.GetI8(), error(nil)
		if err != nil {
			return err
		}
		o = append(o, i)
		return nil
	})
	l.Close()
	return o, err
}

// FromWire deserializes a Bar_ArgWithQueryParams_Args struct from its Thrift-level
// representation. The Thrift-level representation may be obtained
// from a ThriftRW protocol implementation.
//
// An error is returned if we were unable to build a Bar_ArgWithQueryParams_Args struct
// from the provided intermediate representation.
//
//   x, err := binaryProtocol.Decode(reader, wire.TStruct)
//   if err != nil {
//     return nil, err
//   }
//
//   var v Bar_ArgWithQueryParams_Args
//   if err := v.FromWire(x); err != nil {
//     return nil, err
//   }
//   return &v, nil
func (v *Bar_ArgWithQueryParams_Args) FromWire(w wire.Value) error {
	var err error

	nameIsSet := false

	barIsSet := false

	for _, field := range w.GetStruct().Fields {
		switch field.ID {
		case 1:
			if field.Value.Type() == wire.TBinary {
				v.Name, err = field.Value.GetString(), error(nil)
				if err != nil {
					return err
				}
				nameIsSet = true
			}
		case 2:
			if field.Value.Type() == wire.TBinary {
				var x string
				x, err = field.Value.GetString(), error(nil)
				v.UserUUID = &x
				if err != nil {
					return err
				}

			}
		case 3:
			if field.Value.Type() == wire.TList {
				v.Foo, err = _List_String_Read(field.Value.GetList())
				if err != nil {
					return err
				}

			}
		case 4:
			if field.Value.Type() == wire.TList {
				v.Bar, err = _List_Byte_Read(field.Value.GetList())
				if err != nil {
					return err
				}
				barIsSet = true
			}
		}
	}

	if !nameIsSet {
		return errors.New("field Name of Bar_ArgWithQueryParams_Args is required")
	}

	if !barIsSet {
		return errors.New("field Bar of Bar_ArgWithQueryParams_Args is required")
	}

	return nil
}

// String returns a readable string representation of a Bar_ArgWithQueryParams_Args
// struct.
func (v *Bar_ArgWithQueryParams_Args) String() string {
	if v == nil {
		return "<nil>"
	}

	var fields [4]string
	i := 0
	fields[i] = fmt.Sprintf("Name: %v", v.Name)
	i++
	if v.UserUUID != nil {
		fields[i] = fmt.Sprintf("UserUUID: %v", *(v.UserUUID))
		i++
	}
	if v.Foo != nil {
		fields[i] = fmt.Sprintf("Foo: %v", v.Foo)
		i++
	}
	fields[i] = fmt.Sprintf("Bar: %v", v.Bar)
	i++

	return fmt.Sprintf("Bar_ArgWithQueryParams_Args{%v}", strings.Join(fields[:i], ", "))
}

func _List_Byte_Equals(lhs, rhs []int8) bool {
	if len(lhs) != len(rhs) {
		return false
	}

	for i, lv := range lhs {
		rv := rhs[i]
		if !(lv == rv) {
			return false
		}
	}

	return true
}

// Equals returns true if all the fields of this Bar_ArgWithQueryParams_Args match the
// provided Bar_ArgWithQueryParams_Args.
//
// This function performs a deep comparison.
func (v *Bar_ArgWithQueryParams_Args) Equals(rhs *Bar_ArgWithQueryParams_Args) bool {
	if v == nil {
		return rhs == nil
	} else if rhs == nil {
		return false
	}
	if !(v.Name == rhs.Name) {
		return false
	}
	if !_String_EqualsPtr(v.UserUUID, rhs.UserUUID) {
		return false
	}
	if !((v.Foo == nil && rhs.Foo == nil) || (v.Foo != nil && rhs.Foo != nil && _List_String_Equals(v.Foo, rhs.Foo))) {
		return false
	}
	if !_List_Byte_Equals(v.Bar, rhs.Bar) {
		return false
	}

	return true
}

type _List_Byte_Zapper []int8

// MarshalLogArray implements zapcore.ArrayMarshaler, enabling
// fast logging of _List_Byte_Zapper.
func (l _List_Byte_Zapper) MarshalLogArray(enc zapcore.ArrayEncoder) (err error) {
	for _, v := range l {
		enc.AppendInt8(v)
	}
	return err
}

// MarshalLogObject implements zapcore.ObjectMarshaler, enabling
// fast logging of Bar_ArgWithQueryParams_Args.
func (v *Bar_ArgWithQueryParams_Args) MarshalLogObject(enc zapcore.ObjectEncoder) (err error) {
	if v == nil {
		return nil
	}
	enc.AddString("name", v.Name)
	if v.UserUUID != nil {
		enc.AddString("userUUID", *v.UserUUID)
	}
	if v.Foo != nil {
		err = multierr.Append(err, enc.AddArray("foo", (_List_String_Zapper)(v.Foo)))
	}
	err = multierr.Append(err, enc.AddArray("bar", (_List_Byte_Zapper)(v.Bar)))
	return err
}

// GetName returns the value of Name if it is set or its
// zero value if it is unset.
func (v *Bar_ArgWithQueryParams_Args) GetName() (o string) {
	if v != nil {
		o = v.Name
	}
	return
}

// GetUserUUID returns the value of UserUUID if it is set or its
// zero value if it is unset.
func (v *Bar_ArgWithQueryParams_Args) GetUserUUID() (o string) {
	if v != nil && v.UserUUID != nil {
		return *v.UserUUID
	}

	return
}

// IsSetUserUUID returns true if UserUUID is not nil.
func (v *Bar_ArgWithQueryParams_Args) IsSetUserUUID() bool {
	return v != nil && v.UserUUID != nil
}

// GetFoo returns the value of Foo if it is set or its
// zero value if it is unset.
func (v *Bar_ArgWithQueryParams_Args) GetFoo() (o []string) {
	if v != nil && v.Foo != nil {
		return v.Foo
	}

	return
}

// IsSetFoo returns true if Foo is not nil.
func (v *Bar_ArgWithQueryParams_Args) IsSetFoo() bool {
	return v != nil && v.Foo != nil
}

// GetBar returns the value of Bar if it is set or its
// zero value if it is unset.
func (v *Bar_ArgWithQueryParams_Args) GetBar() (o []int8) {
	if v != nil {
		o = v.Bar
	}
	return
}

// IsSetBar returns true if Bar is not nil.
func (v *Bar_ArgWithQueryParams_Args) IsSetBar() bool {
	return v != nil && v.Bar != nil
}

// MethodName returns the name of the Thrift function as specified in
// the IDL, for which this struct represent the arguments.
//
// This will always be "argWithQueryParams" for this struct.
func (v *Bar_ArgWithQueryParams_Args) MethodName() string {
	return "argWithQueryParams"
}

// EnvelopeType returns the kind of value inside this struct.
//
// This will always be Call for this struct.
func (v *Bar_ArgWithQueryParams_Args) EnvelopeType() wire.EnvelopeType {
	return wire.Call
}

// Bar_ArgWithQueryParams_Helper provides functions that aid in handling the
// parameters and return values of the Bar.argWithQueryParams
// function.
var Bar_ArgWithQueryParams_Helper = struct {
	// Args accepts the parameters of argWithQueryParams in-order and returns
	// the arguments struct for the function.
	Args func(
		name string,
		userUUID *string,
		foo []string,
		bar []int8,
	) *Bar_ArgWithQueryParams_Args

	// IsException returns true if the given error can be thrown
	// by argWithQueryParams.
	//
	// An error can be thrown by argWithQueryParams only if the
	// corresponding exception type was mentioned in the 'throws'
	// section for it in the Thrift file.
	IsException func(error) bool

	// WrapResponse returns the result struct for argWithQueryParams
	// given its return value and error.
	//
	// This allows mapping values and errors returned by
	// argWithQueryParams into a serializable result struct.
	// WrapResponse returns a non-nil error if the provided
	// error cannot be thrown by argWithQueryParams
	//
	//   value, err := argWithQueryParams(args)
	//   result, err := Bar_ArgWithQueryParams_Helper.WrapResponse(value, err)
	//   if err != nil {
	//     return fmt.Errorf("unexpected error from argWithQueryParams: %v", err)
	//   }
	//   serialize(result)
	WrapResponse func(*BarResponse, error) (*Bar_ArgWithQueryParams_Result, error)

	// UnwrapResponse takes the result struct for argWithQueryParams
	// and returns the value or error returned by it.
	//
	// The error is non-nil only if argWithQueryParams threw an
	// exception.
	//
	//   result := deserialize(bytes)
	//   value, err := Bar_ArgWithQueryParams_Helper.UnwrapResponse(result)
	UnwrapResponse func(*Bar_ArgWithQueryParams_Result) (*BarResponse, error)
}{}

func init() {
	Bar_ArgWithQueryParams_Helper.Args = func(
		name string,
		userUUID *string,
		foo []string,
		bar []int8,
	) *Bar_ArgWithQueryParams_Args {
		return &Bar_ArgWithQueryParams_Args{
			Name:     name,
			UserUUID: userUUID,
			Foo:      foo,
			Bar:      bar,
		}
	}

	Bar_ArgWithQueryParams_Helper.IsException = func(err error) bool {
		switch err.(type) {
		default:
			return false
		}
	}

	Bar_ArgWithQueryParams_Helper.WrapResponse = func(success *BarResponse, err error) (*Bar_ArgWithQueryParams_Result, error) {
		if err == nil {
			return &Bar_ArgWithQueryParams_Result{Success: success}, nil
		}

		return nil, err
	}
	Bar_ArgWithQueryParams_Helper.UnwrapResponse = func(result *Bar_ArgWithQueryParams_Result) (success *BarResponse, err error) {

		if result.Success != nil {
			success = result.Success
			return
		}

		err = errors.New("expected a non-void result")
		return
	}

}

// Bar_ArgWithQueryParams_Result represents the result of a Bar.argWithQueryParams function call.
//
// The result of a argWithQueryParams execution is sent and received over the wire as this struct.
//
// Success is set only if the function did not throw an exception.
type Bar_ArgWithQueryParams_Result struct {
	// Value returned by argWithQueryParams after a successful execution.
	Success *BarResponse `json:"success,omitempty"`
}

// ToWire translates a Bar_ArgWithQueryParams_Result struct into a Thrift-level intermediate
// representation. This intermediate representation may be serialized
// into bytes using a ThriftRW protocol implementation.
//
// An error is returned if the struct or any of its fields failed to
// validate.
//
//   x, err := v.ToWire()
//   if err != nil {
//     return err
//   }
//
//   if err := binaryProtocol.Encode(x, writer); err != nil {
//     return err
//   }
func (v *Bar_ArgWithQueryParams_Result) ToWire() (wire.Value, error) {
	var (
		fields [1]wire.Field
		i      int = 0
		w      wire.Value
		err    error
	)

	if v.Success != nil {
		w, err = v.Success.ToWire()
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 0, Value: w}
		i++
	}

	if i != 1 {
		return wire.Value{}, fmt.Errorf("Bar_ArgWithQueryParams_Result should have exactly one field: got %v fields", i)
	}

	return wire.NewValueStruct(wire.Struct{Fields: fields[:i]}), nil
}

// FromWire deserializes a Bar_ArgWithQueryParams_Result struct from its Thrift-level
// representation. The Thrift-level representation may be obtained
// from a ThriftRW protocol implementation.
//
// An error is returned if we were unable to build a Bar_ArgWithQueryParams_Result struct
// from the provided intermediate representation.
//
//   x, err := binaryProtocol.Decode(reader, wire.TStruct)
//   if err != nil {
//     return nil, err
//   }
//
//   var v Bar_ArgWithQueryParams_Result
//   if err := v.FromWire(x); err != nil {
//     return nil, err
//   }
//   return &v, nil
func (v *Bar_ArgWithQueryParams_Result) FromWire(w wire.Value) error {
	var err error

	for _, field := range w.GetStruct().Fields {
		switch field.ID {
		case 0:
			if field.Value.Type() == wire.TStruct {
				v.Success, err = _BarResponse_Read(field.Value)
				if err != nil {
					return err
				}

			}
		}
	}

	count := 0
	if v.Success != nil {
		count++
	}
	if count != 1 {
		return fmt.Errorf("Bar_ArgWithQueryParams_Result should have exactly one field: got %v fields", count)
	}

	return nil
}

// String returns a readable string representation of a Bar_ArgWithQueryParams_Result
// struct.
func (v *Bar_ArgWithQueryParams_Result) String() string {
	if v == nil {
		return "<nil>"
	}

	var fields [1]string
	i := 0
	if v.Success != nil {
		fields[i] = fmt.Sprintf("Success: %v", v.Success)
		i++
	}

	return fmt.Sprintf("Bar_ArgWithQueryParams_Result{%v}", strings.Join(fields[:i], ", "))
}

// Equals returns true if all the fields of this Bar_ArgWithQueryParams_Result match the
// provided Bar_ArgWithQueryParams_Result.
//
// This function performs a deep comparison.
func (v *Bar_ArgWithQueryParams_Result) Equals(rhs *Bar_ArgWithQueryParams_Result) bool {
	if v == nil {
		return rhs == nil
	} else if rhs == nil {
		return false
	}
	if !((v.Success == nil && rhs.Success == nil) || (v.Success != nil && rhs.Success != nil && v.Success.Equals(rhs.Success))) {
		return false
	}

	return true
}

// MarshalLogObject implements zapcore.ObjectMarshaler, enabling
// fast logging of Bar_ArgWithQueryParams_Result.
func (v *Bar_ArgWithQueryParams_Result) MarshalLogObject(enc zapcore.ObjectEncoder) (err error) {
	if v == nil {
		return nil
	}
	if v.Success != nil {
		err = multierr.Append(err, enc.AddObject("success", v.Success))
	}
	return err
}

// GetSuccess returns the value of Success if it is set or its
// zero value if it is unset.
func (v *Bar_ArgWithQueryParams_Result) GetSuccess() (o *BarResponse) {
	if v != nil && v.Success != nil {
		return v.Success
	}

	return
}

// IsSetSuccess returns true if Success is not nil.
func (v *Bar_ArgWithQueryParams_Result) IsSetSuccess() bool {
	return v != nil && v.Success != nil
}

// MethodName returns the name of the Thrift function as specified in
// the IDL, for which this struct represent the result.
//
// This will always be "argWithQueryParams" for this struct.
func (v *Bar_ArgWithQueryParams_Result) MethodName() string {
	return "argWithQueryParams"
}

// EnvelopeType returns the kind of value inside this struct.
//
// This will always be Reply for this struct.
func (v *Bar_ArgWithQueryParams_Result) EnvelopeType() wire.EnvelopeType {
	return wire.Reply
}

// Bar_DeleteWithBody_Args represents the arguments for the Bar.deleteWithBody function.
//
// The arguments for deleteWithBody are sent and received over the wire as this struct.
type Bar_DeleteWithBody_Args struct {
	Filter string `json:"filter,required"`
	Count  *int32 `json:"count,omitempty"`
}

// ToWire translates a Bar_DeleteWithBody_Args struct into a Thrift-level intermediate
// representation. This intermediate representation may be serialized
// into bytes using a ThriftRW protocol implementation.
//
// An error is returned if the struct or any of its fields failed to
// validate.
//
//   x, err := v.ToWire()
//   if err != nil {
//     return err
//   }
//
//   if err := binaryProtocol.Encode(x, writer); err != nil {
//     return err
//   }
func (v *Bar_DeleteWithBody_Args) ToWire() (wire.Value, error) {
	var (
		fields [2]wire.Field
		i      int = 0
		w      wire.Value
		err    error
	)

	w, err = wire.NewValueString(v.Filter), error(nil)
	if err != nil {
		return w, err
	}
	fields[i] = wire.Field{ID: 2, Value: w}
	i++
	if v.Count != nil {
		w, err = wire.NewValueI32(*(v.Count)), error(nil)
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 3, Value: w}
		i++
	}

	return wire.NewValueStruct(wire.Struct{Fields: fields[:i]}), nil
}

// FromWire deserializes a Bar_DeleteWithBody_Args struct from its Thrift-level
// representation. The Thrift-level representation may be obtained
// from a ThriftRW protocol implementation.
//
// An error is returned if we were unable to build a Bar_DeleteWithBody_Args struct
// from the provided intermediate representation.
//
//   x, err := binaryProtocol.Decode(reader, wire.TStruct)
//   if err != nil {
//     return nil, err
//   }
//
//   var v Bar_DeleteWithBody_Args
//   if err := v.FromWire(x); err != nil {
//     return nil, err
//   }
//   return &v, nil
func (v *Bar_DeleteWithBody_Args) FromWire(w wire.Value) error {
	var err error

	filterIsSet := false

	for _, field := range w.GetStruct().Fields {
		switch field.ID {
		case 2:
			if field.Value.Type() == wire.TBinary {
				v.Filter, err = field.Value.GetString(), error(nil)
				if err != nil {
					return err
				}
				filterIsSet = true
			}
		case 3:
			if field.Value.Type() == wire.TI32 {
				var x int32
				x, err = field.Value.GetI32(), error(nil)
				v.Count = &x
				if err != nil {
					return err
				}

			}
		}
	}

	if !filterIsSet {
		return errors.New("field Filter of Bar_DeleteWithBody_Args is required")
	}

	return nil
}

// String returns a readable string representation of a Bar_DeleteWithBody_Args
// struct.
func (v *Bar_DeleteWithBody_Args) String() string {
	if v == nil {
		return "<nil>"
	}

	var fields [2]string
	i := 0
	fields[i] = fmt.Sprintf("Filter: %v", v.Filter)
	i++
	if v.Count != nil {
		fields[i] = fmt.Sprintf("Count: %v", *(v.Count))
		i++
	}

	return fmt.Sprintf("Bar_DeleteWithBody_Args{%v}", strings.Join(fields[:i], ", "))
}

// Equals returns true if all the fields of this Bar_DeleteWithBody_Args match the
// provided Bar_DeleteWithBody_Args.
//
// This function performs a deep comparison.
func (v *Bar_DeleteWithBody_Args) Equals(rhs *Bar_DeleteWithBody_Args) bool {
	if v == nil {
		return rhs == nil
	} else if rhs == nil {
		return false
	}
	if !(v.Filter == rhs.Filter) {
		return false
	}
	if !_I32_EqualsPtr(v.Count, rhs.Count) {
		return false
	}

	return true
}

// MarshalLogObject implements zapcore.ObjectMarshaler, enabling
// fast logging of Bar_DeleteWithBody_Args.
func (v *Bar_DeleteWithBody_Args) MarshalLogObject(enc zapcore.ObjectEncoder) (err error) {
	if v == nil {
		return nil
	}
	enc.AddString("filter", v.Filter)
	if v.Count != nil {
		enc.AddInt32("count", *v.Count)
	}
	return err
}

// GetFilter returns the value of Filter if it is set or its
// zero value if it is unset.
func (v *Bar_DeleteWithBody_Args) GetFilter() (o string) {
	if v != nil {
		o = v.Filter
	}
	return
}

// GetCount returns the value of Count if it is set or its
// zero value if it is unset.
func (v *Bar_DeleteWithBody_Args) GetCount() (o int32) {
	if v != nil && v.Count != nil {
		return *v.Count
	}

	return
}

// IsSetCount returns true if Count is not nil.
func (v *Bar_DeleteWithBody_Args) IsSetCount() bool {
	return v != nil && v.Count != nil
}

// MethodName returns the name of the Thrift function as specified in
// the IDL, for which this struct represent the arguments.
//
// This will always be "deleteWithBody" for this struct.
func (v *Bar_DeleteWithBody_Args) MethodName() string {
	return "deleteWithBody"
}

// EnvelopeType returns the kind of value inside this struct.
//
// This will always be Call for this struct.
func (v *Bar_DeleteWithBody_Args) EnvelopeType() wire.EnvelopeType {
	return wire.Call
}

// Bar_DeleteWithBody_Helper provides functions that aid in handling the
// parameters and return values of the Bar.deleteWithBody
// function.
var Bar_DeleteWithBody_Helper = struct {
	// Args accepts the parameters of deleteWithBody in-order and returns
	// the arguments struct for the function.
	Args func(
		filter string,
		count *int32,
	) *Bar_DeleteWithBody_Args

	// IsException returns true if the given error can be thrown
	// by deleteWithBody.
	//
	// An error can be thrown by deleteWithBody only if the
	// corresponding exception type was mentioned in the 'throws'
	// section for it in the Thrift file.
	IsException func(error) bool

	// WrapResponse returns the result struct for deleteWithBody
	// given the error returned by it. The provided error may
	// be nil if deleteWithBody did not fail.
	//
	// This allows mapping errors returned by deleteWithBody into a
	// serializable result struct. WrapResponse returns a
	// non-nil error if the provided error cannot be thrown by
	// deleteWithBody
	//
	//   err := deleteWithBody(args)
	//   result, err := Bar_DeleteWithBody_Helper.WrapResponse(err)
	//   if err != nil {
	//     return fmt.Errorf("unexpected error from deleteWithBody: %v", err)
	//   }
	//   serialize(result)
	WrapResponse func(error) (*Bar_DeleteWithBody_Result, error)

	// UnwrapResponse takes the result struct for deleteWithBody
	// and returns the erorr returned by it (if any).
	//
	// The error is non-nil only if deleteWithBody threw an
	// exception.
	//
	//   result := deserialize(bytes)
	//   err := Bar_DeleteWithBody_Helper.UnwrapResponse(result)
	UnwrapResponse func(*Bar_DeleteWithBody_Result) error
}{}

func init() {
	Bar_DeleteWithBody_Helper.Args = func(
		filter string,
		count *int32,
	) *Bar_DeleteWithBody_Args {
		return &Bar_DeleteWithBody_Args{
			Filter: filter,
			Count:  count,
		}
	}

	Bar_DeleteWithBody_Helper.IsException = func(err error) bool {
		switch err.(type) {
		default:
			return false
		}
	}

	Bar_DeleteWithBody_Helper.WrapResponse = func(err error) (*Bar_DeleteWithBody_Result, error) {
		if err == nil {
			return &Bar_DeleteWithBody_Result{}, nil
		}

		return nil, err
	}
	Bar_DeleteWithBody_Helper.UnwrapResponse = func(result *Bar_DeleteWithBody_Result) (err error) {
		return
	}

}

// Bar_DeleteWithBody_Result represents the result of a Bar.deleteWithBody function call.
//
// The result of a deleteWithBody execution is sent and received over the wire as this struct.
type Bar_DeleteWithBody_Result struct {
}

// ToWire translates a Bar_DeleteWithBody_Result struct into a Thrift-level intermediate
// representation. This intermediate representation may be serialized
// into bytes using a ThriftRW protocol implementation.
//
// An error is returned if the struct or any of its fields failed to
// validate.
//
//   x, err := v.ToWire()
//   if err != nil {
//     return err
//   }
//
//   if err := binaryProtocol.Encode(x, writer); err != nil {
//     return err
//   }
func (v *Bar_DeleteWithBody_Result) ToWire() (wire.Value, error) {
	var (
		fields [0]wire.Field
		i      int = 0
	)

	return wire.NewValueStruct(wire.Struct{Fields: fields[:i]}), nil
}

// FromWire deserializes a Bar_DeleteWithBody_Result struct from its Thrift-level
// representation. The Thrift-level representation may be obtained
// from a ThriftRW protocol implementation.
//
// An error is returned if we were unable to build a Bar_DeleteWithBody_Result struct
// from the provided intermediate representation.
//
//   x, err := binaryProtocol.Decode(reader, wire.TStruct)
//   if err != nil {
//     return nil, err
//   }
//
//   var v Bar_DeleteWithBody_Result
//   if err := v.FromWire(x); err != nil {
//     return nil, err
//   }
//   return &v, nil
func (v *Bar_DeleteWithBody_Result) FromWire(w wire.Value) error {

	for _, field := range w.GetStruct().Fields {
		switch field.ID {
		}
	}

	return nil
}

// String returns a readable string representation of a Bar_DeleteWithBody_Result
// struct.
func (v *Bar_DeleteWithBody_Result) String() string {
	if v == nil {
		return "<nil>"
	}

	var fields [0]string
	i := 0

	return fmt.Sprintf("Bar_DeleteWithBody_Result{%v}", strings.Join(fields[:i], ", "))
}

// Equals returns true if all the fields of this Bar_DeleteWithBody_Result match the
// provided Bar_DeleteWithBody_Result.
//
// This function performs a deep comparison.
func (v *Bar_DeleteWithBody_Result) Equals(rhs *Bar_DeleteWithBody_Result) bool {
	if v == nil {
		return rhs == nil
	} else if rhs == nil {
		return false
	}

	return true
}

// MarshalLogObject implements zapcore.ObjectMarshaler, enabling
// fast logging of Bar_DeleteWithBody_Result.
func (v *Bar_DeleteWithBody_Result) MarshalLogObject(enc zapcore.ObjectEncoder) (err error) {
	if v == nil {
		return nil
	}
	return err
}

// MethodName returns the name of the Thrift function as specified in
// the IDL, for which this struct represent the result.
//
// This will always be "deleteWithBody" for this struct.
func (v *Bar_DeleteWithBody_Result) MethodName() string {
	return "deleteWithBody"
}

// EnvelopeType returns the kind of value inside this struct.
//
// This will always be Reply for this struct.
func (v *Bar_DeleteWithBody_Result) EnvelopeType() wire.EnvelopeType {
	return wire.Reply
}

// Bar_DeleteWithQueryParams_Args represents the arguments for the Bar.deleteWithQueryParams function.
//
// The arguments for deleteWithQueryParams are sent and received over the wire as this struct.
type Bar_DeleteWithQueryParams_Args struct {
	Filter string `json:"filter,required"`
	Count  *int32 `json:"count,omitempty"`
}

// ToWire translates a Bar_DeleteWithQueryParams_Args struct into a Thrift-level intermediate
// representation. This intermediate representation may be serialized
// into bytes using a ThriftRW protocol implementation.
//
// An error is returned if the struct or any of its fields failed to
// validate.
//
//   x, err := v.ToWire()
//   if err != nil {
//     return err
//   }
//
//   if err := binaryProtocol.Encode(x, writer); err != nil {
//     return err
//   }
func (v *Bar_DeleteWithQueryParams_Args) ToWire() (wire.Value, error) {
	var (
		fields [2]wire.Field
		i      int = 0
		w      wire.Value
		err    error
	)

	w, err = wire.NewValueString(v.Filter), error(nil)
	if err != nil {
		return w, err
	}
	fields[i] = wire.Field{ID: 2, Value: w}
	i++
	if v.Count != nil {
		w, err = wire.NewValueI32(*(v.Count)), error(nil)
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 3, Value: w}
		i++
	}

	return wire.NewValueStruct(wire.Struct{Fields: fields[:i]}), nil
}

// FromWire deserializes a Bar_DeleteWithQueryParams_Args struct from its Thrift-level
// representation. The Thrift-level representation may be obtained
// from a ThriftRW protocol implementation.
//
// An error is returned if we were unable to build a Bar_DeleteWithQueryParams_Args struct
// from the provided intermediate representation.
//
//   x, err := binaryProtocol.Decode(reader, wire.TStruct)
//   if err != nil {
//     return nil, err
//   }
//
//   var v Bar_DeleteWithQueryParams_Args
//   if err := v.FromWire(x); err != nil {
//     return nil, err
//   }
//   return &v, nil
func (v *Bar_DeleteWithQueryParams_Args) FromWire(w wire.Value) error {
	var err error

	filterIsSet := false

	for _, field := range w.GetStruct().Fields {
		switch field.ID {
		case 2:
			if field.Value.Type() == wire.TBinary {
				v.Filter, err = field.Value.GetString(), error(nil)
				if err != nil {
					return err
				}
				filterIsSet = true
			}
		case 3:
			if field.Value.Type() == wire.TI32 {
				var x int32
				x, err = field.Value.GetI32(), error(nil)
				v.Count = &x
				if err != nil {
					return err
				}

			}
		}
	}

	if !filterIsSet {
		return errors.New("field Filter of Bar_DeleteWithQueryParams_Args is required")
	}

	return nil
}

// String returns a readable string representation of a Bar_DeleteWithQueryParams_Args
// struct.
func (v *Bar_DeleteWithQueryParams_Args) String() string {
	if v == nil {
		return "<nil>"
	}

	var fields [2]string
	i := 0
	fields[i] = fmt.Sprintf("Filter: %v", v.Filter)
	i++
	if v.Count != nil {
		fields[i] = fmt.Sprintf("Count: %v", *(v.Count))
		i++
	}

	return fmt.Sprintf("Bar_DeleteWithQueryParams_Args{%v}", strings.Join(fields[:i], ", "))
}

// Equals returns true if all the fields of this Bar_DeleteWithQueryParams_Args match the
// provided Bar_DeleteWithQueryParams_Args.
//
// This function performs a deep comparison.
func (v *Bar_DeleteWithQueryParams_Args) Equals(rhs *Bar_DeleteWithQueryParams_Args) bool {
	if v == nil {
		return rhs == nil
	} else if rhs == nil {
		return false
	}
	if !(v.Filter == rhs.Filter) {
		return false
	}
	if !_I32_EqualsPtr(v.Count, rhs.Count) {
		return false
	}

	return true
}

// MarshalLogObject implements zapcore.ObjectMarshaler, enabling
// fast logging of Bar_DeleteWithQueryParams_Args.
func (v *Bar_DeleteWithQueryParams_Args) MarshalLogObject(enc zapcore.ObjectEncoder) (err error) {
	if v == nil {
		return nil
	}
	enc.AddString("filter", v.Filter)
	if v.Count != nil {
		enc.AddInt32("count", *v.Count)
	}
	return err
}

// GetFilter returns the value of Filter if it is set or its
// zero value if it is unset.
func (v *Bar_DeleteWithQueryParams_Args) GetFilter() (o string) {
	if v != nil {
		o = v.Filter
	}
	return
}

// GetCount returns the value of Count if it is set or its
// zero value if it is unset.
func (v *Bar_DeleteWithQueryParams_Args) GetCount() (o int32) {
	if v != nil && v.Count != nil {
		return *v.Count
	}

	return
}

// IsSetCount returns true if Count is not nil.
func (v *Bar_DeleteWithQueryParams_Args) IsSetCount() bool {
	return v != nil && v.Count != nil
}

// MethodName returns the name of the Thrift function as specified in
// the IDL, for which this struct represent the arguments.
//
// This will always be "deleteWithQueryParams" for this struct.
func (v *Bar_DeleteWithQueryParams_Args) MethodName() string {
	return "deleteWithQueryParams"
}

// EnvelopeType returns the kind of value inside this struct.
//
// This will always be Call for this struct.
func (v *Bar_DeleteWithQueryParams_Args) EnvelopeType() wire.EnvelopeType {
	return wire.Call
}

// Bar_DeleteWithQueryParams_Helper provides functions that aid in handling the
// parameters and return values of the Bar.deleteWithQueryParams
// function.
var Bar_DeleteWithQueryParams_Helper = struct {
	// Args accepts the parameters of deleteWithQueryParams in-order and returns
	// the arguments struct for the function.
	Args func(
		filter string,
		count *int32,
	) *Bar_DeleteWithQueryParams_Args

	// IsException returns true if the given error can be thrown
	// by deleteWithQueryParams.
	//
	// An error can be thrown by deleteWithQueryParams only if the
	// corresponding exception type was mentioned in the 'throws'
	// section for it in the Thrift file.
	IsException func(error) bool

	// WrapResponse returns the result struct for deleteWithQueryParams
	// given the error returned by it. The provided error may
	// be nil if deleteWithQueryParams did not fail.
	//
	// This allows mapping errors returned by deleteWithQueryParams into a
	// serializable result struct. WrapResponse returns a
	// non-nil error if the provided error cannot be thrown by
	// deleteWithQueryParams
	//
	//   err := deleteWithQueryParams(args)
	//   result, err := Bar_DeleteWithQueryParams_Helper.WrapResponse(err)
	//   if err != nil {
	//     return fmt.Errorf("unexpected error from deleteWithQueryParams: %v", err)
	//   }
	//   serialize(result)
	WrapResponse func(error) (*Bar_DeleteWithQueryParams_Result, error)

	// UnwrapResponse takes the result struct for deleteWithQueryParams
	// and returns the erorr returned by it (if any).
	//
	// The error is non-nil only if deleteWithQueryParams threw an
	// exception.
	//
	//   result := deserialize(bytes)
	//   err := Bar_DeleteWithQueryParams_Helper.UnwrapResponse(result)
	UnwrapResponse func(*Bar_DeleteWithQueryParams_Result) error
}{}

func init() {
	Bar_DeleteWithQueryParams_Helper.Args = func(
		filter string,
		count *int32,
	) *Bar_DeleteWithQueryParams_Args {
		return &Bar_DeleteWithQueryParams_Args{
			Filter: filter,
			Count:  count,
		}
	}

	Bar_DeleteWithQueryParams_Helper.IsException = func(err error) bool {
		switch err.(type) {
		default:
			return false
		}
	}

	Bar_DeleteWithQueryParams_Helper.WrapResponse = func(err error) (*Bar_DeleteWithQueryParams_Result, error) {
		if err == nil {
			return &Bar_DeleteWithQueryParams_Result{}, nil
		}

		return nil, err
	}
	Bar_DeleteWithQueryParams_Helper.UnwrapResponse = func(result *Bar_DeleteWithQueryParams_Result) (err error) {
		return
	}

}

// Bar_DeleteWithQueryParams_Result represents the result of a Bar.deleteWithQueryParams function call.
//
// The result of a deleteWithQueryParams execution is sent and received over the wire as this struct.
type Bar_DeleteWithQueryParams_Result struct {
}

// ToWire translates a Bar_DeleteWithQueryParams_Result struct into a Thrift-level intermediate
// representation. This intermediate representation may be serialized
// into bytes using a ThriftRW protocol implementation.
//
// An error is returned if the struct or any of its fields failed to
// validate.
//
//   x, err := v.ToWire()
//   if err != nil {
//     return err
//   }
//
//   if err := binaryProtocol.Encode(x, writer); err != nil {
//     return err
//   }
func (v *Bar_DeleteWithQueryParams_Result) ToWire() (wire.Value, error) {
	var (
		fields [0]wire.Field
		i      int = 0
	)

	return wire.NewValueStruct(wire.Struct{Fields: fields[:i]}), nil
}

// FromWire deserializes a Bar_DeleteWithQueryParams_Result struct from its Thrift-level
// representation. The Thrift-level representation may be obtained
// from a ThriftRW protocol implementation.
//
// An error is returned if we were unable to build a Bar_DeleteWithQueryParams_Result struct
// from the provided intermediate representation.
//
//   x, err := binaryProtocol.Decode(reader, wire.TStruct)
//   if err != nil {
//     return nil, err
//   }
//
//   var v Bar_DeleteWithQueryParams_Result
//   if err := v.FromWire(x); err != nil {
//     return nil, err
//   }
//   return &v, nil
func (v *Bar_DeleteWithQueryParams_Result) FromWire(w wire.Value) error {

	for _, field := range w.GetStruct().Fields {
		switch field.ID {
		}
	}

	return nil
}

// String returns a readable string representation of a Bar_DeleteWithQueryParams_Result
// struct.
func (v *Bar_DeleteWithQueryParams_Result) String() string {
	if v == nil {
		return "<nil>"
	}

	var fields [0]string
	i := 0

	return fmt.Sprintf("Bar_DeleteWithQueryParams_Result{%v}", strings.Join(fields[:i], ", "))
}

// Equals returns true if all the fields of this Bar_DeleteWithQueryParams_Result match the
// provided Bar_DeleteWithQueryParams_Result.
//
// This function performs a deep comparison.
func (v *Bar_DeleteWithQueryParams_Result) Equals(rhs *Bar_DeleteWithQueryParams_Result) bool {
	if v == nil {
		return rhs == nil
	} else if rhs == nil {
		return false
	}

	return true
}

// MarshalLogObject implements zapcore.ObjectMarshaler, enabling
// fast logging of Bar_DeleteWithQueryParams_Result.
func (v *Bar_DeleteWithQueryParams_Result) MarshalLogObject(enc zapcore.ObjectEncoder) (err error) {
	if v == nil {
		return nil
	}
	return err
}

// MethodName returns the name of the Thrift function as specified in
// the IDL, for which this struct represent the result.
//
// This will always be "deleteWithQueryParams" for this struct.
func (v *Bar_DeleteWithQueryParams_Result) MethodName() string {
	return "deleteWithQueryParams"
}

// EnvelopeType returns the kind of value inside this struct.
//
// This will always be Reply for this struct.
func (v *Bar_DeleteWithQueryParams_Result) EnvelopeType() wire.EnvelopeType {
	return wire.Reply
}

// Bar_HelloWorld_Args represents the arguments for the Bar.helloWorld function.
//
// The arguments for helloWorld are sent and received over the wire as this struct.
type Bar_HelloWorld_Args struct {
}

// ToWire translates a Bar_HelloWorld_Args struct into a Thrift-level intermediate
// representation. This intermediate representation may be serialized
// into bytes using a ThriftRW protocol implementation.
//
// An error is returned if the struct or any of its fields failed to
// validate.
//
//   x, err := v.ToWire()
//   if err != nil {
//     return err
//   }
//
//   if err := binaryProtocol.Encode(x, writer); err != nil {
//     return err
//   }
func (v *Bar_HelloWorld_Args) ToWire() (wire.Value, error) {
	var (
		fields [0]wire.Field
		i      int = 0
	)

	return wire.NewValueStruct(wire.Struct{Fields: fields[:i]}), nil
}

// FromWire deserializes a Bar_HelloWorld_Args struct from its Thrift-level
// representation. The Thrift-level representation may be obtained
// from a ThriftRW protocol implementation.
//
// An error is returned if we were unable to build a Bar_HelloWorld_Args struct
// from the provided intermediate representation.
//
//   x, err := binaryProtocol.Decode(reader, wire.TStruct)
//   if err != nil {
//     return nil, err
//   }
//
//   var v Bar_HelloWorld_Args
//   if err := v.FromWire(x); err != nil {
//     return nil, err
//   }
//   return &v, nil
func (v *Bar_HelloWorld_Args) FromWire(w wire.Value) error {

	for _, field := range w.GetStruct().Fields {
		switch field.ID {
		}
	}

	return nil
}

// String returns a readable string representation of a Bar_HelloWorld_Args
// struct.
func (v *Bar_HelloWorld_Args) String() string {
	if v == nil {
		return "<nil>"
	}

	var fields [0]string
	i := 0

	return fmt.Sprintf("Bar_HelloWorld_Args{%v}", strings.Join(fields[:i], ", "))
}

// Equals returns true if all the fields of this Bar_HelloWorld_Args match the
// provided Bar_HelloWorld_Args.
//
// This function performs a deep comparison.
func (v *Bar_HelloWorld_Args) Equals(rhs *Bar_HelloWorld_Args) bool {
	if v == nil {
		return rhs == nil
	} else if rhs == nil {
		return false
	}

	return true
}

// MarshalLogObject implements zapcore.ObjectMarshaler, enabling
// fast logging of Bar_HelloWorld_Args.
func (v *Bar_HelloWorld_Args) MarshalLogObject(enc zapcore.ObjectEncoder) (err error) {
	if v == nil {
		return nil
	}
	return err
}

// MethodName returns the name of the Thrift function as specified in
// the IDL, for which this struct represent the arguments.
//
// This will always be "helloWorld" for this struct.
func (v *Bar_HelloWorld_Args) MethodName() string {
	return "helloWorld"
}

// EnvelopeType returns the kind of value inside this struct.
//
// This will always be Call for this struct.
func (v *Bar_HelloWorld_Args) EnvelopeType() wire.EnvelopeType {
	return wire.Call
}

// Bar_HelloWorld_Helper provides functions that aid in handling the
// parameters and return values of the Bar.helloWorld
// function.
var Bar_HelloWorld_Helper = struct {
	// Args accepts the parameters of helloWorld in-order and returns
	// the arguments struct for the function.
	Args func() *Bar_HelloWorld_Args

	// IsException returns true if the given error can be thrown
	// by helloWorld.
	//
	// An error can be thrown by helloWorld only if the
	// corresponding exception type was mentioned in the 'throws'
	// section for it in the Thrift file.
	IsException func(error) bool

	// WrapResponse returns the result struct for helloWorld
	// given its return value and error.
	//
	// This allows mapping values and errors returned by
	// helloWorld into a serializable result struct.
	// WrapResponse returns a non-nil error if the provided
	// error cannot be thrown by helloWorld
	//
	//   value, err := helloWorld(args)
	//   result, err := Bar_HelloWorld_Helper.WrapResponse(value, err)
	//   if err != nil {
	//     return fmt.Errorf("unexpected error from helloWorld: %v", err)
	//   }
	//   serialize(result)
	WrapResponse func(string, error) (*Bar_HelloWorld_Result, error)

	// UnwrapResponse takes the result struct for helloWorld
	// and returns the value or error returned by it.
	//
	// The error is non-nil only if helloWorld threw an
	// exception.
	//
	//   result := deserialize(bytes)
	//   value, err := Bar_HelloWorld_Helper.UnwrapResponse(result)
	UnwrapResponse func(*Bar_HelloWorld_Result) (string, error)
}{}

func init() {
	Bar_HelloWorld_Helper.Args = func() *Bar_HelloWorld_Args {
		return &Bar_HelloWorld_Args{}
	}

	Bar_HelloWorld_Helper.IsException = func(err error) bool {
		switch err.(type) {
		case *BarException:
			return true
		default:
			return false
		}
	}

	Bar_HelloWorld_Helper.WrapResponse = func(success string, err error) (*Bar_HelloWorld_Result, error) {
		if err == nil {
			return &Bar_HelloWorld_Result{Success: &success}, nil
		}

		switch e := err.(type) {
		case *BarException:
			if e == nil {
				return nil, errors.New("WrapResponse received non-nil error type with nil value for Bar_HelloWorld_Result.BarException")
			}
			return &Bar_HelloWorld_Result{BarException: e}, nil
		}

		return nil, err
	}
	Bar_HelloWorld_Helper.UnwrapResponse = func(result *Bar_HelloWorld_Result) (success string, err error) {
		if result.BarException != nil {
			err = result.BarException
			return
		}

		if result.Success != nil {
			success = *result.Success
			return
		}

		err = errors.New("expected a non-void result")
		return
	}

}

// Bar_HelloWorld_Result represents the result of a Bar.helloWorld function call.
//
// The result of a helloWorld execution is sent and received over the wire as this struct.
//
// Success is set only if the function did not throw an exception.
type Bar_HelloWorld_Result struct {
	// Value returned by helloWorld after a successful execution.
	Success      *string       `json:"success,omitempty"`
	BarException *BarException `json:"barException,omitempty"`
}

// ToWire translates a Bar_HelloWorld_Result struct into a Thrift-level intermediate
// representation. This intermediate representation may be serialized
// into bytes using a ThriftRW protocol implementation.
//
// An error is returned if the struct or any of its fields failed to
// validate.
//
//   x, err := v.ToWire()
//   if err != nil {
//     return err
//   }
//
//   if err := binaryProtocol.Encode(x, writer); err != nil {
//     return err
//   }
func (v *Bar_HelloWorld_Result) ToWire() (wire.Value, error) {
	var (
		fields [2]wire.Field
		i      int = 0
		w      wire.Value
		err    error
	)

	if v.Success != nil {
		w, err = wire.NewValueString(*(v.Success)), error(nil)
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 0, Value: w}
		i++
	}
	if v.BarException != nil {
		w, err = v.BarException.ToWire()
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 1, Value: w}
		i++
	}

	if i != 1 {
		return wire.Value{}, fmt.Errorf("Bar_HelloWorld_Result should have exactly one field: got %v fields", i)
	}

	return wire.NewValueStruct(wire.Struct{Fields: fields[:i]}), nil
}

// FromWire deserializes a Bar_HelloWorld_Result struct from its Thrift-level
// representation. The Thrift-level representation may be obtained
// from a ThriftRW protocol implementation.
//
// An error is returned if we were unable to build a Bar_HelloWorld_Result struct
// from the provided intermediate representation.
//
//   x, err := binaryProtocol.Decode(reader, wire.TStruct)
//   if err != nil {
//     return nil, err
//   }
//
//   var v Bar_HelloWorld_Result
//   if err := v.FromWire(x); err != nil {
//     return nil, err
//   }
//   return &v, nil
func (v *Bar_HelloWorld_Result) FromWire(w wire.Value) error {
	var err error

	for _, field := range w.GetStruct().Fields {
		switch field.ID {
		case 0:
			if field.Value.Type() == wire.TBinary {
				var x string
				x, err = field.Value.GetString(), error(nil)
				v.Success = &x
				if err != nil {
					return err
				}

			}
		case 1:
			if field.Value.Type() == wire.TStruct {
				v.BarException, err = _BarException_Read(field.Value)
				if err != nil {
					return err
				}

			}
		}
	}

	count := 0
	if v.Success != nil {
		count++
	}
	if v.BarException != nil {
		count++
	}
	if count != 1 {
		return fmt.Errorf("Bar_HelloWorld_Result should have exactly one field: got %v fields", count)
	}

	return nil
}

// String returns a readable string representation of a Bar_HelloWorld_Result
// struct.
func (v *Bar_HelloWorld_Result) String() string {
	if v == nil {
		return "<nil>"
	}

	var fields [2]string
	i := 0
	if v.Success != nil {
		fields[i] = fmt.Sprintf("Success: %v", *(v.Success))
		i++
	}
	if v.BarException != nil {
		fields[i] = fmt.Sprintf("BarException: %v", v.BarException)
		i++
	}

	return fmt.Sprintf("Bar_HelloWorld_Result{%v}", strings.Join(fields[:i], ", "))
}

// Equals returns true if all the fields of this Bar_HelloWorld_Result match the
// provided Bar_HelloWorld_Result.
//
// This function performs a deep comparison.
func (v *Bar_HelloWorld_Result) Equals(rhs *Bar_HelloWorld_Result) bool {
	if v == nil {
		return rhs == nil
	} else if rhs == nil {
		return false
	}
	if !_String_EqualsPtr(v.Success, rhs.Success) {
		return false
	}
	if !((v.BarException == nil && rhs.BarException == nil) || (v.BarException != nil && rhs.BarException != nil && v.BarException.Equals(rhs.BarException))) {
		return false
	}

	return true
}

// MarshalLogObject implements zapcore.ObjectMarshaler, enabling
// fast logging of Bar_HelloWorld_Result.
func (v *Bar_HelloWorld_Result) MarshalLogObject(enc zapcore.ObjectEncoder) (err error) {
	if v == nil {
		return nil
	}
	if v.Success != nil {
		enc.AddString("success", *v.Success)
	}
	if v.BarException != nil {
		err = multierr.Append(err, enc.AddObject("barException", v.BarException))
	}
	return err
}

// GetSuccess returns the value of Success if it is set or its
// zero value if it is unset.
func (v *Bar_HelloWorld_Result) GetSuccess() (o string) {
	if v != nil && v.Success != nil {
		return *v.Success
	}

	return
}

// IsSetSuccess returns true if Success is not nil.
func (v *Bar_HelloWorld_Result) IsSetSuccess() bool {
	return v != nil && v.Success != nil
}

// GetBarException returns the value of BarException if it is set or its
// zero value if it is unset.
func (v *Bar_HelloWorld_Result) GetBarException() (o *BarException) {
	if v != nil && v.BarException != nil {
		return v.BarException
	}

	return
}

// IsSetBarException returns true if BarException is not nil.
func (v *Bar_HelloWorld_Result) IsSetBarException() bool {
	return v != nil && v.BarException != nil
}

// MethodName returns the name of the Thrift function as specified in
// the IDL, for which this struct represent the result.
//
// This will always be "helloWorld" for this struct.
func (v *Bar_HelloWorld_Result) MethodName() string {
	return "helloWorld"
}

// EnvelopeType returns the kind of value inside this struct.
//
// This will always be Reply for this struct.
func (v *Bar_HelloWorld_Result) EnvelopeType() wire.EnvelopeType {
	return wire.Reply
}

// Bar_ListAndEnum_Args represents the arguments for the Bar.listAndEnum function.
//
// The arguments for listAndEnum are sent and received over the wire as this struct.
type Bar_ListAndEnum_Args struct {
	DemoIds  []string   `json:"demoIds,required"`
	DemoType *DemoType  `json:"demoType,omitempty"`
	Demos    []DemoType `json:"demos,omitempty"`
}

// ToWire translates a Bar_ListAndEnum_Args struct into a Thrift-level intermediate
// representation. This intermediate representation may be serialized
// into bytes using a ThriftRW protocol implementation.
//
// An error is returned if the struct or any of its fields failed to
// validate.
//
//   x, err := v.ToWire()
//   if err != nil {
//     return err
//   }
//
//   if err := binaryProtocol.Encode(x, writer); err != nil {
//     return err
//   }
func (v *Bar_ListAndEnum_Args) ToWire() (wire.Value, error) {
	var (
		fields [3]wire.Field
		i      int = 0
		w      wire.Value
		err    error
	)

	if v.DemoIds == nil {
		return w, errors.New("field DemoIds of Bar_ListAndEnum_Args is required")
	}
	w, err = wire.NewValueList(_List_String_ValueList(v.DemoIds)), error(nil)
	if err != nil {
		return w, err
	}
	fields[i] = wire.Field{ID: 1, Value: w}
	i++
	if v.DemoType != nil {
		w, err = v.DemoType.ToWire()
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 2, Value: w}
		i++
	}
	if v.Demos != nil {
		w, err = wire.NewValueList(_List_DemoType_ValueList(v.Demos)), error(nil)
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 3, Value: w}
		i++
	}

	return wire.NewValueStruct(wire.Struct{Fields: fields[:i]}), nil
}

// FromWire deserializes a Bar_ListAndEnum_Args struct from its Thrift-level
// representation. The Thrift-level representation may be obtained
// from a ThriftRW protocol implementation.
//
// An error is returned if we were unable to build a Bar_ListAndEnum_Args struct
// from the provided intermediate representation.
//
//   x, err := binaryProtocol.Decode(reader, wire.TStruct)
//   if err != nil {
//     return nil, err
//   }
//
//   var v Bar_ListAndEnum_Args
//   if err := v.FromWire(x); err != nil {
//     return nil, err
//   }
//   return &v, nil
func (v *Bar_ListAndEnum_Args) FromWire(w wire.Value) error {
	var err error

	demoIdsIsSet := false

	for _, field := range w.GetStruct().Fields {
		switch field.ID {
		case 1:
			if field.Value.Type() == wire.TList {
				v.DemoIds, err = _List_String_Read(field.Value.GetList())
				if err != nil {
					return err
				}
				demoIdsIsSet = true
			}
		case 2:
			if field.Value.Type() == wire.TI32 {
				var x DemoType
				x, err = _DemoType_Read(field.Value)
				v.DemoType = &x
				if err != nil {
					return err
				}

			}
		case 3:
			if field.Value.Type() == wire.TList {
				v.Demos, err = _List_DemoType_Read(field.Value.GetList())
				if err != nil {
					return err
				}

			}
		}
	}

	if !demoIdsIsSet {
		return errors.New("field DemoIds of Bar_ListAndEnum_Args is required")
	}

	return nil
}

// String returns a readable string representation of a Bar_ListAndEnum_Args
// struct.
func (v *Bar_ListAndEnum_Args) String() string {
	if v == nil {
		return "<nil>"
	}

	var fields [3]string
	i := 0
	fields[i] = fmt.Sprintf("DemoIds: %v", v.DemoIds)
	i++
	if v.DemoType != nil {
		fields[i] = fmt.Sprintf("DemoType: %v", *(v.DemoType))
		i++
	}
	if v.Demos != nil {
		fields[i] = fmt.Sprintf("Demos: %v", v.Demos)
		i++
	}

	return fmt.Sprintf("Bar_ListAndEnum_Args{%v}", strings.Join(fields[:i], ", "))
}

func _DemoType_EqualsPtr(lhs, rhs *DemoType) bool {
	if lhs != nil && rhs != nil {

		x := *lhs
		y := *rhs
		return x.Equals(y)
	}
	return lhs == nil && rhs == nil
}

// Equals returns true if all the fields of this Bar_ListAndEnum_Args match the
// provided Bar_ListAndEnum_Args.
//
// This function performs a deep comparison.
func (v *Bar_ListAndEnum_Args) Equals(rhs *Bar_ListAndEnum_Args) bool {
	if v == nil {
		return rhs == nil
	} else if rhs == nil {
		return false
	}
	if !_List_String_Equals(v.DemoIds, rhs.DemoIds) {
		return false
	}
	if !_DemoType_EqualsPtr(v.DemoType, rhs.DemoType) {
		return false
	}
	if !((v.Demos == nil && rhs.Demos == nil) || (v.Demos != nil && rhs.Demos != nil && _List_DemoType_Equals(v.Demos, rhs.Demos))) {
		return false
	}

	return true
}

// MarshalLogObject implements zapcore.ObjectMarshaler, enabling
// fast logging of Bar_ListAndEnum_Args.
func (v *Bar_ListAndEnum_Args) MarshalLogObject(enc zapcore.ObjectEncoder) (err error) {
	if v == nil {
		return nil
	}
	err = multierr.Append(err, enc.AddArray("demoIds", (_List_String_Zapper)(v.DemoIds)))
	if v.DemoType != nil {
		err = multierr.Append(err, enc.AddObject("demoType", *v.DemoType))
	}
	if v.Demos != nil {
		err = multierr.Append(err, enc.AddArray("demos", (_List_DemoType_Zapper)(v.Demos)))
	}
	return err
}

// GetDemoIds returns the value of DemoIds if it is set or its
// zero value if it is unset.
func (v *Bar_ListAndEnum_Args) GetDemoIds() (o []string) {
	if v != nil {
		o = v.DemoIds
	}
	return
}

// IsSetDemoIds returns true if DemoIds is not nil.
func (v *Bar_ListAndEnum_Args) IsSetDemoIds() bool {
	return v != nil && v.DemoIds != nil
}

// GetDemoType returns the value of DemoType if it is set or its
// zero value if it is unset.
func (v *Bar_ListAndEnum_Args) GetDemoType() (o DemoType) {
	if v != nil && v.DemoType != nil {
		return *v.DemoType
	}

	return
}

// IsSetDemoType returns true if DemoType is not nil.
func (v *Bar_ListAndEnum_Args) IsSetDemoType() bool {
	return v != nil && v.DemoType != nil
}

// GetDemos returns the value of Demos if it is set or its
// zero value if it is unset.
func (v *Bar_ListAndEnum_Args) GetDemos() (o []DemoType) {
	if v != nil && v.Demos != nil {
		return v.Demos
	}

	return
}

// IsSetDemos returns true if Demos is not nil.
func (v *Bar_ListAndEnum_Args) IsSetDemos() bool {
	return v != nil && v.Demos != nil
}

// MethodName returns the name of the Thrift function as specified in
// the IDL, for which this struct represent the arguments.
//
// This will always be "listAndEnum" for this struct.
func (v *Bar_ListAndEnum_Args) MethodName() string {
	return "listAndEnum"
}

// EnvelopeType returns the kind of value inside this struct.
//
// This will always be Call for this struct.
func (v *Bar_ListAndEnum_Args) EnvelopeType() wire.EnvelopeType {
	return wire.Call
}

// Bar_ListAndEnum_Helper provides functions that aid in handling the
// parameters and return values of the Bar.listAndEnum
// function.
var Bar_ListAndEnum_Helper = struct {
	// Args accepts the parameters of listAndEnum in-order and returns
	// the arguments struct for the function.
	Args func(
		demoIds []string,
		demoType *DemoType,
		demos []DemoType,
	) *Bar_ListAndEnum_Args

	// IsException returns true if the given error can be thrown
	// by listAndEnum.
	//
	// An error can be thrown by listAndEnum only if the
	// corresponding exception type was mentioned in the 'throws'
	// section for it in the Thrift file.
	IsException func(error) bool

	// WrapResponse returns the result struct for listAndEnum
	// given its return value and error.
	//
	// This allows mapping values and errors returned by
	// listAndEnum into a serializable result struct.
	// WrapResponse returns a non-nil error if the provided
	// error cannot be thrown by listAndEnum
	//
	//   value, err := listAndEnum(args)
	//   result, err := Bar_ListAndEnum_Helper.WrapResponse(value, err)
	//   if err != nil {
	//     return fmt.Errorf("unexpected error from listAndEnum: %v", err)
	//   }
	//   serialize(result)
	WrapResponse func(string, error) (*Bar_ListAndEnum_Result, error)

	// UnwrapResponse takes the result struct for listAndEnum
	// and returns the value or error returned by it.
	//
	// The error is non-nil only if listAndEnum threw an
	// exception.
	//
	//   result := deserialize(bytes)
	//   value, err := Bar_ListAndEnum_Helper.UnwrapResponse(result)
	UnwrapResponse func(*Bar_ListAndEnum_Result) (string, error)
}{}

func init() {
	Bar_ListAndEnum_Helper.Args = func(
		demoIds []string,
		demoType *DemoType,
		demos []DemoType,
	) *Bar_ListAndEnum_Args {
		return &Bar_ListAndEnum_Args{
			DemoIds:  demoIds,
			DemoType: demoType,
			Demos:    demos,
		}
	}

	Bar_ListAndEnum_Helper.IsException = func(err error) bool {
		switch err.(type) {
		case *BarException:
			return true
		default:
			return false
		}
	}

	Bar_ListAndEnum_Helper.WrapResponse = func(success string, err error) (*Bar_ListAndEnum_Result, error) {
		if err == nil {
			return &Bar_ListAndEnum_Result{Success: &success}, nil
		}

		switch e := err.(type) {
		case *BarException:
			if e == nil {
				return nil, errors.New("WrapResponse received non-nil error type with nil value for Bar_ListAndEnum_Result.BarException")
			}
			return &Bar_ListAndEnum_Result{BarException: e}, nil
		}

		return nil, err
	}
	Bar_ListAndEnum_Helper.UnwrapResponse = func(result *Bar_ListAndEnum_Result) (success string, err error) {
		if result.BarException != nil {
			err = result.BarException
			return
		}

		if result.Success != nil {
			success = *result.Success
			return
		}

		err = errors.New("expected a non-void result")
		return
	}

}

// Bar_ListAndEnum_Result represents the result of a Bar.listAndEnum function call.
//
// The result of a listAndEnum execution is sent and received over the wire as this struct.
//
// Success is set only if the function did not throw an exception.
type Bar_ListAndEnum_Result struct {
	// Value returned by listAndEnum after a successful execution.
	Success      *string       `json:"success,omitempty"`
	BarException *BarException `json:"barException,omitempty"`
}

// ToWire translates a Bar_ListAndEnum_Result struct into a Thrift-level intermediate
// representation. This intermediate representation may be serialized
// into bytes using a ThriftRW protocol implementation.
//
// An error is returned if the struct or any of its fields failed to
// validate.
//
//   x, err := v.ToWire()
//   if err != nil {
//     return err
//   }
//
//   if err := binaryProtocol.Encode(x, writer); err != nil {
//     return err
//   }
func (v *Bar_ListAndEnum_Result) ToWire() (wire.Value, error) {
	var (
		fields [2]wire.Field
		i      int = 0
		w      wire.Value
		err    error
	)

	if v.Success != nil {
		w, err = wire.NewValueString(*(v.Success)), error(nil)
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 0, Value: w}
		i++
	}
	if v.BarException != nil {
		w, err = v.BarException.ToWire()
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 1, Value: w}
		i++
	}

	if i != 1 {
		return wire.Value{}, fmt.Errorf("Bar_ListAndEnum_Result should have exactly one field: got %v fields", i)
	}

	return wire.NewValueStruct(wire.Struct{Fields: fields[:i]}), nil
}

// FromWire deserializes a Bar_ListAndEnum_Result struct from its Thrift-level
// representation. The Thrift-level representation may be obtained
// from a ThriftRW protocol implementation.
//
// An error is returned if we were unable to build a Bar_ListAndEnum_Result struct
// from the provided intermediate representation.
//
//   x, err := binaryProtocol.Decode(reader, wire.TStruct)
//   if err != nil {
//     return nil, err
//   }
//
//   var v Bar_ListAndEnum_Result
//   if err := v.FromWire(x); err != nil {
//     return nil, err
//   }
//   return &v, nil
func (v *Bar_ListAndEnum_Result) FromWire(w wire.Value) error {
	var err error

	for _, field := range w.GetStruct().Fields {
		switch field.ID {
		case 0:
			if field.Value.Type() == wire.TBinary {
				var x string
				x, err = field.Value.GetString(), error(nil)
				v.Success = &x
				if err != nil {
					return err
				}

			}
		case 1:
			if field.Value.Type() == wire.TStruct {
				v.BarException, err = _BarException_Read(field.Value)
				if err != nil {
					return err
				}

			}
		}
	}

	count := 0
	if v.Success != nil {
		count++
	}
	if v.BarException != nil {
		count++
	}
	if count != 1 {
		return fmt.Errorf("Bar_ListAndEnum_Result should have exactly one field: got %v fields", count)
	}

	return nil
}

// String returns a readable string representation of a Bar_ListAndEnum_Result
// struct.
func (v *Bar_ListAndEnum_Result) String() string {
	if v == nil {
		return "<nil>"
	}

	var fields [2]string
	i := 0
	if v.Success != nil {
		fields[i] = fmt.Sprintf("Success: %v", *(v.Success))
		i++
	}
	if v.BarException != nil {
		fields[i] = fmt.Sprintf("BarException: %v", v.BarException)
		i++
	}

	return fmt.Sprintf("Bar_ListAndEnum_Result{%v}", strings.Join(fields[:i], ", "))
}

// Equals returns true if all the fields of this Bar_ListAndEnum_Result match the
// provided Bar_ListAndEnum_Result.
//
// This function performs a deep comparison.
func (v *Bar_ListAndEnum_Result) Equals(rhs *Bar_ListAndEnum_Result) bool {
	if v == nil {
		return rhs == nil
	} else if rhs == nil {
		return false
	}
	if !_String_EqualsPtr(v.Success, rhs.Success) {
		return false
	}
	if !((v.BarException == nil && rhs.BarException == nil) || (v.BarException != nil && rhs.BarException != nil && v.BarException.Equals(rhs.BarException))) {
		return false
	}

	return true
}

// MarshalLogObject implements zapcore.ObjectMarshaler, enabling
// fast logging of Bar_ListAndEnum_Result.
func (v *Bar_ListAndEnum_Result) MarshalLogObject(enc zapcore.ObjectEncoder) (err error) {
	if v == nil {
		return nil
	}
	if v.Success != nil {
		enc.AddString("success", *v.Success)
	}
	if v.BarException != nil {
		err = multierr.Append(err, enc.AddObject("barException", v.BarException))
	}
	return err
}

// GetSuccess returns the value of Success if it is set or its
// zero value if it is unset.
func (v *Bar_ListAndEnum_Result) GetSuccess() (o string) {
	if v != nil && v.Success != nil {
		return *v.Success
	}

	return
}

// IsSetSuccess returns true if Success is not nil.
func (v *Bar_ListAndEnum_Result) IsSetSuccess() bool {
	return v != nil && v.Success != nil
}

// GetBarException returns the value of BarException if it is set or its
// zero value if it is unset.
func (v *Bar_ListAndEnum_Result) GetBarException() (o *BarException) {
	if v != nil && v.BarException != nil {
		return v.BarException
	}

	return
}

// IsSetBarException returns true if BarException is not nil.
func (v *Bar_ListAndEnum_Result) IsSetBarException() bool {
	return v != nil && v.BarException != nil
}

// MethodName returns the name of the Thrift function as specified in
// the IDL, for which this struct represent the result.
//
// This will always be "listAndEnum" for this struct.
func (v *Bar_ListAndEnum_Result) MethodName() string {
	return "listAndEnum"
}

// EnvelopeType returns the kind of value inside this struct.
//
// This will always be Reply for this struct.
func (v *Bar_ListAndEnum_Result) EnvelopeType() wire.EnvelopeType {
	return wire.Reply
}

// Bar_MissingArg_Args represents the arguments for the Bar.missingArg function.
//
// The arguments for missingArg are sent and received over the wire as this struct.
type Bar_MissingArg_Args struct {
}

// ToWire translates a Bar_MissingArg_Args struct into a Thrift-level intermediate
// representation. This intermediate representation may be serialized
// into bytes using a ThriftRW protocol implementation.
//
// An error is returned if the struct or any of its fields failed to
// validate.
//
//   x, err := v.ToWire()
//   if err != nil {
//     return err
//   }
//
//   if err := binaryProtocol.Encode(x, writer); err != nil {
//     return err
//   }
func (v *Bar_MissingArg_Args) ToWire() (wire.Value, error) {
	var (
		fields [0]wire.Field
		i      int = 0
	)

	return wire.NewValueStruct(wire.Struct{Fields: fields[:i]}), nil
}

// FromWire deserializes a Bar_MissingArg_Args struct from its Thrift-level
// representation. The Thrift-level representation may be obtained
// from a ThriftRW protocol implementation.
//
// An error is returned if we were unable to build a Bar_MissingArg_Args struct
// from the provided intermediate representation.
//
//   x, err := binaryProtocol.Decode(reader, wire.TStruct)
//   if err != nil {
//     return nil, err
//   }
//
//   var v Bar_MissingArg_Args
//   if err := v.FromWire(x); err != nil {
//     return nil, err
//   }
//   return &v, nil
func (v *Bar_MissingArg_Args) FromWire(w wire.Value) error {

	for _, field := range w.GetStruct().Fields {
		switch field.ID {
		}
	}

	return nil
}

// String returns a readable string representation of a Bar_MissingArg_Args
// struct.
func (v *Bar_MissingArg_Args) String() string {
	if v == nil {
		return "<nil>"
	}

	var fields [0]string
	i := 0

	return fmt.Sprintf("Bar_MissingArg_Args{%v}", strings.Join(fields[:i], ", "))
}

// Equals returns true if all the fields of this Bar_MissingArg_Args match the
// provided Bar_MissingArg_Args.
//
// This function performs a deep comparison.
func (v *Bar_MissingArg_Args) Equals(rhs *Bar_MissingArg_Args) bool {
	if v == nil {
		return rhs == nil
	} else if rhs == nil {
		return false
	}

	return true
}

// MarshalLogObject implements zapcore.ObjectMarshaler, enabling
// fast logging of Bar_MissingArg_Args.
func (v *Bar_MissingArg_Args) MarshalLogObject(enc zapcore.ObjectEncoder) (err error) {
	if v == nil {
		return nil
	}
	return err
}

// MethodName returns the name of the Thrift function as specified in
// the IDL, for which this struct represent the arguments.
//
// This will always be "missingArg" for this struct.
func (v *Bar_MissingArg_Args) MethodName() string {
	return "missingArg"
}

// EnvelopeType returns the kind of value inside this struct.
//
// This will always be Call for this struct.
func (v *Bar_MissingArg_Args) EnvelopeType() wire.EnvelopeType {
	return wire.Call
}

// Bar_MissingArg_Helper provides functions that aid in handling the
// parameters and return values of the Bar.missingArg
// function.
var Bar_MissingArg_Helper = struct {
	// Args accepts the parameters of missingArg in-order and returns
	// the arguments struct for the function.
	Args func() *Bar_MissingArg_Args

	// IsException returns true if the given error can be thrown
	// by missingArg.
	//
	// An error can be thrown by missingArg only if the
	// corresponding exception type was mentioned in the 'throws'
	// section for it in the Thrift file.
	IsException func(error) bool

	// WrapResponse returns the result struct for missingArg
	// given its return value and error.
	//
	// This allows mapping values and errors returned by
	// missingArg into a serializable result struct.
	// WrapResponse returns a non-nil error if the provided
	// error cannot be thrown by missingArg
	//
	//   value, err := missingArg(args)
	//   result, err := Bar_MissingArg_Helper.WrapResponse(value, err)
	//   if err != nil {
	//     return fmt.Errorf("unexpected error from missingArg: %v", err)
	//   }
	//   serialize(result)
	WrapResponse func(*BarResponse, error) (*Bar_MissingArg_Result, error)

	// UnwrapResponse takes the result struct for missingArg
	// and returns the value or error returned by it.
	//
	// The error is non-nil only if missingArg threw an
	// exception.
	//
	//   result := deserialize(bytes)
	//   value, err := Bar_MissingArg_Helper.UnwrapResponse(result)
	UnwrapResponse func(*Bar_MissingArg_Result) (*BarResponse, error)
}{}

func init() {
	Bar_MissingArg_Helper.Args = func() *Bar_MissingArg_Args {
		return &Bar_MissingArg_Args{}
	}

	Bar_MissingArg_Helper.IsException = func(err error) bool {
		switch err.(type) {
		case *BarException:
			return true
		default:
			return false
		}
	}

	Bar_MissingArg_Helper.WrapResponse = func(success *BarResponse, err error) (*Bar_MissingArg_Result, error) {
		if err == nil {
			return &Bar_MissingArg_Result{Success: success}, nil
		}

		switch e := err.(type) {
		case *BarException:
			if e == nil {
				return nil, errors.New("WrapResponse received non-nil error type with nil value for Bar_MissingArg_Result.BarException")
			}
			return &Bar_MissingArg_Result{BarException: e}, nil
		}

		return nil, err
	}
	Bar_MissingArg_Helper.UnwrapResponse = func(result *Bar_MissingArg_Result) (success *BarResponse, err error) {
		if result.BarException != nil {
			err = result.BarException
			return
		}

		if result.Success != nil {
			success = result.Success
			return
		}

		err = errors.New("expected a non-void result")
		return
	}

}

// Bar_MissingArg_Result represents the result of a Bar.missingArg function call.
//
// The result of a missingArg execution is sent and received over the wire as this struct.
//
// Success is set only if the function did not throw an exception.
type Bar_MissingArg_Result struct {
	// Value returned by missingArg after a successful execution.
	Success      *BarResponse  `json:"success,omitempty"`
	BarException *BarException `json:"barException,omitempty"`
}

// ToWire translates a Bar_MissingArg_Result struct into a Thrift-level intermediate
// representation. This intermediate representation may be serialized
// into bytes using a ThriftRW protocol implementation.
//
// An error is returned if the struct or any of its fields failed to
// validate.
//
//   x, err := v.ToWire()
//   if err != nil {
//     return err
//   }
//
//   if err := binaryProtocol.Encode(x, writer); err != nil {
//     return err
//   }
func (v *Bar_MissingArg_Result) ToWire() (wire.Value, error) {
	var (
		fields [2]wire.Field
		i      int = 0
		w      wire.Value
		err    error
	)

	if v.Success != nil {
		w, err = v.Success.ToWire()
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 0, Value: w}
		i++
	}
	if v.BarException != nil {
		w, err = v.BarException.ToWire()
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 1, Value: w}
		i++
	}

	if i != 1 {
		return wire.Value{}, fmt.Errorf("Bar_MissingArg_Result should have exactly one field: got %v fields", i)
	}

	return wire.NewValueStruct(wire.Struct{Fields: fields[:i]}), nil
}

// FromWire deserializes a Bar_MissingArg_Result struct from its Thrift-level
// representation. The Thrift-level representation may be obtained
// from a ThriftRW protocol implementation.
//
// An error is returned if we were unable to build a Bar_MissingArg_Result struct
// from the provided intermediate representation.
//
//   x, err := binaryProtocol.Decode(reader, wire.TStruct)
//   if err != nil {
//     return nil, err
//   }
//
//   var v Bar_MissingArg_Result
//   if err := v.FromWire(x); err != nil {
//     return nil, err
//   }
//   return &v, nil
func (v *Bar_MissingArg_Result) FromWire(w wire.Value) error {
	var err error

	for _, field := range w.GetStruct().Fields {
		switch field.ID {
		case 0:
			if field.Value.Type() == wire.TStruct {
				v.Success, err = _BarResponse_Read(field.Value)
				if err != nil {
					return err
				}

			}
		case 1:
			if field.Value.Type() == wire.TStruct {
				v.BarException, err = _BarException_Read(field.Value)
				if err != nil {
					return err
				}

			}
		}
	}

	count := 0
	if v.Success != nil {
		count++
	}
	if v.BarException != nil {
		count++
	}
	if count != 1 {
		return fmt.Errorf("Bar_MissingArg_Result should have exactly one field: got %v fields", count)
	}

	return nil
}

// String returns a readable string representation of a Bar_MissingArg_Result
// struct.
func (v *Bar_MissingArg_Result) String() string {
	if v == nil {
		return "<nil>"
	}

	var fields [2]string
	i := 0
	if v.Success != nil {
		fields[i] = fmt.Sprintf("Success: %v", v.Success)
		i++
	}
	if v.BarException != nil {
		fields[i] = fmt.Sprintf("BarException: %v", v.BarException)
		i++
	}

	return fmt.Sprintf("Bar_MissingArg_Result{%v}", strings.Join(fields[:i], ", "))
}

// Equals returns true if all the fields of this Bar_MissingArg_Result match the
// provided Bar_MissingArg_Result.
//
// This function performs a deep comparison.
func (v *Bar_MissingArg_Result) Equals(rhs *Bar_MissingArg_Result) bool {
	if v == nil {
		return rhs == nil
	} else if rhs == nil {
		return false
	}
	if !((v.Success == nil && rhs.Success == nil) || (v.Success != nil && rhs.Success != nil && v.Success.Equals(rhs.Success))) {
		return false
	}
	if !((v.BarException == nil && rhs.BarException == nil) || (v.BarException != nil && rhs.BarException != nil && v.BarException.Equals(rhs.BarException))) {
		return false
	}

	return true
}

// MarshalLogObject implements zapcore.ObjectMarshaler, enabling
// fast logging of Bar_MissingArg_Result.
func (v *Bar_MissingArg_Result) MarshalLogObject(enc zapcore.ObjectEncoder) (err error) {
	if v == nil {
		return nil
	}
	if v.Success != nil {
		err = multierr.Append(err, enc.AddObject("success", v.Success))
	}
	if v.BarException != nil {
		err = multierr.Append(err, enc.AddObject("barException", v.BarException))
	}
	return err
}

// GetSuccess returns the value of Success if it is set or its
// zero value if it is unset.
func (v *Bar_MissingArg_Result) GetSuccess() (o *BarResponse) {
	if v != nil && v.Success != nil {
		return v.Success
	}

	return
}

// IsSetSuccess returns true if Success is not nil.
func (v *Bar_MissingArg_Result) IsSetSuccess() bool {
	return v != nil && v.Success != nil
}

// GetBarException returns the value of BarException if it is set or its
// zero value if it is unset.
func (v *Bar_MissingArg_Result) GetBarException() (o *BarException) {
	if v != nil && v.BarException != nil {
		return v.BarException
	}

	return
}

// IsSetBarException returns true if BarException is not nil.
func (v *Bar_MissingArg_Result) IsSetBarException() bool {
	return v != nil && v.BarException != nil
}

// MethodName returns the name of the Thrift function as specified in
// the IDL, for which this struct represent the result.
//
// This will always be "missingArg" for this struct.
func (v *Bar_MissingArg_Result) MethodName() string {
	return "missingArg"
}

// EnvelopeType returns the kind of value inside this struct.
//
// This will always be Reply for this struct.
func (v *Bar_MissingArg_Result) EnvelopeType() wire.EnvelopeType {
	return wire.Reply
}

// Bar_NoRequest_Args represents the arguments for the Bar.noRequest function.
//
// The arguments for noRequest are sent and received over the wire as this struct.
type Bar_NoRequest_Args struct {
}

// ToWire translates a Bar_NoRequest_Args struct into a Thrift-level intermediate
// representation. This intermediate representation may be serialized
// into bytes using a ThriftRW protocol implementation.
//
// An error is returned if the struct or any of its fields failed to
// validate.
//
//   x, err := v.ToWire()
//   if err != nil {
//     return err
//   }
//
//   if err := binaryProtocol.Encode(x, writer); err != nil {
//     return err
//   }
func (v *Bar_NoRequest_Args) ToWire() (wire.Value, error) {
	var (
		fields [0]wire.Field
		i      int = 0
	)

	return wire.NewValueStruct(wire.Struct{Fields: fields[:i]}), nil
}

// FromWire deserializes a Bar_NoRequest_Args struct from its Thrift-level
// representation. The Thrift-level representation may be obtained
// from a ThriftRW protocol implementation.
//
// An error is returned if we were unable to build a Bar_NoRequest_Args struct
// from the provided intermediate representation.
//
//   x, err := binaryProtocol.Decode(reader, wire.TStruct)
//   if err != nil {
//     return nil, err
//   }
//
//   var v Bar_NoRequest_Args
//   if err := v.FromWire(x); err != nil {
//     return nil, err
//   }
//   return &v, nil
func (v *Bar_NoRequest_Args) FromWire(w wire.Value) error {

	for _, field := range w.GetStruct().Fields {
		switch field.ID {
		}
	}

	return nil
}

// String returns a readable string representation of a Bar_NoRequest_Args
// struct.
func (v *Bar_NoRequest_Args) String() string {
	if v == nil {
		return "<nil>"
	}

	var fields [0]string
	i := 0

	return fmt.Sprintf("Bar_NoRequest_Args{%v}", strings.Join(fields[:i], ", "))
}

// Equals returns true if all the fields of this Bar_NoRequest_Args match the
// provided Bar_NoRequest_Args.
//
// This function performs a deep comparison.
func (v *Bar_NoRequest_Args) Equals(rhs *Bar_NoRequest_Args) bool {
	if v == nil {
		return rhs == nil
	} else if rhs == nil {
		return false
	}

	return true
}

// MarshalLogObject implements zapcore.ObjectMarshaler, enabling
// fast logging of Bar_NoRequest_Args.
func (v *Bar_NoRequest_Args) MarshalLogObject(enc zapcore.ObjectEncoder) (err error) {
	if v == nil {
		return nil
	}
	return err
}

// MethodName returns the name of the Thrift function as specified in
// the IDL, for which this struct represent the arguments.
//
// This will always be "noRequest" for this struct.
func (v *Bar_NoRequest_Args) MethodName() string {
	return "noRequest"
}

// EnvelopeType returns the kind of value inside this struct.
//
// This will always be Call for this struct.
func (v *Bar_NoRequest_Args) EnvelopeType() wire.EnvelopeType {
	return wire.Call
}

// Bar_NoRequest_Helper provides functions that aid in handling the
// parameters and return values of the Bar.noRequest
// function.
var Bar_NoRequest_Helper = struct {
	// Args accepts the parameters of noRequest in-order and returns
	// the arguments struct for the function.
	Args func() *Bar_NoRequest_Args

	// IsException returns true if the given error can be thrown
	// by noRequest.
	//
	// An error can be thrown by noRequest only if the
	// corresponding exception type was mentioned in the 'throws'
	// section for it in the Thrift file.
	IsException func(error) bool

	// WrapResponse returns the result struct for noRequest
	// given its return value and error.
	//
	// This allows mapping values and errors returned by
	// noRequest into a serializable result struct.
	// WrapResponse returns a non-nil error if the provided
	// error cannot be thrown by noRequest
	//
	//   value, err := noRequest(args)
	//   result, err := Bar_NoRequest_Helper.WrapResponse(value, err)
	//   if err != nil {
	//     return fmt.Errorf("unexpected error from noRequest: %v", err)
	//   }
	//   serialize(result)
	WrapResponse func(*BarResponse, error) (*Bar_NoRequest_Result, error)

	// UnwrapResponse takes the result struct for noRequest
	// and returns the value or error returned by it.
	//
	// The error is non-nil only if noRequest threw an
	// exception.
	//
	//   result := deserialize(bytes)
	//   value, err := Bar_NoRequest_Helper.UnwrapResponse(result)
	UnwrapResponse func(*Bar_NoRequest_Result) (*BarResponse, error)
}{}

func init() {
	Bar_NoRequest_Helper.Args = func() *Bar_NoRequest_Args {
		return &Bar_NoRequest_Args{}
	}

	Bar_NoRequest_Helper.IsException = func(err error) bool {
		switch err.(type) {
		case *BarException:
			return true
		default:
			return false
		}
	}

	Bar_NoRequest_Helper.WrapResponse = func(success *BarResponse, err error) (*Bar_NoRequest_Result, error) {
		if err == nil {
			return &Bar_NoRequest_Result{Success: success}, nil
		}

		switch e := err.(type) {
		case *BarException:
			if e == nil {
				return nil, errors.New("WrapResponse received non-nil error type with nil value for Bar_NoRequest_Result.BarException")
			}
			return &Bar_NoRequest_Result{BarException: e}, nil
		}

		return nil, err
	}
	Bar_NoRequest_Helper.UnwrapResponse = func(result *Bar_NoRequest_Result) (success *BarResponse, err error) {
		if result.BarException != nil {
			err = result.BarException
			return
		}

		if result.Success != nil {
			success = result.Success
			return
		}

		err = errors.New("expected a non-void result")
		return
	}

}

// Bar_NoRequest_Result represents the result of a Bar.noRequest function call.
//
// The result of a noRequest execution is sent and received over the wire as this struct.
//
// Success is set only if the function did not throw an exception.
type Bar_NoRequest_Result struct {
	// Value returned by noRequest after a successful execution.
	Success      *BarResponse  `json:"success,omitempty"`
	BarException *BarException `json:"barException,omitempty"`
}

// ToWire translates a Bar_NoRequest_Result struct into a Thrift-level intermediate
// representation. This intermediate representation may be serialized
// into bytes using a ThriftRW protocol implementation.
//
// An error is returned if the struct or any of its fields failed to
// validate.
//
//   x, err := v.ToWire()
//   if err != nil {
//     return err
//   }
//
//   if err := binaryProtocol.Encode(x, writer); err != nil {
//     return err
//   }
func (v *Bar_NoRequest_Result) ToWire() (wire.Value, error) {
	var (
		fields [2]wire.Field
		i      int = 0
		w      wire.Value
		err    error
	)

	if v.Success != nil {
		w, err = v.Success.ToWire()
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 0, Value: w}
		i++
	}
	if v.BarException != nil {
		w, err = v.BarException.ToWire()
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 1, Value: w}
		i++
	}

	if i != 1 {
		return wire.Value{}, fmt.Errorf("Bar_NoRequest_Result should have exactly one field: got %v fields", i)
	}

	return wire.NewValueStruct(wire.Struct{Fields: fields[:i]}), nil
}

// FromWire deserializes a Bar_NoRequest_Result struct from its Thrift-level
// representation. The Thrift-level representation may be obtained
// from a ThriftRW protocol implementation.
//
// An error is returned if we were unable to build a Bar_NoRequest_Result struct
// from the provided intermediate representation.
//
//   x, err := binaryProtocol.Decode(reader, wire.TStruct)
//   if err != nil {
//     return nil, err
//   }
//
//   var v Bar_NoRequest_Result
//   if err := v.FromWire(x); err != nil {
//     return nil, err
//   }
//   return &v, nil
func (v *Bar_NoRequest_Result) FromWire(w wire.Value) error {
	var err error

	for _, field := range w.GetStruct().Fields {
		switch field.ID {
		case 0:
			if field.Value.Type() == wire.TStruct {
				v.Success, err = _BarResponse_Read(field.Value)
				if err != nil {
					return err
				}

			}
		case 1:
			if field.Value.Type() == wire.TStruct {
				v.BarException, err = _BarException_Read(field.Value)
				if err != nil {
					return err
				}

			}
		}
	}

	count := 0
	if v.Success != nil {
		count++
	}
	if v.BarException != nil {
		count++
	}
	if count != 1 {
		return fmt.Errorf("Bar_NoRequest_Result should have exactly one field: got %v fields", count)
	}

	return nil
}

// String returns a readable string representation of a Bar_NoRequest_Result
// struct.
func (v *Bar_NoRequest_Result) String() string {
	if v == nil {
		return "<nil>"
	}

	var fields [2]string
	i := 0
	if v.Success != nil {
		fields[i] = fmt.Sprintf("Success: %v", v.Success)
		i++
	}
	if v.BarException != nil {
		fields[i] = fmt.Sprintf("BarException: %v", v.BarException)
		i++
	}

	return fmt.Sprintf("Bar_NoRequest_Result{%v}", strings.Join(fields[:i], ", "))
}

// Equals returns true if all the fields of this Bar_NoRequest_Result match the
// provided Bar_NoRequest_Result.
//
// This function performs a deep comparison.
func (v *Bar_NoRequest_Result) Equals(rhs *Bar_NoRequest_Result) bool {
	if v == nil {
		return rhs == nil
	} else if rhs == nil {
		return false
	}
	if !((v.Success == nil && rhs.Success == nil) || (v.Success != nil && rhs.Success != nil && v.Success.Equals(rhs.Success))) {
		return false
	}
	if !((v.BarException == nil && rhs.BarException == nil) || (v.BarException != nil && rhs.BarException != nil && v.BarException.Equals(rhs.BarException))) {
		return false
	}

	return true
}

// MarshalLogObject implements zapcore.ObjectMarshaler, enabling
// fast logging of Bar_NoRequest_Result.
func (v *Bar_NoRequest_Result) MarshalLogObject(enc zapcore.ObjectEncoder) (err error) {
	if v == nil {
		return nil
	}
	if v.Success != nil {
		err = multierr.Append(err, enc.AddObject("success", v.Success))
	}
	if v.BarException != nil {
		err = multierr.Append(err, enc.AddObject("barException", v.BarException))
	}
	return err
}

// GetSuccess returns the value of Success if it is set or its
// zero value if it is unset.
func (v *Bar_NoRequest_Result) GetSuccess() (o *BarResponse) {
	if v != nil && v.Success != nil {
		return v.Success
	}

	return
}

// IsSetSuccess returns true if Success is not nil.
func (v *Bar_NoRequest_Result) IsSetSuccess() bool {
	return v != nil && v.Success != nil
}

// GetBarException returns the value of BarException if it is set or its
// zero value if it is unset.
func (v *Bar_NoRequest_Result) GetBarException() (o *BarException) {
	if v != nil && v.BarException != nil {
		return v.BarException
	}

	return
}

// IsSetBarException returns true if BarException is not nil.
func (v *Bar_NoRequest_Result) IsSetBarException() bool {
	return v != nil && v.BarException != nil
}

// MethodName returns the name of the Thrift function as specified in
// the IDL, for which this struct represent the result.
//
// This will always be "noRequest" for this struct.
func (v *Bar_NoRequest_Result) MethodName() string {
	return "noRequest"
}

// EnvelopeType returns the kind of value inside this struct.
//
// This will always be Reply for this struct.
func (v *Bar_NoRequest_Result) EnvelopeType() wire.EnvelopeType {
	return wire.Reply
}

// Bar_Normal_Args represents the arguments for the Bar.normal function.
//
// The arguments for normal are sent and received over the wire as this struct.
type Bar_Normal_Args struct {
	Request *BarRequest `json:"request,required"`
}

// ToWire translates a Bar_Normal_Args struct into a Thrift-level intermediate
// representation. This intermediate representation may be serialized
// into bytes using a ThriftRW protocol implementation.
//
// An error is returned if the struct or any of its fields failed to
// validate.
//
//   x, err := v.ToWire()
//   if err != nil {
//     return err
//   }
//
//   if err := binaryProtocol.Encode(x, writer); err != nil {
//     return err
//   }
func (v *Bar_Normal_Args) ToWire() (wire.Value, error) {
	var (
		fields [1]wire.Field
		i      int = 0
		w      wire.Value
		err    error
	)

	if v.Request == nil {
		return w, errors.New("field Request of Bar_Normal_Args is required")
	}
	w, err = v.Request.ToWire()
	if err != nil {
		return w, err
	}
	fields[i] = wire.Field{ID: 1, Value: w}
	i++

	return wire.NewValueStruct(wire.Struct{Fields: fields[:i]}), nil
}

// FromWire deserializes a Bar_Normal_Args struct from its Thrift-level
// representation. The Thrift-level representation may be obtained
// from a ThriftRW protocol implementation.
//
// An error is returned if we were unable to build a Bar_Normal_Args struct
// from the provided intermediate representation.
//
//   x, err := binaryProtocol.Decode(reader, wire.TStruct)
//   if err != nil {
//     return nil, err
//   }
//
//   var v Bar_Normal_Args
//   if err := v.FromWire(x); err != nil {
//     return nil, err
//   }
//   return &v, nil
func (v *Bar_Normal_Args) FromWire(w wire.Value) error {
	var err error

	requestIsSet := false

	for _, field := range w.GetStruct().Fields {
		switch field.ID {
		case 1:
			if field.Value.Type() == wire.TStruct {
				v.Request, err = _BarRequest_Read(field.Value)
				if err != nil {
					return err
				}
				requestIsSet = true
			}
		}
	}

	if !requestIsSet {
		return errors.New("field Request of Bar_Normal_Args is required")
	}

	return nil
}

// String returns a readable string representation of a Bar_Normal_Args
// struct.
func (v *Bar_Normal_Args) String() string {
	if v == nil {
		return "<nil>"
	}

	var fields [1]string
	i := 0
	fields[i] = fmt.Sprintf("Request: %v", v.Request)
	i++

	return fmt.Sprintf("Bar_Normal_Args{%v}", strings.Join(fields[:i], ", "))
}

// Equals returns true if all the fields of this Bar_Normal_Args match the
// provided Bar_Normal_Args.
//
// This function performs a deep comparison.
func (v *Bar_Normal_Args) Equals(rhs *Bar_Normal_Args) bool {
	if v == nil {
		return rhs == nil
	} else if rhs == nil {
		return false
	}
	if !v.Request.Equals(rhs.Request) {
		return false
	}

	return true
}

// MarshalLogObject implements zapcore.ObjectMarshaler, enabling
// fast logging of Bar_Normal_Args.
func (v *Bar_Normal_Args) MarshalLogObject(enc zapcore.ObjectEncoder) (err error) {
	if v == nil {
		return nil
	}
	err = multierr.Append(err, enc.AddObject("request", v.Request))
	return err
}

// GetRequest returns the value of Request if it is set or its
// zero value if it is unset.
func (v *Bar_Normal_Args) GetRequest() (o *BarRequest) {
	if v != nil {
		o = v.Request
	}
	return
}

// IsSetRequest returns true if Request is not nil.
func (v *Bar_Normal_Args) IsSetRequest() bool {
	return v != nil && v.Request != nil
}

// MethodName returns the name of the Thrift function as specified in
// the IDL, for which this struct represent the arguments.
//
// This will always be "normal" for this struct.
func (v *Bar_Normal_Args) MethodName() string {
	return "normal"
}

// EnvelopeType returns the kind of value inside this struct.
//
// This will always be Call for this struct.
func (v *Bar_Normal_Args) EnvelopeType() wire.EnvelopeType {
	return wire.Call
}

// Bar_Normal_Helper provides functions that aid in handling the
// parameters and return values of the Bar.normal
// function.
var Bar_Normal_Helper = struct {
	// Args accepts the parameters of normal in-order and returns
	// the arguments struct for the function.
	Args func(
		request *BarRequest,
	) *Bar_Normal_Args

	// IsException returns true if the given error can be thrown
	// by normal.
	//
	// An error can be thrown by normal only if the
	// corresponding exception type was mentioned in the 'throws'
	// section for it in the Thrift file.
	IsException func(error) bool

	// WrapResponse returns the result struct for normal
	// given its return value and error.
	//
	// This allows mapping values and errors returned by
	// normal into a serializable result struct.
	// WrapResponse returns a non-nil error if the provided
	// error cannot be thrown by normal
	//
	//   value, err := normal(args)
	//   result, err := Bar_Normal_Helper.WrapResponse(value, err)
	//   if err != nil {
	//     return fmt.Errorf("unexpected error from normal: %v", err)
	//   }
	//   serialize(result)
	WrapResponse func(*BarResponse, error) (*Bar_Normal_Result, error)

	// UnwrapResponse takes the result struct for normal
	// and returns the value or error returned by it.
	//
	// The error is non-nil only if normal threw an
	// exception.
	//
	//   result := deserialize(bytes)
	//   value, err := Bar_Normal_Helper.UnwrapResponse(result)
	UnwrapResponse func(*Bar_Normal_Result) (*BarResponse, error)
}{}

func init() {
	Bar_Normal_Helper.Args = func(
		request *BarRequest,
	) *Bar_Normal_Args {
		return &Bar_Normal_Args{
			Request: request,
		}
	}

	Bar_Normal_Helper.IsException = func(err error) bool {
		switch err.(type) {
		case *BarException:
			return true
		default:
			return false
		}
	}

	Bar_Normal_Helper.WrapResponse = func(success *BarResponse, err error) (*Bar_Normal_Result, error) {
		if err == nil {
			return &Bar_Normal_Result{Success: success}, nil
		}

		switch e := err.(type) {
		case *BarException:
			if e == nil {
				return nil, errors.New("WrapResponse received non-nil error type with nil value for Bar_Normal_Result.BarException")
			}
			return &Bar_Normal_Result{BarException: e}, nil
		}

		return nil, err
	}
	Bar_Normal_Helper.UnwrapResponse = func(result *Bar_Normal_Result) (success *BarResponse, err error) {
		if result.BarException != nil {
			err = result.BarException
			return
		}

		if result.Success != nil {
			success = result.Success
			return
		}

		err = errors.New("expected a non-void result")
		return
	}

}

// Bar_Normal_Result represents the result of a Bar.normal function call.
//
// The result of a normal execution is sent and received over the wire as this struct.
//
// Success is set only if the function did not throw an exception.
type Bar_Normal_Result struct {
	// Value returned by normal after a successful execution.
	Success      *BarResponse  `json:"success,omitempty"`
	BarException *BarException `json:"barException,omitempty"`
}

// ToWire translates a Bar_Normal_Result struct into a Thrift-level intermediate
// representation. This intermediate representation may be serialized
// into bytes using a ThriftRW protocol implementation.
//
// An error is returned if the struct or any of its fields failed to
// validate.
//
//   x, err := v.ToWire()
//   if err != nil {
//     return err
//   }
//
//   if err := binaryProtocol.Encode(x, writer); err != nil {
//     return err
//   }
func (v *Bar_Normal_Result) ToWire() (wire.Value, error) {
	var (
		fields [2]wire.Field
		i      int = 0
		w      wire.Value
		err    error
	)

	if v.Success != nil {
		w, err = v.Success.ToWire()
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 0, Value: w}
		i++
	}
	if v.BarException != nil {
		w, err = v.BarException.ToWire()
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 1, Value: w}
		i++
	}

	if i != 1 {
		return wire.Value{}, fmt.Errorf("Bar_Normal_Result should have exactly one field: got %v fields", i)
	}

	return wire.NewValueStruct(wire.Struct{Fields: fields[:i]}), nil
}

// FromWire deserializes a Bar_Normal_Result struct from its Thrift-level
// representation. The Thrift-level representation may be obtained
// from a ThriftRW protocol implementation.
//
// An error is returned if we were unable to build a Bar_Normal_Result struct
// from the provided intermediate representation.
//
//   x, err := binaryProtocol.Decode(reader, wire.TStruct)
//   if err != nil {
//     return nil, err
//   }
//
//   var v Bar_Normal_Result
//   if err := v.FromWire(x); err != nil {
//     return nil, err
//   }
//   return &v, nil
func (v *Bar_Normal_Result) FromWire(w wire.Value) error {
	var err error

	for _, field := range w.GetStruct().Fields {
		switch field.ID {
		case 0:
			if field.Value.Type() == wire.TStruct {
				v.Success, err = _BarResponse_Read(field.Value)
				if err != nil {
					return err
				}

			}
		case 1:
			if field.Value.Type() == wire.TStruct {
				v.BarException, err = _BarException_Read(field.Value)
				if err != nil {
					return err
				}

			}
		}
	}

	count := 0
	if v.Success != nil {
		count++
	}
	if v.BarException != nil {
		count++
	}
	if count != 1 {
		return fmt.Errorf("Bar_Normal_Result should have exactly one field: got %v fields", count)
	}

	return nil
}

// String returns a readable string representation of a Bar_Normal_Result
// struct.
func (v *Bar_Normal_Result) String() string {
	if v == nil {
		return "<nil>"
	}

	var fields [2]string
	i := 0
	if v.Success != nil {
		fields[i] = fmt.Sprintf("Success: %v", v.Success)
		i++
	}
	if v.BarException != nil {
		fields[i] = fmt.Sprintf("BarException: %v", v.BarException)
		i++
	}

	return fmt.Sprintf("Bar_Normal_Result{%v}", strings.Join(fields[:i], ", "))
}

// Equals returns true if all the fields of this Bar_Normal_Result match the
// provided Bar_Normal_Result.
//
// This function performs a deep comparison.
func (v *Bar_Normal_Result) Equals(rhs *Bar_Normal_Result) bool {
	if v == nil {
		return rhs == nil
	} else if rhs == nil {
		return false
	}
	if !((v.Success == nil && rhs.Success == nil) || (v.Success != nil && rhs.Success != nil && v.Success.Equals(rhs.Success))) {
		return false
	}
	if !((v.BarException == nil && rhs.BarException == nil) || (v.BarException != nil && rhs.BarException != nil && v.BarException.Equals(rhs.BarException))) {
		return false
	}

	return true
}

// MarshalLogObject implements zapcore.ObjectMarshaler, enabling
// fast logging of Bar_Normal_Result.
func (v *Bar_Normal_Result) MarshalLogObject(enc zapcore.ObjectEncoder) (err error) {
	if v == nil {
		return nil
	}
	if v.Success != nil {
		err = multierr.Append(err, enc.AddObject("success", v.Success))
	}
	if v.BarException != nil {
		err = multierr.Append(err, enc.AddObject("barException", v.BarException))
	}
	return err
}

// GetSuccess returns the value of Success if it is set or its
// zero value if it is unset.
func (v *Bar_Normal_Result) GetSuccess() (o *BarResponse) {
	if v != nil && v.Success != nil {
		return v.Success
	}

	return
}

// IsSetSuccess returns true if Success is not nil.
func (v *Bar_Normal_Result) IsSetSuccess() bool {
	return v != nil && v.Success != nil
}

// GetBarException returns the value of BarException if it is set or its
// zero value if it is unset.
func (v *Bar_Normal_Result) GetBarException() (o *BarException) {
	if v != nil && v.BarException != nil {
		return v.BarException
	}

	return
}

// IsSetBarException returns true if BarException is not nil.
func (v *Bar_Normal_Result) IsSetBarException() bool {
	return v != nil && v.BarException != nil
}

// MethodName returns the name of the Thrift function as specified in
// the IDL, for which this struct represent the result.
//
// This will always be "normal" for this struct.
func (v *Bar_Normal_Result) MethodName() string {
	return "normal"
}

// EnvelopeType returns the kind of value inside this struct.
//
// This will always be Reply for this struct.
func (v *Bar_Normal_Result) EnvelopeType() wire.EnvelopeType {
	return wire.Reply
}

// Bar_TooManyArgs_Args represents the arguments for the Bar.tooManyArgs function.
//
// The arguments for tooManyArgs are sent and received over the wire as this struct.
type Bar_TooManyArgs_Args struct {
	Request *BarRequest    `json:"request,required"`
	Foo     *foo.FooStruct `json:"foo,omitempty"`
}

// ToWire translates a Bar_TooManyArgs_Args struct into a Thrift-level intermediate
// representation. This intermediate representation may be serialized
// into bytes using a ThriftRW protocol implementation.
//
// An error is returned if the struct or any of its fields failed to
// validate.
//
//   x, err := v.ToWire()
//   if err != nil {
//     return err
//   }
//
//   if err := binaryProtocol.Encode(x, writer); err != nil {
//     return err
//   }
func (v *Bar_TooManyArgs_Args) ToWire() (wire.Value, error) {
	var (
		fields [2]wire.Field
		i      int = 0
		w      wire.Value
		err    error
	)

	if v.Request == nil {
		return w, errors.New("field Request of Bar_TooManyArgs_Args is required")
	}
	w, err = v.Request.ToWire()
	if err != nil {
		return w, err
	}
	fields[i] = wire.Field{ID: 1, Value: w}
	i++
	if v.Foo != nil {
		w, err = v.Foo.ToWire()
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 2, Value: w}
		i++
	}

	return wire.NewValueStruct(wire.Struct{Fields: fields[:i]}), nil
}

func _FooStruct_Read(w wire.Value) (*foo.FooStruct, error) {
	var v foo.FooStruct
	err := v.FromWire(w)
	return &v, err
}

// FromWire deserializes a Bar_TooManyArgs_Args struct from its Thrift-level
// representation. The Thrift-level representation may be obtained
// from a ThriftRW protocol implementation.
//
// An error is returned if we were unable to build a Bar_TooManyArgs_Args struct
// from the provided intermediate representation.
//
//   x, err := binaryProtocol.Decode(reader, wire.TStruct)
//   if err != nil {
//     return nil, err
//   }
//
//   var v Bar_TooManyArgs_Args
//   if err := v.FromWire(x); err != nil {
//     return nil, err
//   }
//   return &v, nil
func (v *Bar_TooManyArgs_Args) FromWire(w wire.Value) error {
	var err error

	requestIsSet := false

	for _, field := range w.GetStruct().Fields {
		switch field.ID {
		case 1:
			if field.Value.Type() == wire.TStruct {
				v.Request, err = _BarRequest_Read(field.Value)
				if err != nil {
					return err
				}
				requestIsSet = true
			}
		case 2:
			if field.Value.Type() == wire.TStruct {
				v.Foo, err = _FooStruct_Read(field.Value)
				if err != nil {
					return err
				}

			}
		}
	}

	if !requestIsSet {
		return errors.New("field Request of Bar_TooManyArgs_Args is required")
	}

	return nil
}

// String returns a readable string representation of a Bar_TooManyArgs_Args
// struct.
func (v *Bar_TooManyArgs_Args) String() string {
	if v == nil {
		return "<nil>"
	}

	var fields [2]string
	i := 0
	fields[i] = fmt.Sprintf("Request: %v", v.Request)
	i++
	if v.Foo != nil {
		fields[i] = fmt.Sprintf("Foo: %v", v.Foo)
		i++
	}

	return fmt.Sprintf("Bar_TooManyArgs_Args{%v}", strings.Join(fields[:i], ", "))
}

// Equals returns true if all the fields of this Bar_TooManyArgs_Args match the
// provided Bar_TooManyArgs_Args.
//
// This function performs a deep comparison.
func (v *Bar_TooManyArgs_Args) Equals(rhs *Bar_TooManyArgs_Args) bool {
	if v == nil {
		return rhs == nil
	} else if rhs == nil {
		return false
	}
	if !v.Request.Equals(rhs.Request) {
		return false
	}
	if !((v.Foo == nil && rhs.Foo == nil) || (v.Foo != nil && rhs.Foo != nil && v.Foo.Equals(rhs.Foo))) {
		return false
	}

	return true
}

// MarshalLogObject implements zapcore.ObjectMarshaler, enabling
// fast logging of Bar_TooManyArgs_Args.
func (v *Bar_TooManyArgs_Args) MarshalLogObject(enc zapcore.ObjectEncoder) (err error) {
	if v == nil {
		return nil
	}
	err = multierr.Append(err, enc.AddObject("request", v.Request))
	if v.Foo != nil {
		err = multierr.Append(err, enc.AddObject("foo", v.Foo))
	}
	return err
}

// GetRequest returns the value of Request if it is set or its
// zero value if it is unset.
func (v *Bar_TooManyArgs_Args) GetRequest() (o *BarRequest) {
	if v != nil {
		o = v.Request
	}
	return
}

// IsSetRequest returns true if Request is not nil.
func (v *Bar_TooManyArgs_Args) IsSetRequest() bool {
	return v != nil && v.Request != nil
}

// GetFoo returns the value of Foo if it is set or its
// zero value if it is unset.
func (v *Bar_TooManyArgs_Args) GetFoo() (o *foo.FooStruct) {
	if v != nil && v.Foo != nil {
		return v.Foo
	}

	return
}

// IsSetFoo returns true if Foo is not nil.
func (v *Bar_TooManyArgs_Args) IsSetFoo() bool {
	return v != nil && v.Foo != nil
}

// MethodName returns the name of the Thrift function as specified in
// the IDL, for which this struct represent the arguments.
//
// This will always be "tooManyArgs" for this struct.
func (v *Bar_TooManyArgs_Args) MethodName() string {
	return "tooManyArgs"
}

// EnvelopeType returns the kind of value inside this struct.
//
// This will always be Call for this struct.
func (v *Bar_TooManyArgs_Args) EnvelopeType() wire.EnvelopeType {
	return wire.Call
}

// Bar_TooManyArgs_Helper provides functions that aid in handling the
// parameters and return values of the Bar.tooManyArgs
// function.
var Bar_TooManyArgs_Helper = struct {
	// Args accepts the parameters of tooManyArgs in-order and returns
	// the arguments struct for the function.
	Args func(
		request *BarRequest,
		foo *foo.FooStruct,
	) *Bar_TooManyArgs_Args

	// IsException returns true if the given error can be thrown
	// by tooManyArgs.
	//
	// An error can be thrown by tooManyArgs only if the
	// corresponding exception type was mentioned in the 'throws'
	// section for it in the Thrift file.
	IsException func(error) bool

	// WrapResponse returns the result struct for tooManyArgs
	// given its return value and error.
	//
	// This allows mapping values and errors returned by
	// tooManyArgs into a serializable result struct.
	// WrapResponse returns a non-nil error if the provided
	// error cannot be thrown by tooManyArgs
	//
	//   value, err := tooManyArgs(args)
	//   result, err := Bar_TooManyArgs_Helper.WrapResponse(value, err)
	//   if err != nil {
	//     return fmt.Errorf("unexpected error from tooManyArgs: %v", err)
	//   }
	//   serialize(result)
	WrapResponse func(*BarResponse, error) (*Bar_TooManyArgs_Result, error)

	// UnwrapResponse takes the result struct for tooManyArgs
	// and returns the value or error returned by it.
	//
	// The error is non-nil only if tooManyArgs threw an
	// exception.
	//
	//   result := deserialize(bytes)
	//   value, err := Bar_TooManyArgs_Helper.UnwrapResponse(result)
	UnwrapResponse func(*Bar_TooManyArgs_Result) (*BarResponse, error)
}{}

func init() {
	Bar_TooManyArgs_Helper.Args = func(
		request *BarRequest,
		foo *foo.FooStruct,
	) *Bar_TooManyArgs_Args {
		return &Bar_TooManyArgs_Args{
			Request: request,
			Foo:     foo,
		}
	}

	Bar_TooManyArgs_Helper.IsException = func(err error) bool {
		switch err.(type) {
		case *BarException:
			return true
		case *foo.FooException:
			return true
		default:
			return false
		}
	}

	Bar_TooManyArgs_Helper.WrapResponse = func(success *BarResponse, err error) (*Bar_TooManyArgs_Result, error) {
		if err == nil {
			return &Bar_TooManyArgs_Result{Success: success}, nil
		}

		switch e := err.(type) {
		case *BarException:
			if e == nil {
				return nil, errors.New("WrapResponse received non-nil error type with nil value for Bar_TooManyArgs_Result.BarException")
			}
			return &Bar_TooManyArgs_Result{BarException: e}, nil
		case *foo.FooException:
			if e == nil {
				return nil, errors.New("WrapResponse received non-nil error type with nil value for Bar_TooManyArgs_Result.FooException")
			}
			return &Bar_TooManyArgs_Result{FooException: e}, nil
		}

		return nil, err
	}
	Bar_TooManyArgs_Helper.UnwrapResponse = func(result *Bar_TooManyArgs_Result) (success *BarResponse, err error) {
		if result.BarException != nil {
			err = result.BarException
			return
		}
		if result.FooException != nil {
			err = result.FooException
			return
		}

		if result.Success != nil {
			success = result.Success
			return
		}

		err = errors.New("expected a non-void result")
		return
	}

}

// Bar_TooManyArgs_Result represents the result of a Bar.tooManyArgs function call.
//
// The result of a tooManyArgs execution is sent and received over the wire as this struct.
//
// Success is set only if the function did not throw an exception.
type Bar_TooManyArgs_Result struct {
	// Value returned by tooManyArgs after a successful execution.
	Success      *BarResponse      `json:"success,omitempty"`
	BarException *BarException     `json:"barException,omitempty"`
	FooException *foo.FooException `json:"fooException,omitempty"`
}

// ToWire translates a Bar_TooManyArgs_Result struct into a Thrift-level intermediate
// representation. This intermediate representation may be serialized
// into bytes using a ThriftRW protocol implementation.
//
// An error is returned if the struct or any of its fields failed to
// validate.
//
//   x, err := v.ToWire()
//   if err != nil {
//     return err
//   }
//
//   if err := binaryProtocol.Encode(x, writer); err != nil {
//     return err
//   }
func (v *Bar_TooManyArgs_Result) ToWire() (wire.Value, error) {
	var (
		fields [3]wire.Field
		i      int = 0
		w      wire.Value
		err    error
	)

	if v.Success != nil {
		w, err = v.Success.ToWire()
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 0, Value: w}
		i++
	}
	if v.BarException != nil {
		w, err = v.BarException.ToWire()
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 1, Value: w}
		i++
	}
	if v.FooException != nil {
		w, err = v.FooException.ToWire()
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 2, Value: w}
		i++
	}

	if i != 1 {
		return wire.Value{}, fmt.Errorf("Bar_TooManyArgs_Result should have exactly one field: got %v fields", i)
	}

	return wire.NewValueStruct(wire.Struct{Fields: fields[:i]}), nil
}

func _FooException_Read(w wire.Value) (*foo.FooException, error) {
	var v foo.FooException
	err := v.FromWire(w)
	return &v, err
}

// FromWire deserializes a Bar_TooManyArgs_Result struct from its Thrift-level
// representation. The Thrift-level representation may be obtained
// from a ThriftRW protocol implementation.
//
// An error is returned if we were unable to build a Bar_TooManyArgs_Result struct
// from the provided intermediate representation.
//
//   x, err := binaryProtocol.Decode(reader, wire.TStruct)
//   if err != nil {
//     return nil, err
//   }
//
//   var v Bar_TooManyArgs_Result
//   if err := v.FromWire(x); err != nil {
//     return nil, err
//   }
//   return &v, nil
func (v *Bar_TooManyArgs_Result) FromWire(w wire.Value) error {
	var err error

	for _, field := range w.GetStruct().Fields {
		switch field.ID {
		case 0:
			if field.Value.Type() == wire.TStruct {
				v.Success, err = _BarResponse_Read(field.Value)
				if err != nil {
					return err
				}

			}
		case 1:
			if field.Value.Type() == wire.TStruct {
				v.BarException, err = _BarException_Read(field.Value)
				if err != nil {
					return err
				}

			}
		case 2:
			if field.Value.Type() == wire.TStruct {
				v.FooException, err = _FooException_Read(field.Value)
				if err != nil {
					return err
				}

			}
		}
	}

	count := 0
	if v.Success != nil {
		count++
	}
	if v.BarException != nil {
		count++
	}
	if v.FooException != nil {
		count++
	}
	if count != 1 {
		return fmt.Errorf("Bar_TooManyArgs_Result should have exactly one field: got %v fields", count)
	}

	return nil
}

// String returns a readable string representation of a Bar_TooManyArgs_Result
// struct.
func (v *Bar_TooManyArgs_Result) String() string {
	if v == nil {
		return "<nil>"
	}

	var fields [3]string
	i := 0
	if v.Success != nil {
		fields[i] = fmt.Sprintf("Success: %v", v.Success)
		i++
	}
	if v.BarException != nil {
		fields[i] = fmt.Sprintf("BarException: %v", v.BarException)
		i++
	}
	if v.FooException != nil {
		fields[i] = fmt.Sprintf("FooException: %v", v.FooException)
		i++
	}

	return fmt.Sprintf("Bar_TooManyArgs_Result{%v}", strings.Join(fields[:i], ", "))
}

// Equals returns true if all the fields of this Bar_TooManyArgs_Result match the
// provided Bar_TooManyArgs_Result.
//
// This function performs a deep comparison.
func (v *Bar_TooManyArgs_Result) Equals(rhs *Bar_TooManyArgs_Result) bool {
	if v == nil {
		return rhs == nil
	} else if rhs == nil {
		return false
	}
	if !((v.Success == nil && rhs.Success == nil) || (v.Success != nil && rhs.Success != nil && v.Success.Equals(rhs.Success))) {
		return false
	}
	if !((v.BarException == nil && rhs.BarException == nil) || (v.BarException != nil && rhs.BarException != nil && v.BarException.Equals(rhs.BarException))) {
		return false
	}
	if !((v.FooException == nil && rhs.FooException == nil) || (v.FooException != nil && rhs.FooException != nil && v.FooException.Equals(rhs.FooException))) {
		return false
	}

	return true
}

// MarshalLogObject implements zapcore.ObjectMarshaler, enabling
// fast logging of Bar_TooManyArgs_Result.
func (v *Bar_TooManyArgs_Result) MarshalLogObject(enc zapcore.ObjectEncoder) (err error) {
	if v == nil {
		return nil
	}
	if v.Success != nil {
		err = multierr.Append(err, enc.AddObject("success", v.Success))
	}
	if v.BarException != nil {
		err = multierr.Append(err, enc.AddObject("barException", v.BarException))
	}
	if v.FooException != nil {
		err = multierr.Append(err, enc.AddObject("fooException", v.FooException))
	}
	return err
}

// GetSuccess returns the value of Success if it is set or its
// zero value if it is unset.
func (v *Bar_TooManyArgs_Result) GetSuccess() (o *BarResponse) {
	if v != nil && v.Success != nil {
		return v.Success
	}

	return
}

// IsSetSuccess returns true if Success is not nil.
func (v *Bar_TooManyArgs_Result) IsSetSuccess() bool {
	return v != nil && v.Success != nil
}

// GetBarException returns the value of BarException if it is set or its
// zero value if it is unset.
func (v *Bar_TooManyArgs_Result) GetBarException() (o *BarException) {
	if v != nil && v.BarException != nil {
		return v.BarException
	}

	return
}

// IsSetBarException returns true if BarException is not nil.
func (v *Bar_TooManyArgs_Result) IsSetBarException() bool {
	return v != nil && v.BarException != nil
}

// GetFooException returns the value of FooException if it is set or its
// zero value if it is unset.
func (v *Bar_TooManyArgs_Result) GetFooException() (o *foo.FooException) {
	if v != nil && v.FooException != nil {
		return v.FooException
	}

	return
}

// IsSetFooException returns true if FooException is not nil.
func (v *Bar_TooManyArgs_Result) IsSetFooException() bool {
	return v != nil && v.FooException != nil
}

// MethodName returns the name of the Thrift function as specified in
// the IDL, for which this struct represent the result.
//
// This will always be "tooManyArgs" for this struct.
func (v *Bar_TooManyArgs_Result) MethodName() string {
	return "tooManyArgs"
}

// EnvelopeType returns the kind of value inside this struct.
//
// This will always be Reply for this struct.
func (v *Bar_TooManyArgs_Result) EnvelopeType() wire.EnvelopeType {
	return wire.Reply
}
